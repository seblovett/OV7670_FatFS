
OV7670_FATFS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000017c  00800100  000077fe  00007892  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000077fe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b0c  0080027c  0080027c  00007a0e  2**0
                  ALLOC
  3 .stab         00000948  00000000  00000000  00007a10  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000020f  00000000  00000000  00008358  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  00008568  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004cff  00000000  00000000  00008748  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f03  00000000  00000000  0000d447  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d2a  00000000  00000000  0000e34a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001080  00000000  00000000  00010074  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009d2  00000000  00000000  000110f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000675d  00000000  00000000  00011ac6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00018223  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c2 04 	jmp	0x984	; 0x984 <__ctors_end>
       4:	0c 94 2d 37 	jmp	0x6e5a	; 0x6e5a <__vector_1>
       8:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
       c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      10:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      14:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      18:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      1c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      20:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      24:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      28:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      2c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      30:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      34:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      38:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      3c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      40:	0c 94 79 2a 	jmp	0x54f2	; 0x54f2 <__vector_16>
      44:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      48:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      4c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      50:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      54:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      58:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      5c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      60:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      64:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      68:	0c 94 83 39 	jmp	0x7306	; 0x7306 <__vector_26>
      6c:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      70:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      74:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      78:	0c 94 df 04 	jmp	0x9be	; 0x9be <__bad_interrupt>
      7c:	52 2f       	mov	r21, r18
      7e:	64 2b       	or	r22, r20
      80:	64 2b       	or	r22, r20
      82:	64 2b       	or	r22, r20
      84:	64 2b       	or	r22, r20
      86:	64 2b       	or	r22, r20
      88:	64 2b       	or	r22, r20
      8a:	64 2b       	or	r22, r20
      8c:	64 2b       	or	r22, r20
      8e:	64 2b       	or	r22, r20
      90:	64 2b       	or	r22, r20
      92:	64 2b       	or	r22, r20
      94:	64 2b       	or	r22, r20
      96:	64 2b       	or	r22, r20
      98:	8d 34       	cpi	r24, 0x4D	; 77
      9a:	64 2b       	or	r22, r20
      9c:	64 2b       	or	r22, r20
      9e:	64 2b       	or	r22, r20
      a0:	64 2b       	or	r22, r20
      a2:	64 2b       	or	r22, r20
      a4:	64 2b       	or	r22, r20
      a6:	64 2b       	or	r22, r20
      a8:	64 2b       	or	r22, r20
      aa:	64 2b       	or	r22, r20
      ac:	ed 34       	cpi	r30, 0x4D	; 77
      ae:	64 2b       	or	r22, r20
      b0:	06 32       	cpi	r16, 0x26	; 38
      b2:	26 33       	cpi	r18, 0x36	; 54
      b4:	0d 32       	cpi	r16, 0x2D	; 45
      b6:	64 2b       	or	r22, r20
      b8:	2d 2f       	mov	r18, r29
      ba:	64 2b       	or	r22, r20
      bc:	33 2f       	mov	r19, r19
      be:	07 37       	cpi	r16, 0x77	; 119
      c0:	25 2f       	mov	r18, r21
      c2:	1f 2f       	mov	r17, r31
      c4:	64 2b       	or	r22, r20
      c6:	17 2f       	mov	r17, r23
      c8:	e5 31       	cpi	r30, 0x15	; 21
      ca:	64 2b       	or	r22, r20
      cc:	64 2b       	or	r22, r20
      ce:	52 32       	cpi	r21, 0x22	; 34
      d0:	11 2f       	mov	r17, r17
      d2:	18 35       	cpi	r17, 0x58	; 88
      d4:	09 2f       	mov	r16, r25
      d6:	9c 34       	cpi	r25, 0x4C	; 76
      d8:	a1 33       	cpi	r26, 0x31	; 49
      da:	03 2f       	mov	r16, r19

000000dc <__c.2350>:
      dc:	4d 43 55 53 52 20 3d 20 25 64 0a 00                 MCUSR = %d..

000000e8 <__c.2352>:
      e8:	0a 4f 56 37 36 37 30 20 43 61 6d 65 72 61 20 54     .OV7670 Camera T
      f8:	65 73 74 20 41 70 70 6c 69 63 61 74 69 6f 6e 2e     est Application.
     108:	0a 00                                               ..

0000010a <__c.2356>:
     10a:	4c 46 4e 20 44 69 73 61 62 6c 65 64 00              LFN Disabled.

00000117 <__c.2358>:
     117:	2c 20 43 6f 64 65 20 70 61 67 65 3a 20 25 75 0a     , Code page: %u.
	...

00000128 <__c.2360>:
     128:	52 54 43 20 69 73 20 6e 6f 74 20 73 75 70 70 6f     RTC is not suppo
     138:	72 74 65 64 2e 20 41 6c 6c 20 66 69 6c 65 73 20     rted. All files 
     148:	77 69 6c 6c 20 68 61 76 65 20 74 69 6d 65 73 74     will have timest
     158:	61 6d 70 20 6f 66 20 30 0a 00                       amp of 0..

00000162 <__c.2362>:
     162:	54 57 49 20 49 6e 69 74 69 61 6c 69 73 65 64 2e     TWI Initialised.
     172:	0a 00                                               ..

00000174 <__c.2364>:
     174:	46 49 46 4f 20 49 6e 69 74 69 61 6c 69 73 65 64     FIFO Initialised
     184:	20 25 64 0a 00                                       %d..

00000189 <__c.2366>:
     189:	4f 56 37 36 37 30 20 49 6e 69 74 69 61 6c 69 73     OV7670 Initialis
     199:	65 3a 20 25 64 0a 00                                e: %d..

000001a0 <__c.2371>:
     1a0:	72 63 3d 25 64 0a 00                                rc=%d..

000001a7 <__c.2373>:
     1a7:	53 65 63 74 6f 72 3a 25 6c 75 0a 00                 Sector:%lu..

000001b3 <__c.2379>:
     1b3:	72 63 3d 25 64 0a 00                                rc=%d..

000001ba <__c.2382>:
     1ba:	44 72 69 76 65 20 73 69 7a 65 3a 20 25 6c 75 20     Drive size: %lu 
     1ca:	73 65 63 74 6f 72 73 0a 00                          sectors..

000001d3 <__c.2384>:
     1d3:	45 72 61 73 65 20 62 6c 6f 63 6b 3a 20 25 6c 75     Erase block: %lu
     1e3:	20 73 65 63 74 6f 72 73 0a 00                        sectors..

000001ed <__c.2386>:
     1ed:	43 61 72 64 20 74 79 70 65 3a 20 25 75 0a 00        Card type: %u..

000001fc <__c.2388>:
     1fc:	43 53 44 3a 0a 00                                   CSD:..

00000202 <__c.2390>:
     202:	43 49 44 3a 0a 00                                   CID:..

00000208 <__c.2392>:
     208:	4f 43 52 3a 0a 00                                   OCR:..

0000020e <__c.2394>:
     20e:	53 44 20 53 74 61 74 75 73 3a 0a 00                 SD Status:..

0000021a <__c.2399>:
     21a:	4d 6f 64 65 6c 3a 20 25 73 0a 00                    Model: %s..

00000225 <__c.2401>:
     225:	53 2f 4e 3a 20 25 73 0a 00                          S/N: %s..

0000022e <__c.2413>:
     22e:	25 30 34 58 20 25 30 32 58 2d 00                    %04X %02X-.

00000239 <__c.2417>:
     239:	3f 3f 3f 0a 00                                      ???..

0000023e <__c.2421>:
     23e:	72 63 3d 25 75 0a 00                                rc=%u..

00000245 <__c.2424>:
     245:	72 63 3d 25 75 0a 00                                rc=%u..

0000024c <__c.2435>:
     24c:	46 41 54 20 74 79 70 65 20 3d 20 25 75 0a 42 79     FAT type = %u.By
     25c:	74 65 73 2f 43 6c 75 73 74 65 72 20 3d 20 25 6c     tes/Cluster = %l
     26c:	75 0a 4e 75 6d 62 65 72 20 6f 66 20 46 41 54 73     u.Number of FATs
     27c:	20 3d 20 25 75 0a 52 6f 6f 74 20 44 49 52 20 65      = %u.Root DIR e
     28c:	6e 74 72 69 65 73 20 3d 20 25 75 0a 53 65 63 74     ntries = %u.Sect
     29c:	6f 72 73 2f 46 41 54 20 3d 20 25 6c 75 0a 4e 75     ors/FAT = %lu.Nu
     2ac:	6d 62 65 72 20 6f 66 20 63 6c 75 73 74 65 72 73     mber of clusters
     2bc:	20 3d 20 25 6c 75 0a 46 41 54 20 73 74 61 72 74      = %lu.FAT start
     2cc:	20 28 6c 62 61 29 20 3d 20 25 6c 75 0a 44 49 52      (lba) = %lu.DIR
     2dc:	20 73 74 61 72 74 20 28 6c 62 61 2c 63 6c 75 73      start (lba,clus
     2ec:	74 6f 72 29 20 3d 20 25 6c 75 0a 44 61 74 61 20     tor) = %lu.Data 
     2fc:	73 74 61 72 74 20 28 6c 62 61 29 20 3d 20 25 6c     start (lba) = %l
     30c:	75 0a 0a 2e 2e 2e 00                                u......

00000313 <__c.2437>:
     313:	0d 25 75 20 66 69 6c 65 73 2c 20 25 6c 75 20 62     .%u files, %lu b
     323:	79 74 65 73 2e 0a 25 75 20 66 6f 6c 64 65 72 73     ytes..%u folders
     333:	2e 0a 25 6c 75 20 4b 42 20 74 6f 74 61 6c 20 64     ..%lu KB total d
     343:	69 73 6b 20 73 70 61 63 65 2e 0a 25 6c 75 20 4b     isk space..%lu K
     353:	42 20 61 76 61 69 6c 61 62 6c 65 2e 0a 00           B available...

00000361 <__c.2444>:
     361:	25 63 25 63 25 63 25 63 25 63 20 25 75 2f 25 30     %c%c%c%c%c %u/%0
     371:	32 75 2f 25 30 32 75 20 25 30 32 75 3a 25 30 32     2u/%02u %02u:%02
     381:	75 20 25 39 6c 75 20 20 25 73 00                    u %9lu  %s.

0000038c <__c.2447>:
     38c:	25 34 75 20 46 69 6c 65 28 73 29 2c 25 31 30 6c     %4u File(s),%10l
     39c:	75 20 62 79 74 65 73 20 74 6f 74 61 6c 0a 25 34     u bytes total.%4
     3ac:	75 20 44 69 72 28 73 29 00                          u Dir(s).

000003b5 <__c.2449>:
     3b5:	2c 20 25 31 30 6c 75 4b 20 62 79 74 65 73 20 66     , %10luK bytes f
     3c5:	72 65 65 0a 00                                      ree..

000003ca <__c.2457>:
     3ca:	66 70 74 72 20 3d 20 25 6c 75 28 30 78 25 6c 58     fptr = %lu(0x%lX
     3da:	29 0a 00                                            )..

000003dd <__c.2463>:
     3dd:	25 6c 75 20 62 79 74 65 73 20 72 65 61 64 20 77     %lu bytes read w
     3ed:	69 74 68 20 25 6c 75 20 62 79 74 65 73 2f 73 65     ith %lu bytes/se
     3fd:	63 2e 0a 00                                         c...

00000401 <__c.2473>:
     401:	25 6c 75 20 62 79 74 65 73 20 77 72 69 74 74 65     %lu bytes writte
     411:	6e 20 77 69 74 68 20 25 6c 75 20 62 79 74 65 73     n with %lu bytes
     421:	2f 73 65 63 2e 0a 00                                /sec...

00000428 <__c.2507>:
     428:	4f 70 65 6e 69 6e 67 20 22 25 73 22 00              Opening "%s".

00000435 <__c.2509>:
     435:	0a 43 72 65 61 74 69 6e 67 20 22 25 73 22 00        .Creating "%s".

00000444 <__c.2511>:
     444:	0a 43 6f 70 79 69 6e 67 2e 2e 2e 00                 .Copying....

00000450 <__c.2515>:
     450:	0a 25 6c 75 20 62 79 74 65 73 20 63 6f 70 69 65     .%lu bytes copie
     460:	64 20 77 69 74 68 20 25 6c 75 20 62 79 74 65 73     d with %lu bytes
     470:	2f 73 65 63 2e 0a 00                                /sec...

00000477 <__c.2527>:
     477:	5b 44 69 73 6b 20 63 6f 6e 74 6f 72 6c 73 5d 0a     [Disk contorls].
     487:	20 64 69 20 3c 70 64 23 3e 20 2d 20 49 6e 69 74      di <pd#> - Init
     497:	69 61 6c 69 7a 65 20 64 69 73 6b 0a 20 64 64 20     ialize disk. dd 
     4a7:	5b 3c 70 64 23 3e 20 3c 73 65 63 74 3e 5d 20 2d     [<pd#> <sect>] -
     4b7:	20 44 75 6d 70 20 61 20 73 65 63 72 74 6f 72 0a      Dump a secrtor.
     4c7:	20 64 73 20 3c 70 64 23 3e 20 2d 20 53 68 6f 77      ds <pd#> - Show
     4d7:	20 64 69 73 6b 20 73 74 61 74 75 73 0a 5b 42 75      disk status.[Bu
     4e7:	66 66 65 72 20 63 6f 6e 74 72 6f 6c 73 5d 0a 20     ffer controls]. 
     4f7:	62 64 20 3c 6f 66 73 3e 20 2d 20 44 75 6d 70 20     bd <ofs> - Dump 
     507:	77 6f 72 6b 69 6e 67 20 62 75 66 66 65 72 0a 20     working buffer. 
     517:	62 65 20 3c 6f 66 73 3e 20 5b 3c 64 61 74 61 3e     be <ofs> [<data>
     527:	5d 20 2e 2e 2e 20 2d 20 45 64 69 74 20 77 6f 72     ] ... - Edit wor
     537:	6b 69 6e 67 20 62 75 66 66 65 72 0a 20 62 72 20     king buffer. br 
     547:	3c 70 64 23 3e 20 3c 73 65 63 74 3e 20 5b 3c 6e     <pd#> <sect> [<n
     557:	75 6d 3e 5d 20 2d 20 52 65 61 64 20 64 69 73 6b     um>] - Read disk
     567:	20 69 6e 74 6f 20 77 6f 72 6b 69 6e 67 20 62 75      into working bu
     577:	66 66 65 72 0a 20 62 77 20 3c 70 64 23 3e 20 3c     ffer. bw <pd#> <
     587:	73 65 63 74 3e 20 5b 3c 6e 75 6d 3e 5d 20 2d 20     sect> [<num>] - 
     597:	57 72 69 74 65 20 77 6f 72 6b 69 6e 67 20 62 75     Write working bu
     5a7:	66 66 65 72 20 69 6e 74 6f 20 64 69 73 6b 0a 20     ffer into disk. 
     5b7:	62 66 20 3c 76 61 6c 3e 20 2d 20 46 69 6c 6c 20     bf <val> - Fill 
     5c7:	77 6f 72 6b 69 6e 67 20 62 75 66 66 65 72 0a 5b     working buffer.[
     5d7:	46 69 6c 65 20 73 79 73 74 65 6d 20 63 6f 6e 74     File system cont
     5e7:	72 6f 6c 73 5d 0a 20 66 69 20 3c 6c 64 23 3e 20     rols]. fi <ld#> 
     5f7:	2d 20 46 6f 72 63 65 20 69 6e 69 74 69 61 6c 69     - Force initiali
     607:	7a 65 64 20 74 68 65 20 76 6f 6c 75 6d 65 0a 20     zed the volume. 
     617:	66 73 20 5b 3c 70 61 74 68 3e 5d 20 2d 20 53 68     fs [<path>] - Sh
     627:	6f 77 20 76 6f 6c 75 6d 65 20 73 74 61 74 75 73     ow volume status
     637:	0a 20 66 6c 20 5b 3c 70 61 74 68 3e 5d 20 2d 20     . fl [<path>] - 
     647:	53 68 6f 77 20 61 20 64 69 72 65 63 74 6f 72 79     Show a directory
     657:	0a 20 66 6f 20 3c 6d 6f 64 65 3e 20 3c 66 69 6c     . fo <mode> <fil
     667:	65 3e 20 2d 20 4f 70 65 6e 20 61 20 66 69 6c 65     e> - Open a file
     677:	0a 20 66 63 20 2d 20 43 6c 6f 73 65 20 74 68 65     . fc - Close the
     687:	20 66 69 6c 65 0a 20 66 65 20 3c 6f 66 73 3e 20      file. fe <ofs> 
     697:	2d 20 4d 6f 76 65 20 66 70 20 69 6e 20 6e 6f 72     - Move fp in nor
     6a7:	6d 61 6c 20 73 65 65 6b 0a 20 66 64 20 3c 6c 65     mal seek. fd <le
     6b7:	6e 3e 20 2d 20 52 65 61 64 20 61 6e 64 20 64 75     n> - Read and du
     6c7:	6d 70 20 74 68 65 20 66 69 6c 65 0a 20 66 72 20     mp the file. fr 
     6d7:	3c 6c 65 6e 3e 20 2d 20 52 65 61 64 20 74 68 65     <len> - Read the
     6e7:	20 66 69 6c 65 0a 20 66 77 20 3c 6c 65 6e 3e 20      file. fw <len> 
     6f7:	3c 76 61 6c 3e 20 2d 20 57 72 69 74 65 20 74 6f     <val> - Write to
     707:	20 74 68 65 20 66 69 6c 65 0a 20 66 6e 20 3c 6f      the file. fn <o
     717:	72 67 20 6e 61 6d 65 3e 20 3c 6e 65 77 20 6e 61     rg name> <new na
     727:	6d 65 3e 20 2d 20 52 65 6e 61 6d 65 20 61 6e 20     me> - Rename an 
     737:	6f 62 6a 65 63 74 0a 20 66 75 20 3c 6f 62 6a 20     object. fu <obj 
     747:	6e 61 6d 65 3e 20 2d 20 55 6e 6c 69 6e 6b 20 61     name> - Unlink a
     757:	6e 20 6f 62 6a 65 63 74 0a 20 66 76 20 2d 20 54     n object. fv - T
     767:	72 75 6e 63 61 74 65 20 74 68 65 20 66 69 6c 65     runcate the file
     777:	20 61 74 20 63 75 72 72 65 6e 74 20 66 70 0a 20      at current fp. 
     787:	66 6b 20 3c 64 69 72 20 6e 61 6d 65 3e 20 2d 20     fk <dir name> - 
     797:	43 72 65 61 74 65 20 61 20 64 69 72 65 63 74 6f     Create a directo
     7a7:	72 79 0a 20 66 61 20 3c 61 74 72 72 3e 20 3c 6d     ry. fa <atrr> <m
     7b7:	61 73 6b 3e 20 3c 6f 62 6a 65 63 74 20 6e 61 6d     ask> <object nam
     7c7:	65 3e 20 2d 20 43 68 61 6e 67 65 20 6f 62 6a 65     e> - Change obje
     7d7:	63 74 20 61 74 74 72 69 62 75 74 65 0a 20 66 74     ct attribute. ft
     7e7:	20 3c 79 65 61 72 3e 20 3c 6d 6f 6e 74 68 3e 20      <year> <month> 
     7f7:	3c 64 61 79 3e 20 3c 68 6f 75 72 3e 20 3c 6d 69     <day> <hour> <mi
     807:	6e 3e 20 3c 73 65 63 3e 20 3c 6f 62 6a 65 63 74     n> <sec> <object
     817:	20 6e 61 6d 65 3e 20 2d 20 43 68 61 6e 67 65 20      name> - Change 
     827:	74 69 6d 65 73 74 61 6d 70 20 6f 66 20 61 6e 20     timestamp of an 
     837:	6f 62 6a 65 63 74 0a 20 66 78 20 3c 73 72 63 20     object. fx <src 
     847:	66 69 6c 65 3e 20 3c 64 73 74 20 66 69 6c 65 3e     file> <dst file>
     857:	20 2d 20 43 6f 70 79 20 61 20 66 69 6c 65 0a 20      - Copy a file. 
     867:	66 67 20 3c 70 61 74 68 3e 20 2d 20 43 68 61 6e     fg <path> - Chan
     877:	67 65 20 63 75 72 72 65 6e 74 20 64 69 72 65 63     ge current direc
     887:	74 6f 72 79 0a 20 66 6a 20 3c 6c 64 23 3e 20 2d     tory. fj <ld#> -
     897:	20 43 68 61 6e 67 65 20 63 75 72 72 65 6e 74 20      Change current 
     8a7:	64 72 69 76 65 0a 20 66 71 20 2d 20 53 68 6f 77     drive. fq - Show
     8b7:	20 63 75 72 72 65 6e 74 20 64 69 72 65 63 74 6f      current directo
     8c7:	72 79 0a 20 66 6d 20 3c 6c 64 23 3e 20 3c 72 75     ry. fm <ld#> <ru
     8d7:	6c 65 3e 20 3c 63 6c 75 73 74 65 72 20 73 69 7a     le> <cluster siz
     8e7:	65 3e 20 2d 20 43 72 65 61 74 65 20 66 69 6c 65     e> - Create file
     8f7:	20 73 79 73 74 65 6d 0a 5b 4d 69 73 63 20 63 6f      system.[Misc co
     907:	6d 6d 61 6e 64 73 5d 0a 20 70 20 2d 20 53 74 6f     mmands]. p - Sto
     917:	72 65 20 61 20 42 69 74 6d 61 70 20 50 68 6f 74     re a Bitmap Phot
     927:	6f 20 74 6f 20 6f 70 65 6e 20 46 69 6c 65 0a 0a     o to open File..
	...

00000938 <__c.2289>:
     938:	25 30 38 6c 58 20 00                                %08lX .

0000093f <__c.2291>:
     93f:	20 25 30 32 58 00                                    %02X.

00000945 <__c.2327>:
     945:	72 63 3d 25 75 20 46 52 5f 25 53 0a 00              rc=%u FR_%S..

00000952 <__c.2314>:
     952:	46 69 6c 65 20 57 72 69 74 65 20 46 61 69 6c 20     File Write Fail 
     962:	3a 20 25 64 00                                      : %d.

00000967 <__c.2319>:
     967:	53 75 63 63 65 73 73 21 0a 00                       Success!..

00000971 <__c.2321>:
     971:	43 6c 6f 73 69 6e 67 20 46 69 6c 65 3a 20 25 64     Closing File: %d
     981:	0a 00 00                                            ...

00000984 <__ctors_end>:
     984:	11 24       	eor	r1, r1
     986:	1f be       	out	0x3f, r1	; 63
     988:	cf ef       	ldi	r28, 0xFF	; 255
     98a:	d0 e1       	ldi	r29, 0x10	; 16
     98c:	de bf       	out	0x3e, r29	; 62
     98e:	cd bf       	out	0x3d, r28	; 61

00000990 <__do_copy_data>:
     990:	12 e0       	ldi	r17, 0x02	; 2
     992:	a0 e0       	ldi	r26, 0x00	; 0
     994:	b1 e0       	ldi	r27, 0x01	; 1
     996:	ee ef       	ldi	r30, 0xFE	; 254
     998:	f7 e7       	ldi	r31, 0x77	; 119
     99a:	02 c0       	rjmp	.+4      	; 0x9a0 <__do_copy_data+0x10>
     99c:	05 90       	lpm	r0, Z+
     99e:	0d 92       	st	X+, r0
     9a0:	ac 37       	cpi	r26, 0x7C	; 124
     9a2:	b1 07       	cpc	r27, r17
     9a4:	d9 f7       	brne	.-10     	; 0x99c <__do_copy_data+0xc>

000009a6 <__do_clear_bss>:
     9a6:	1d e0       	ldi	r17, 0x0D	; 13
     9a8:	ac e7       	ldi	r26, 0x7C	; 124
     9aa:	b2 e0       	ldi	r27, 0x02	; 2
     9ac:	01 c0       	rjmp	.+2      	; 0x9b0 <.do_clear_bss_start>

000009ae <.do_clear_bss_loop>:
     9ae:	1d 92       	st	X+, r1

000009b0 <.do_clear_bss_start>:
     9b0:	a8 38       	cpi	r26, 0x88	; 136
     9b2:	b1 07       	cpc	r27, r17
     9b4:	e1 f7       	brne	.-8      	; 0x9ae <.do_clear_bss_loop>
     9b6:	0e 94 b0 2a 	call	0x5560	; 0x5560 <main>
     9ba:	0c 94 fd 3b 	jmp	0x77fa	; 0x77fa <_exit>

000009be <__bad_interrupt>:
     9be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009c2 <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader( void )
{
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	cf 93       	push	r28
     9c8:	df 93       	push	r29
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <WriteBMPHeader+0xa>
     9cc:	00 d0       	rcall	.+0      	; 0x9ce <WriteBMPHeader+0xc>
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
	uint32_t p;
	FRESULT f; 
	
	f_lseek(&File[0], 0);
     9d2:	05 ed       	ldi	r16, 0xD5	; 213
     9d4:	14 e0       	ldi	r17, 0x04	; 4
     9d6:	c8 01       	movw	r24, r16
     9d8:	40 e0       	ldi	r20, 0x00	; 0
     9da:	50 e0       	ldi	r21, 0x00	; 0
     9dc:	ba 01       	movw	r22, r20
     9de:	0e 94 9e 20 	call	0x413c	; 0x413c <f_lseek>
	f = f_write(&File[0], BMPHeader, BMPHEADERSIZE, &p);
     9e2:	c8 01       	movw	r24, r16
     9e4:	60 e0       	ldi	r22, 0x00	; 0
     9e6:	71 e0       	ldi	r23, 0x01	; 1
     9e8:	2e e0       	ldi	r18, 0x0E	; 14
     9ea:	30 e0       	ldi	r19, 0x00	; 0
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	8e 01       	movw	r16, r28
     9f2:	0f 5f       	subi	r16, 0xFF	; 255
     9f4:	1f 4f       	sbci	r17, 0xFF	; 255
     9f6:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
	
	return f;
}
     9fa:	0f 90       	pop	r0
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	0f 90       	pop	r0
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	1f 91       	pop	r17
     a08:	0f 91       	pop	r16
     a0a:	08 95       	ret

00000a0c <WriteDIBHeader>:

FRESULT WriteDIBHeader( void )
{
     a0c:	0f 93       	push	r16
     a0e:	1f 93       	push	r17
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
     a14:	00 d0       	rcall	.+0      	; 0xa16 <WriteDIBHeader+0xa>
     a16:	00 d0       	rcall	.+0      	; 0xa18 <WriteDIBHeader+0xc>
     a18:	cd b7       	in	r28, 0x3d	; 61
     a1a:	de b7       	in	r29, 0x3e	; 62
	uint32_t p;
	FRESULT f;
	
	f_lseek(&File[0], BMPHEADERSIZE);//place just after the bitmap header
     a1c:	05 ed       	ldi	r16, 0xD5	; 213
     a1e:	14 e0       	ldi	r17, 0x04	; 4
     a20:	c8 01       	movw	r24, r16
     a22:	4e e0       	ldi	r20, 0x0E	; 14
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	60 e0       	ldi	r22, 0x00	; 0
     a28:	70 e0       	ldi	r23, 0x00	; 0
     a2a:	0e 94 9e 20 	call	0x413c	; 0x413c <f_lseek>
	f = f_write(&File[0], DIBHead, DIBHEADERSIZE, &p);
     a2e:	c8 01       	movw	r24, r16
     a30:	6e e0       	ldi	r22, 0x0E	; 14
     a32:	71 e0       	ldi	r23, 0x01	; 1
     a34:	2c e7       	ldi	r18, 0x7C	; 124
     a36:	30 e0       	ldi	r19, 0x00	; 0
     a38:	40 e0       	ldi	r20, 0x00	; 0
     a3a:	50 e0       	ldi	r21, 0x00	; 0
     a3c:	8e 01       	movw	r16, r28
     a3e:	0f 5f       	subi	r16, 0xFF	; 255
     a40:	1f 4f       	sbci	r17, 0xFF	; 255
     a42:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
	return f;
}
     a46:	0f 90       	pop	r0
     a48:	0f 90       	pop	r0
     a4a:	0f 90       	pop	r0
     a4c:	0f 90       	pop	r0
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	1f 91       	pop	r17
     a54:	0f 91       	pop	r16
     a56:	08 95       	ret

00000a58 <IO_Init>:
#include "Config.h"

void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     a58:	ee e6       	ldi	r30, 0x6E	; 110
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	80 81       	ld	r24, Z
     a5e:	82 60       	ori	r24, 0x02	; 2
     a60:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     a62:	84 b5       	in	r24, 0x24	; 36
     a64:	82 60       	ori	r24, 0x02	; 2
     a66:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     a68:	85 e7       	ldi	r24, 0x75	; 117
     a6a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     a6c:	85 b5       	in	r24, 0x25	; 37
     a6e:	85 60       	ori	r24, 0x05	; 5
     a70:	85 bd       	out	0x25, r24	; 37
	sei();
     a72:	78 94       	sei
     a74:	08 95       	ret

00000a76 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     a76:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     a78:	8f ee       	ldi	r24, 0xEF	; 239
     a7a:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     a7c:	8f e4       	ldi	r24, 0x4F	; 79
     a7e:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     a80:	08 95       	ret

00000a82 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     a82:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     a84:	0d b4       	in	r0, 0x2d	; 45
     a86:	07 fe       	sbrs	r0, 7
     a88:	fd cf       	rjmp	.-6      	; 0xa84 <xchg_spi+0x2>
	return SPDR;
     a8a:	8e b5       	in	r24, 0x2e	; 46
}
     a8c:	08 95       	ret

00000a8e <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     a8e:	82 e3       	ldi	r24, 0x32	; 50
     a90:	80 93 7c 02 	sts	0x027C, r24
	do
		d = xchg_spi(0xFF);
     a94:	8f ef       	ldi	r24, 0xFF	; 255
     a96:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	while (d != 0xFF && Timer2);
     a9a:	8f 3f       	cpi	r24, 0xFF	; 255
     a9c:	21 f0       	breq	.+8      	; 0xaa6 <wait_ready+0x18>
     a9e:	90 91 7c 02 	lds	r25, 0x027C
     aa2:	99 23       	and	r25, r25
     aa4:	b9 f7       	brne	.-18     	; 0xa94 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     aa6:	21 e0       	ldi	r18, 0x01	; 1
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	8f 3f       	cpi	r24, 0xFF	; 255
     aac:	11 f0       	breq	.+4      	; 0xab2 <wait_ready+0x24>
     aae:	20 e0       	ldi	r18, 0x00	; 0
     ab0:	30 e0       	ldi	r19, 0x00	; 0
}
     ab2:	82 2f       	mov	r24, r18
     ab4:	93 2f       	mov	r25, r19
     ab6:	08 95       	ret

00000ab8 <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     ab8:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     aba:	8f ef       	ldi	r24, 0xFF	; 255
     abc:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
}
     ac0:	08 95       	ret

00000ac2 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     ac2:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     ac4:	8f ef       	ldi	r24, 0xFF	; 255
     ac6:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     aca:	0e 94 47 05 	call	0xa8e	; 0xa8e <wait_ready>
     ace:	00 97       	sbiw	r24, 0x00	; 0
     ad0:	29 f4       	brne	.+10     	; 0xadc <select+0x1a>
	deselect();
     ad2:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
	return 0;	/* Timeout */
     ad6:	80 e0       	ldi	r24, 0x00	; 0
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     ae0:	08 95       	ret

00000ae2 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     ae2:	cf 92       	push	r12
     ae4:	df 92       	push	r13
     ae6:	ef 92       	push	r14
     ae8:	ff 92       	push	r15
     aea:	cf 93       	push	r28
     aec:	df 93       	push	r29
     aee:	ec 01       	movw	r28, r24
     af0:	6a 01       	movw	r12, r20
     af2:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     af4:	84 e1       	ldi	r24, 0x14	; 20
     af6:	80 93 7d 02 	sts	0x027D, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     afa:	8f ef       	ldi	r24, 0xFF	; 255
     afc:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     b00:	8f 3f       	cpi	r24, 0xFF	; 255
     b02:	39 f4       	brne	.+14     	; 0xb12 <rcvr_datablock+0x30>
     b04:	80 91 7d 02 	lds	r24, 0x027D
     b08:	88 23       	and	r24, r24
     b0a:	b9 f7       	brne	.-18     	; 0xafa <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	28 c0       	rjmp	.+80     	; 0xb62 <rcvr_datablock+0x80>
     b12:	8e 3f       	cpi	r24, 0xFE	; 254
     b14:	21 f5       	brne	.+72     	; 0xb5e <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     b16:	8f ef       	ldi	r24, 0xFF	; 255
     b18:	8e bd       	out	0x2e, r24	; 46
     b1a:	0d b4       	in	r0, 0x2d	; 45
     b1c:	07 fe       	sbrs	r0, 7
     b1e:	fd cf       	rjmp	.-6      	; 0xb1a <rcvr_datablock+0x38>
     b20:	9e b5       	in	r25, 0x2e	; 46
     b22:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     b24:	8e bd       	out	0x2e, r24	; 46
     b26:	0d b4       	in	r0, 0x2d	; 45
     b28:	07 fe       	sbrs	r0, 7
     b2a:	fd cf       	rjmp	.-6      	; 0xb26 <rcvr_datablock+0x44>
     b2c:	9e b5       	in	r25, 0x2e	; 46
     b2e:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     b30:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     b32:	2e ef       	ldi	r18, 0xFE	; 254
     b34:	3f ef       	ldi	r19, 0xFF	; 255
     b36:	4f ef       	ldi	r20, 0xFF	; 255
     b38:	5f ef       	ldi	r21, 0xFF	; 255
     b3a:	c2 0e       	add	r12, r18
     b3c:	d3 1e       	adc	r13, r19
     b3e:	e4 1e       	adc	r14, r20
     b40:	f5 1e       	adc	r15, r21
     b42:	c1 14       	cp	r12, r1
     b44:	d1 04       	cpc	r13, r1
     b46:	e1 04       	cpc	r14, r1
     b48:	f1 04       	cpc	r15, r1
     b4a:	31 f7       	brne	.-52     	; 0xb18 <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	xchg_spi(0xFF);
     b52:	8f ef       	ldi	r24, 0xFF	; 255
     b54:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>

	return 1;						/* Return with success */
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	02 c0       	rjmp	.+4      	; 0xb62 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     b62:	df 91       	pop	r29
     b64:	cf 91       	pop	r28
     b66:	ff 90       	pop	r15
     b68:	ef 90       	pop	r14
     b6a:	df 90       	pop	r13
     b6c:	cf 90       	pop	r12
     b6e:	08 95       	ret

00000b70 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     b70:	1f 93       	push	r17
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	ec 01       	movw	r28, r24
     b78:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     b7a:	0e 94 47 05 	call	0xa8e	; 0xa8e <wait_ready>
     b7e:	00 97       	sbiw	r24, 0x00	; 0
     b80:	41 f1       	breq	.+80     	; 0xbd2 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     b82:	81 2f       	mov	r24, r17
     b84:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     b88:	1d 3f       	cpi	r17, 0xFD	; 253
     b8a:	31 f1       	breq	.+76     	; 0xbd8 <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     b8c:	ce 01       	movw	r24, r28
     b8e:	80 50       	subi	r24, 0x00	; 0
     b90:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     b92:	28 81       	ld	r18, Y
     b94:	2e bd       	out	0x2e, r18	; 46
     b96:	0d b4       	in	r0, 0x2d	; 45
     b98:	07 fe       	sbrs	r0, 7
     b9a:	fd cf       	rjmp	.-6      	; 0xb96 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     b9c:	29 81       	ldd	r18, Y+1	; 0x01
     b9e:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     ba0:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     ba2:	0d b4       	in	r0, 0x2d	; 45
     ba4:	07 fe       	sbrs	r0, 7
     ba6:	fd cf       	rjmp	.-6      	; 0xba2 <xmit_datablock+0x32>
	} while (cnt -= 2);
     ba8:	8c 17       	cp	r24, r28
     baa:	9d 07       	cpc	r25, r29
     bac:	91 f7       	brne	.-28     	; 0xb92 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     bae:	8f ef       	ldi	r24, 0xFF	; 255
     bb0:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
		xchg_spi(0xFF);
     bb4:	8f ef       	ldi	r24, 0xFF	; 255
     bb6:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     bba:	8f ef       	ldi	r24, 0xFF	; 255
     bbc:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     bc0:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     bc2:	21 e0       	ldi	r18, 0x01	; 1
     bc4:	30 e0       	ldi	r19, 0x00	; 0
     bc6:	85 30       	cpi	r24, 0x05	; 5
     bc8:	11 f0       	breq	.+4      	; 0xbce <xmit_datablock+0x5e>
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     bce:	c9 01       	movw	r24, r18
     bd0:	05 c0       	rjmp	.+10     	; 0xbdc <xmit_datablock+0x6c>
     bd2:	80 e0       	ldi	r24, 0x00	; 0
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	02 c0       	rjmp	.+4      	; 0xbdc <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     bd8:	81 e0       	ldi	r24, 0x01	; 1
     bda:	90 e0       	ldi	r25, 0x00	; 0
}
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	1f 91       	pop	r17
     be2:	08 95       	ret

00000be4 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     be4:	ff 92       	push	r15
     be6:	0f 93       	push	r16
     be8:	1f 93       	push	r17
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	c8 2f       	mov	r28, r24
     bf0:	d4 2f       	mov	r29, r20
     bf2:	15 2f       	mov	r17, r21
     bf4:	06 2f       	mov	r16, r22
     bf6:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     bf8:	88 23       	and	r24, r24
     bfa:	4c f4       	brge	.+18     	; 0xc0e <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     bfc:	87 e3       	ldi	r24, 0x37	; 55
     bfe:	40 e0       	ldi	r20, 0x00	; 0
     c00:	50 e0       	ldi	r21, 0x00	; 0
     c02:	ba 01       	movw	r22, r20
     c04:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
		if (res > 1) return res;
     c08:	82 30       	cpi	r24, 0x02	; 2
     c0a:	68 f5       	brcc	.+90     	; 0xc66 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     c0c:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     c0e:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
	if (!select()) return 0xFF;
     c12:	0e 94 61 05 	call	0xac2	; 0xac2 <select>
     c16:	00 97       	sbiw	r24, 0x00	; 0
     c18:	29 f1       	breq	.+74     	; 0xc64 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     c1a:	8c 2f       	mov	r24, r28
     c1c:	80 64       	ori	r24, 0x40	; 64
     c1e:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     c22:	8f 2d       	mov	r24, r15
     c24:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     c28:	80 2f       	mov	r24, r16
     c2a:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     c2e:	81 2f       	mov	r24, r17
     c30:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     c34:	8d 2f       	mov	r24, r29
     c36:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     c3a:	cc 23       	and	r28, r28
     c3c:	f1 f0       	breq	.+60     	; 0xc7a <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     c3e:	c8 30       	cpi	r28, 0x08	; 8
     c40:	c1 f0       	breq	.+48     	; 0xc72 <send_cmd+0x8e>
	xchg_spi(n);
     c42:	81 e0       	ldi	r24, 0x01	; 1
     c44:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     c48:	cc 30       	cpi	r28, 0x0C	; 12
     c4a:	19 f4       	brne	.+6      	; 0xc52 <send_cmd+0x6e>
     c4c:	8f ef       	ldi	r24, 0xFF	; 255
     c4e:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     c52:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     c54:	8f ef       	ldi	r24, 0xFF	; 255
     c56:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
	while ((res & 0x80) && --n);
     c5a:	88 23       	and	r24, r24
     c5c:	24 f4       	brge	.+8      	; 0xc66 <send_cmd+0x82>
     c5e:	c1 50       	subi	r28, 0x01	; 1
     c60:	c9 f7       	brne	.-14     	; 0xc54 <send_cmd+0x70>
     c62:	01 c0       	rjmp	.+2      	; 0xc66 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     c64:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	ff 90       	pop	r15
     c70:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     c72:	87 e8       	ldi	r24, 0x87	; 135
     c74:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
     c78:	ec cf       	rjmp	.-40     	; 0xc52 <send_cmd+0x6e>
     c7a:	85 e9       	ldi	r24, 0x95	; 149
     c7c:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
     c80:	e8 cf       	rjmp	.-48     	; 0xc52 <send_cmd+0x6e>

00000c82 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     c82:	cf 92       	push	r12
     c84:	df 92       	push	r13
     c86:	ef 92       	push	r14
     c88:	ff 92       	push	r15
     c8a:	0f 93       	push	r16
     c8c:	1f 93       	push	r17
     c8e:	cf 93       	push	r28
     c90:	df 93       	push	r29
     c92:	00 d0       	rcall	.+0      	; 0xc94 <disk_initialize+0x12>
     c94:	00 d0       	rcall	.+0      	; 0xc96 <disk_initialize+0x14>
     c96:	cd b7       	in	r28, 0x3d	; 61
     c98:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     c9a:	88 23       	and	r24, r24
     c9c:	09 f0       	breq	.+2      	; 0xca0 <disk_initialize+0x1e>
     c9e:	a8 c0       	rjmp	.+336    	; 0xdf0 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     ca0:	0e 94 3b 05 	call	0xa76	; 0xa76 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     ca4:	80 91 8a 01 	lds	r24, 0x018A
     ca8:	81 ff       	sbrs	r24, 1
     caa:	03 c0       	rjmp	.+6      	; 0xcb2 <disk_initialize+0x30>
     cac:	80 91 8a 01 	lds	r24, 0x018A
     cb0:	a0 c0       	rjmp	.+320    	; 0xdf2 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     cb2:	80 e1       	ldi	r24, 0x10	; 16
     cb4:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     cb6:	80 eb       	ldi	r24, 0xB0	; 176
     cb8:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     cba:	81 e5       	ldi	r24, 0x51	; 81
     cbc:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     cbe:	82 e5       	ldi	r24, 0x52	; 82
     cc0:	8c bd       	out	0x2c, r24	; 44
     cc2:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     cc4:	8f ef       	ldi	r24, 0xFF	; 255
     cc6:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
     cca:	01 50       	subi	r16, 0x01	; 1
     ccc:	d9 f7       	brne	.-10     	; 0xcc4 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	40 e0       	ldi	r20, 0x00	; 0
     cd2:	50 e0       	ldi	r21, 0x00	; 0
     cd4:	ba 01       	movw	r22, r20
     cd6:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     cda:	81 30       	cpi	r24, 0x01	; 1
     cdc:	09 f0       	breq	.+2      	; 0xce0 <disk_initialize+0x5e>
     cde:	9c c0       	rjmp	.+312    	; 0xe18 <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     ce0:	84 e6       	ldi	r24, 0x64	; 100
     ce2:	80 93 7d 02 	sts	0x027D, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     ce6:	88 e0       	ldi	r24, 0x08	; 8
     ce8:	4a ea       	ldi	r20, 0xAA	; 170
     cea:	51 e0       	ldi	r21, 0x01	; 1
     cec:	60 e0       	ldi	r22, 0x00	; 0
     cee:	70 e0       	ldi	r23, 0x00	; 0
     cf0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     cf4:	81 30       	cpi	r24, 0x01	; 1
     cf6:	09 f0       	breq	.+2      	; 0xcfa <disk_initialize+0x78>
     cf8:	42 c0       	rjmp	.+132    	; 0xd7e <disk_initialize+0xfc>
     cfa:	6e 01       	movw	r12, r28
     cfc:	08 94       	sec
     cfe:	c1 1c       	adc	r12, r1
     d00:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     d02:	8e 01       	movw	r16, r28
     d04:	0b 5f       	subi	r16, 0xFB	; 251
     d06:	1f 4f       	sbci	r17, 0xFF	; 255
     d08:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     d0a:	8f ef       	ldi	r24, 0xFF	; 255
     d0c:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
     d10:	f7 01       	movw	r30, r14
     d12:	81 93       	st	Z+, r24
     d14:	7f 01       	movw	r14, r30
     d16:	e0 17       	cp	r30, r16
     d18:	f1 07       	cpc	r31, r17
     d1a:	b9 f7       	brne	.-18     	; 0xd0a <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     d1c:	8b 81       	ldd	r24, Y+3	; 0x03
     d1e:	81 30       	cpi	r24, 0x01	; 1
     d20:	09 f0       	breq	.+2      	; 0xd24 <disk_initialize+0xa2>
     d22:	7a c0       	rjmp	.+244    	; 0xe18 <disk_initialize+0x196>
     d24:	8c 81       	ldd	r24, Y+4	; 0x04
     d26:	8a 3a       	cpi	r24, 0xAA	; 170
     d28:	09 f0       	breq	.+2      	; 0xd2c <disk_initialize+0xaa>
     d2a:	76 c0       	rjmp	.+236    	; 0xe18 <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     d2c:	80 91 7d 02 	lds	r24, 0x027D
     d30:	88 23       	and	r24, r24
     d32:	49 f0       	breq	.+18     	; 0xd46 <disk_initialize+0xc4>
     d34:	89 ea       	ldi	r24, 0xA9	; 169
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	50 e0       	ldi	r21, 0x00	; 0
     d3a:	60 e0       	ldi	r22, 0x00	; 0
     d3c:	70 e4       	ldi	r23, 0x40	; 64
     d3e:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     d42:	88 23       	and	r24, r24
     d44:	99 f7       	brne	.-26     	; 0xd2c <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     d46:	80 91 7d 02 	lds	r24, 0x027D
     d4a:	88 23       	and	r24, r24
     d4c:	09 f4       	brne	.+2      	; 0xd50 <disk_initialize+0xce>
     d4e:	64 c0       	rjmp	.+200    	; 0xe18 <disk_initialize+0x196>
     d50:	8a e3       	ldi	r24, 0x3A	; 58
     d52:	40 e0       	ldi	r20, 0x00	; 0
     d54:	50 e0       	ldi	r21, 0x00	; 0
     d56:	ba 01       	movw	r22, r20
     d58:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     d5c:	88 23       	and	r24, r24
     d5e:	09 f0       	breq	.+2      	; 0xd62 <disk_initialize+0xe0>
     d60:	5b c0       	rjmp	.+182    	; 0xe18 <disk_initialize+0x196>
     d62:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     d64:	8f ef       	ldi	r24, 0xFF	; 255
     d66:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
     d6a:	f6 01       	movw	r30, r12
     d6c:	81 93       	st	Z+, r24
     d6e:	6f 01       	movw	r12, r30
     d70:	01 50       	subi	r16, 0x01	; 1
     d72:	c1 f7       	brne	.-16     	; 0xd64 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     d74:	89 81       	ldd	r24, Y+1	; 0x01
     d76:	86 fd       	sbrc	r24, 6
     d78:	49 c0       	rjmp	.+146    	; 0xe0c <disk_initialize+0x18a>
     d7a:	84 e0       	ldi	r24, 0x04	; 4
     d7c:	48 c0       	rjmp	.+144    	; 0xe0e <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     d7e:	89 ea       	ldi	r24, 0xA9	; 169
     d80:	40 e0       	ldi	r20, 0x00	; 0
     d82:	50 e0       	ldi	r21, 0x00	; 0
     d84:	ba 01       	movw	r22, r20
     d86:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     d8a:	82 30       	cpi	r24, 0x02	; 2
     d8c:	18 f4       	brcc	.+6      	; 0xd94 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     d8e:	12 e0       	ldi	r17, 0x02	; 2
     d90:	09 ea       	ldi	r16, 0xA9	; 169
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     d94:	11 e0       	ldi	r17, 0x01	; 1
     d96:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     d98:	80 91 7d 02 	lds	r24, 0x027D
     d9c:	88 23       	and	r24, r24
     d9e:	41 f0       	breq	.+16     	; 0xdb0 <disk_initialize+0x12e>
     da0:	80 2f       	mov	r24, r16
     da2:	40 e0       	ldi	r20, 0x00	; 0
     da4:	50 e0       	ldi	r21, 0x00	; 0
     da6:	ba 01       	movw	r22, r20
     da8:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     dac:	88 23       	and	r24, r24
     dae:	a1 f7       	brne	.-24     	; 0xd98 <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     db0:	80 91 7d 02 	lds	r24, 0x027D
     db4:	88 23       	and	r24, r24
     db6:	81 f1       	breq	.+96     	; 0xe18 <disk_initialize+0x196>
     db8:	80 e1       	ldi	r24, 0x10	; 16
     dba:	40 e0       	ldi	r20, 0x00	; 0
     dbc:	52 e0       	ldi	r21, 0x02	; 2
     dbe:	60 e0       	ldi	r22, 0x00	; 0
     dc0:	70 e0       	ldi	r23, 0x00	; 0
     dc2:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     dc6:	88 23       	and	r24, r24
     dc8:	39 f5       	brne	.+78     	; 0xe18 <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     dca:	10 93 7e 02 	sts	0x027E, r17
	deselect();
     dce:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>

	if (ty) {			/* Initialization succeded */
     dd2:	11 23       	and	r17, r17
     dd4:	41 f0       	breq	.+16     	; 0xde6 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     dd6:	80 91 8a 01 	lds	r24, 0x018A
     dda:	8e 7f       	andi	r24, 0xFE	; 254
     ddc:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     de0:	80 e5       	ldi	r24, 0x50	; 80
     de2:	8c bd       	out	0x2c, r24	; 44
     de4:	02 c0       	rjmp	.+4      	; 0xdea <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     de6:	0e 94 3b 05 	call	0xa76	; 0xa76 <power_off>
	}

	return Stat;
     dea:	80 91 8a 01 	lds	r24, 0x018A
     dee:	01 c0       	rjmp	.+2      	; 0xdf2 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     df0:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     df2:	0f 90       	pop	r0
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	0f 90       	pop	r0
     dfa:	df 91       	pop	r29
     dfc:	cf 91       	pop	r28
     dfe:	1f 91       	pop	r17
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	df 90       	pop	r13
     e08:	cf 90       	pop	r12
     e0a:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     e0c:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     e0e:	80 93 7e 02 	sts	0x027E, r24
	deselect();
     e12:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
     e16:	df cf       	rjmp	.-66     	; 0xdd6 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     e18:	10 92 7e 02 	sts	0x027E, r1
	deselect();
     e1c:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
     e20:	e2 cf       	rjmp	.-60     	; 0xde6 <disk_initialize+0x164>

00000e22 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     e22:	88 23       	and	r24, r24
     e24:	19 f4       	brne	.+6      	; 0xe2c <disk_status+0xa>
	return Stat;
     e26:	80 91 8a 01 	lds	r24, 0x018A
     e2a:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     e2c:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     e2e:	08 95       	ret

00000e30 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     e30:	0f 93       	push	r16
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     e38:	88 23       	and	r24, r24
     e3a:	09 f0       	breq	.+2      	; 0xe3e <disk_read+0xe>
     e3c:	4a c0       	rjmp	.+148    	; 0xed2 <disk_read+0xa2>
     e3e:	00 23       	and	r16, r16
     e40:	09 f4       	brne	.+2      	; 0xe44 <disk_read+0x14>
     e42:	49 c0       	rjmp	.+146    	; 0xed6 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     e44:	80 91 8a 01 	lds	r24, 0x018A
     e48:	80 fd       	sbrc	r24, 0
     e4a:	47 c0       	rjmp	.+142    	; 0xeda <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     e4c:	80 91 7e 02 	lds	r24, 0x027E
     e50:	83 fd       	sbrc	r24, 3
     e52:	09 c0       	rjmp	.+18     	; 0xe66 <disk_read+0x36>
     e54:	01 2e       	mov	r0, r17
     e56:	19 e0       	ldi	r17, 0x09	; 9
     e58:	22 0f       	add	r18, r18
     e5a:	33 1f       	adc	r19, r19
     e5c:	44 1f       	adc	r20, r20
     e5e:	55 1f       	adc	r21, r21
     e60:	1a 95       	dec	r17
     e62:	d1 f7       	brne	.-12     	; 0xe58 <disk_read+0x28>
     e64:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     e66:	01 30       	cpi	r16, 0x01	; 1
     e68:	89 f4       	brne	.+34     	; 0xe8c <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     e6a:	81 e1       	ldi	r24, 0x11	; 17
     e6c:	ba 01       	movw	r22, r20
     e6e:	a9 01       	movw	r20, r18
     e70:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     e74:	88 23       	and	r24, r24
     e76:	31 f5       	brne	.+76     	; 0xec4 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     e78:	ce 01       	movw	r24, r28
     e7a:	40 e0       	ldi	r20, 0x00	; 0
     e7c:	52 e0       	ldi	r21, 0x02	; 2
     e7e:	60 e0       	ldi	r22, 0x00	; 0
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
     e86:	00 97       	sbiw	r24, 0x00	; 0
     e88:	e1 f4       	brne	.+56     	; 0xec2 <disk_read+0x92>
     e8a:	1c c0       	rjmp	.+56     	; 0xec4 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     e8c:	82 e1       	ldi	r24, 0x12	; 18
     e8e:	ba 01       	movw	r22, r20
     e90:	a9 01       	movw	r20, r18
     e92:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     e96:	88 23       	and	r24, r24
     e98:	a9 f4       	brne	.+42     	; 0xec4 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     e9a:	ce 01       	movw	r24, r28
     e9c:	40 e0       	ldi	r20, 0x00	; 0
     e9e:	52 e0       	ldi	r21, 0x02	; 2
     ea0:	60 e0       	ldi	r22, 0x00	; 0
     ea2:	70 e0       	ldi	r23, 0x00	; 0
     ea4:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
     ea8:	00 97       	sbiw	r24, 0x00	; 0
     eaa:	21 f0       	breq	.+8      	; 0xeb4 <disk_read+0x84>
				buff += 512;
     eac:	c0 50       	subi	r28, 0x00	; 0
     eae:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     eb0:	01 50       	subi	r16, 0x01	; 1
     eb2:	99 f7       	brne	.-26     	; 0xe9a <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     eb4:	8c e0       	ldi	r24, 0x0C	; 12
     eb6:	40 e0       	ldi	r20, 0x00	; 0
     eb8:	50 e0       	ldi	r21, 0x00	; 0
     eba:	ba 01       	movw	r22, r20
     ebc:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     ec0:	01 c0       	rjmp	.+2      	; 0xec4 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     ec2:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     ec4:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>

	return count ? RES_ERROR : RES_OK;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	00 23       	and	r16, r16
     ecc:	39 f4       	brne	.+14     	; 0xedc <disk_read+0xac>
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	05 c0       	rjmp	.+10     	; 0xedc <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     ed2:	84 e0       	ldi	r24, 0x04	; 4
     ed4:	03 c0       	rjmp	.+6      	; 0xedc <disk_read+0xac>
     ed6:	84 e0       	ldi	r24, 0x04	; 4
     ed8:	01 c0       	rjmp	.+2      	; 0xedc <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     eda:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     edc:	df 91       	pop	r29
     ede:	cf 91       	pop	r28
     ee0:	0f 91       	pop	r16
     ee2:	08 95       	ret

00000ee4 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     ee4:	cf 92       	push	r12
     ee6:	df 92       	push	r13
     ee8:	ef 92       	push	r14
     eea:	ff 92       	push	r15
     eec:	0f 93       	push	r16
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	eb 01       	movw	r28, r22
     ef4:	69 01       	movw	r12, r18
     ef6:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     ef8:	88 23       	and	r24, r24
     efa:	09 f0       	breq	.+2      	; 0xefe <disk_write+0x1a>
     efc:	57 c0       	rjmp	.+174    	; 0xfac <disk_write+0xc8>
     efe:	00 23       	and	r16, r16
     f00:	09 f4       	brne	.+2      	; 0xf04 <disk_write+0x20>
     f02:	56 c0       	rjmp	.+172    	; 0xfb0 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     f04:	80 91 8a 01 	lds	r24, 0x018A
     f08:	80 fd       	sbrc	r24, 0
     f0a:	54 c0       	rjmp	.+168    	; 0xfb4 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     f0c:	80 91 8a 01 	lds	r24, 0x018A
     f10:	82 fd       	sbrc	r24, 2
     f12:	52 c0       	rjmp	.+164    	; 0xfb8 <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     f14:	80 91 7e 02 	lds	r24, 0x027E
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	83 fd       	sbrc	r24, 3
     f1c:	09 c0       	rjmp	.+18     	; 0xf30 <disk_write+0x4c>
     f1e:	0b 2e       	mov	r0, r27
     f20:	b9 e0       	ldi	r27, 0x09	; 9
     f22:	cc 0c       	add	r12, r12
     f24:	dd 1c       	adc	r13, r13
     f26:	ee 1c       	adc	r14, r14
     f28:	ff 1c       	adc	r15, r15
     f2a:	ba 95       	dec	r27
     f2c:	d1 f7       	brne	.-12     	; 0xf22 <disk_write+0x3e>
     f2e:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     f30:	01 30       	cpi	r16, 0x01	; 1
     f32:	71 f4       	brne	.+28     	; 0xf50 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     f34:	88 e1       	ldi	r24, 0x18	; 24
     f36:	b7 01       	movw	r22, r14
     f38:	a6 01       	movw	r20, r12
     f3a:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     f3e:	88 23       	and	r24, r24
     f40:	71 f5       	brne	.+92     	; 0xf9e <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     f42:	ce 01       	movw	r24, r28
     f44:	6e ef       	ldi	r22, 0xFE	; 254
     f46:	0e 94 b8 05 	call	0xb70	; 0xb70 <xmit_datablock>
     f4a:	00 97       	sbiw	r24, 0x00	; 0
     f4c:	29 f5       	brne	.+74     	; 0xf98 <disk_write+0xb4>
     f4e:	27 c0       	rjmp	.+78     	; 0xf9e <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     f50:	86 70       	andi	r24, 0x06	; 6
     f52:	90 70       	andi	r25, 0x00	; 0
     f54:	00 97       	sbiw	r24, 0x00	; 0
     f56:	39 f0       	breq	.+14     	; 0xf66 <disk_write+0x82>
     f58:	40 2f       	mov	r20, r16
     f5a:	50 e0       	ldi	r21, 0x00	; 0
     f5c:	60 e0       	ldi	r22, 0x00	; 0
     f5e:	70 e0       	ldi	r23, 0x00	; 0
     f60:	87 e9       	ldi	r24, 0x97	; 151
     f62:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     f66:	89 e1       	ldi	r24, 0x19	; 25
     f68:	b7 01       	movw	r22, r14
     f6a:	a6 01       	movw	r20, r12
     f6c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
     f70:	88 23       	and	r24, r24
     f72:	a9 f4       	brne	.+42     	; 0xf9e <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     f74:	ce 01       	movw	r24, r28
     f76:	6c ef       	ldi	r22, 0xFC	; 252
     f78:	0e 94 b8 05 	call	0xb70	; 0xb70 <xmit_datablock>
     f7c:	00 97       	sbiw	r24, 0x00	; 0
     f7e:	21 f0       	breq	.+8      	; 0xf88 <disk_write+0xa4>
				buff += 512;
     f80:	c0 50       	subi	r28, 0x00	; 0
     f82:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     f84:	01 50       	subi	r16, 0x01	; 1
     f86:	b1 f7       	brne	.-20     	; 0xf74 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	6d ef       	ldi	r22, 0xFD	; 253
     f8e:	0e 94 b8 05 	call	0xb70	; 0xb70 <xmit_datablock>
     f92:	00 97       	sbiw	r24, 0x00	; 0
     f94:	19 f0       	breq	.+6      	; 0xf9c <disk_write+0xb8>
     f96:	03 c0       	rjmp	.+6      	; 0xf9e <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     f98:	00 e0       	ldi	r16, 0x00	; 0
     f9a:	01 c0       	rjmp	.+2      	; 0xf9e <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     f9c:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     f9e:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>

	return count ? RES_ERROR : RES_OK;
     fa2:	81 e0       	ldi	r24, 0x01	; 1
     fa4:	00 23       	and	r16, r16
     fa6:	49 f4       	brne	.+18     	; 0xfba <disk_write+0xd6>
     fa8:	80 e0       	ldi	r24, 0x00	; 0
     faa:	07 c0       	rjmp	.+14     	; 0xfba <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     fac:	84 e0       	ldi	r24, 0x04	; 4
     fae:	05 c0       	rjmp	.+10     	; 0xfba <disk_write+0xd6>
     fb0:	84 e0       	ldi	r24, 0x04	; 4
     fb2:	03 c0       	rjmp	.+6      	; 0xfba <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     fb4:	83 e0       	ldi	r24, 0x03	; 3
     fb6:	01 c0       	rjmp	.+2      	; 0xfba <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     fb8:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	0f 91       	pop	r16
     fc0:	ff 90       	pop	r15
     fc2:	ef 90       	pop	r14
     fc4:	df 90       	pop	r13
     fc6:	cf 90       	pop	r12
     fc8:	08 95       	ret

00000fca <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     fca:	ef 92       	push	r14
     fcc:	ff 92       	push	r15
     fce:	0f 93       	push	r16
     fd0:	1f 93       	push	r17
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
     fd6:	cd b7       	in	r28, 0x3d	; 61
     fd8:	de b7       	in	r29, 0x3e	; 62
     fda:	60 97       	sbiw	r28, 0x10	; 16
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	f8 94       	cli
     fe0:	de bf       	out	0x3e, r29	; 62
     fe2:	0f be       	out	0x3f, r0	; 63
     fe4:	cd bf       	out	0x3d, r28	; 61
     fe6:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     fe8:	88 23       	and	r24, r24
     fea:	09 f0       	breq	.+2      	; 0xfee <disk_ioctl+0x24>
     fec:	da c1       	rjmp	.+948    	; 0x13a2 <__stack+0x2a3>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     fee:	65 30       	cpi	r22, 0x05	; 5
     ff0:	89 f4       	brne	.+34     	; 0x1014 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     ff2:	fa 01       	movw	r30, r20
     ff4:	80 81       	ld	r24, Z
     ff6:	88 23       	and	r24, r24
     ff8:	21 f0       	breq	.+8      	; 0x1002 <disk_ioctl+0x38>
     ffa:	81 30       	cpi	r24, 0x01	; 1
     ffc:	09 f0       	breq	.+2      	; 0x1000 <disk_ioctl+0x36>
     ffe:	d3 c1       	rjmp	.+934    	; 0x13a6 <__stack+0x2a7>
    1000:	04 c0       	rjmp	.+8      	; 0x100a <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
    1002:	0e 94 3b 05 	call	0xa76	; 0xa76 <power_off>
			res = RES_OK;
    1006:	00 e0       	ldi	r16, 0x00	; 0
			break;
    1008:	d1 c1       	rjmp	.+930    	; 0x13ac <__stack+0x2ad>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	fa 01       	movw	r30, r20
    100e:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
    1010:	00 e0       	ldi	r16, 0x00	; 0
			break;
    1012:	cc c1       	rjmp	.+920    	; 0x13ac <__stack+0x2ad>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
    1014:	80 91 8a 01 	lds	r24, 0x018A
    1018:	80 fd       	sbrc	r24, 0
    101a:	c7 c1       	rjmp	.+910    	; 0x13aa <__stack+0x2ab>

		switch (ctrl) {
    101c:	6a 30       	cpi	r22, 0x0A	; 10
    101e:	09 f4       	brne	.+2      	; 0x1022 <disk_ioctl+0x58>
    1020:	44 c1       	rjmp	.+648    	; 0x12aa <__stack+0x1ab>
    1022:	6b 30       	cpi	r22, 0x0B	; 11
    1024:	58 f4       	brcc	.+22     	; 0x103c <disk_ioctl+0x72>
    1026:	61 30       	cpi	r22, 0x01	; 1
    1028:	f9 f0       	breq	.+62     	; 0x1068 <disk_ioctl+0x9e>
    102a:	61 30       	cpi	r22, 0x01	; 1
    102c:	a0 f0       	brcs	.+40     	; 0x1056 <disk_ioctl+0x8c>
    102e:	62 30       	cpi	r22, 0x02	; 2
    1030:	09 f4       	brne	.+2      	; 0x1034 <disk_ioctl+0x6a>
    1032:	98 c0       	rjmp	.+304    	; 0x1164 <__stack+0x65>
    1034:	63 30       	cpi	r22, 0x03	; 3
    1036:	09 f0       	breq	.+2      	; 0x103a <disk_ioctl+0x70>
    1038:	94 c1       	rjmp	.+808    	; 0x1362 <__stack+0x263>
    103a:	9b c0       	rjmp	.+310    	; 0x1172 <__stack+0x73>
    103c:	6c 30       	cpi	r22, 0x0C	; 12
    103e:	09 f4       	brne	.+2      	; 0x1042 <disk_ioctl+0x78>
    1040:	4f c1       	rjmp	.+670    	; 0x12e0 <__stack+0x1e1>
    1042:	6c 30       	cpi	r22, 0x0C	; 12
    1044:	08 f4       	brcc	.+2      	; 0x1048 <disk_ioctl+0x7e>
    1046:	37 c1       	rjmp	.+622    	; 0x12b6 <__stack+0x1b7>
    1048:	6d 30       	cpi	r22, 0x0D	; 13
    104a:	09 f4       	brne	.+2      	; 0x104e <disk_ioctl+0x84>
    104c:	5e c1       	rjmp	.+700    	; 0x130a <__stack+0x20b>
    104e:	6e 30       	cpi	r22, 0x0E	; 14
    1050:	09 f0       	breq	.+2      	; 0x1054 <disk_ioctl+0x8a>
    1052:	87 c1       	rjmp	.+782    	; 0x1362 <__stack+0x263>
    1054:	70 c1       	rjmp	.+736    	; 0x1336 <__stack+0x237>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
    1056:	0e 94 61 05 	call	0xac2	; 0xac2 <select>
    105a:	00 97       	sbiw	r24, 0x00	; 0
    105c:	09 f4       	brne	.+2      	; 0x1060 <disk_ioctl+0x96>
    105e:	83 c1       	rjmp	.+774    	; 0x1366 <__stack+0x267>
				deselect();
    1060:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
				res = RES_OK;
    1064:	00 e0       	ldi	r16, 0x00	; 0
    1066:	9a c1       	rjmp	.+820    	; 0x139c <__stack+0x29d>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    1068:	89 e0       	ldi	r24, 0x09	; 9
    106a:	40 e0       	ldi	r20, 0x00	; 0
    106c:	50 e0       	ldi	r21, 0x00	; 0
    106e:	ba 01       	movw	r22, r20
    1070:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    1074:	88 23       	and	r24, r24
    1076:	09 f0       	breq	.+2      	; 0x107a <disk_ioctl+0xb0>
    1078:	78 c1       	rjmp	.+752    	; 0x136a <__stack+0x26b>
    107a:	ce 01       	movw	r24, r28
    107c:	01 96       	adiw	r24, 0x01	; 1
    107e:	40 e1       	ldi	r20, 0x10	; 16
    1080:	50 e0       	ldi	r21, 0x00	; 0
    1082:	60 e0       	ldi	r22, 0x00	; 0
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    108a:	00 97       	sbiw	r24, 0x00	; 0
    108c:	09 f4       	brne	.+2      	; 0x1090 <disk_ioctl+0xc6>
    108e:	6f c1       	rjmp	.+734    	; 0x136e <__stack+0x26f>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	82 95       	swap	r24
    1094:	86 95       	lsr	r24
    1096:	86 95       	lsr	r24
    1098:	83 70       	andi	r24, 0x03	; 3
    109a:	81 30       	cpi	r24, 0x01	; 1
    109c:	51 f5       	brne	.+84     	; 0x10f2 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    109e:	48 85       	ldd	r20, Y+8	; 0x08
    10a0:	50 e0       	ldi	r21, 0x00	; 0
    10a2:	60 e0       	ldi	r22, 0x00	; 0
    10a4:	70 e0       	ldi	r23, 0x00	; 0
    10a6:	4f 73       	andi	r20, 0x3F	; 63
    10a8:	50 70       	andi	r21, 0x00	; 0
    10aa:	60 70       	andi	r22, 0x00	; 0
    10ac:	70 70       	andi	r23, 0x00	; 0
    10ae:	ba 01       	movw	r22, r20
    10b0:	55 27       	eor	r21, r21
    10b2:	44 27       	eor	r20, r20
    10b4:	4f 5f       	subi	r20, 0xFF	; 255
    10b6:	5f 4f       	sbci	r21, 0xFF	; 255
    10b8:	6f 4f       	sbci	r22, 0xFF	; 255
    10ba:	7f 4f       	sbci	r23, 0xFF	; 255
    10bc:	99 85       	ldd	r25, Y+9	; 0x09
    10be:	80 e0       	ldi	r24, 0x00	; 0
    10c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    10c2:	82 0f       	add	r24, r18
    10c4:	91 1d       	adc	r25, r1
    10c6:	a0 e0       	ldi	r26, 0x00	; 0
    10c8:	b0 e0       	ldi	r27, 0x00	; 0
    10ca:	84 0f       	add	r24, r20
    10cc:	95 1f       	adc	r25, r21
    10ce:	a6 1f       	adc	r26, r22
    10d0:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
    10d2:	07 2e       	mov	r0, r23
    10d4:	7a e0       	ldi	r23, 0x0A	; 10
    10d6:	88 0f       	add	r24, r24
    10d8:	99 1f       	adc	r25, r25
    10da:	aa 1f       	adc	r26, r26
    10dc:	bb 1f       	adc	r27, r27
    10de:	7a 95       	dec	r23
    10e0:	d1 f7       	brne	.-12     	; 0x10d6 <disk_ioctl+0x10c>
    10e2:	70 2d       	mov	r23, r0
    10e4:	f7 01       	movw	r30, r14
    10e6:	80 83       	st	Z, r24
    10e8:	91 83       	std	Z+1, r25	; 0x01
    10ea:	a2 83       	std	Z+2, r26	; 0x02
    10ec:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
    10ee:	00 e0       	ldi	r16, 0x00	; 0
    10f0:	55 c1       	rjmp	.+682    	; 0x139c <__stack+0x29d>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    10f2:	29 85       	ldd	r18, Y+9	; 0x09
    10f4:	22 95       	swap	r18
    10f6:	26 95       	lsr	r18
    10f8:	26 95       	lsr	r18
    10fa:	23 70       	andi	r18, 0x03	; 3
    10fc:	88 85       	ldd	r24, Y+8	; 0x08
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	88 0f       	add	r24, r24
    1102:	99 1f       	adc	r25, r25
    1104:	88 0f       	add	r24, r24
    1106:	99 1f       	adc	r25, r25
    1108:	82 0f       	add	r24, r18
    110a:	91 1d       	adc	r25, r1
    110c:	01 96       	adiw	r24, 0x01	; 1
    110e:	2f 81       	ldd	r18, Y+7	; 0x07
    1110:	30 e0       	ldi	r19, 0x00	; 0
    1112:	23 70       	andi	r18, 0x03	; 3
    1114:	30 70       	andi	r19, 0x00	; 0
    1116:	32 2f       	mov	r19, r18
    1118:	22 27       	eor	r18, r18
    111a:	33 0f       	add	r19, r19
    111c:	33 0f       	add	r19, r19
    111e:	82 0f       	add	r24, r18
    1120:	93 1f       	adc	r25, r19
    1122:	ac 01       	movw	r20, r24
    1124:	60 e0       	ldi	r22, 0x00	; 0
    1126:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    1128:	9e 81       	ldd	r25, Y+6	; 0x06
    112a:	9f 70       	andi	r25, 0x0F	; 15
    112c:	8b 85       	ldd	r24, Y+11	; 0x0b
    112e:	88 1f       	adc	r24, r24
    1130:	88 27       	eor	r24, r24
    1132:	88 1f       	adc	r24, r24
    1134:	98 0f       	add	r25, r24
    1136:	9e 5f       	subi	r25, 0xFE	; 254
    1138:	8a 85       	ldd	r24, Y+10	; 0x0a
    113a:	83 70       	andi	r24, 0x03	; 3
    113c:	88 0f       	add	r24, r24
    113e:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	09 97       	sbiw	r24, 0x09	; 9
    1144:	8a 01       	movw	r16, r20
    1146:	9b 01       	movw	r18, r22
    1148:	04 c0       	rjmp	.+8      	; 0x1152 <__stack+0x53>
    114a:	00 0f       	add	r16, r16
    114c:	11 1f       	adc	r17, r17
    114e:	22 1f       	adc	r18, r18
    1150:	33 1f       	adc	r19, r19
    1152:	8a 95       	dec	r24
    1154:	d2 f7       	brpl	.-12     	; 0x114a <__stack+0x4b>
    1156:	f7 01       	movw	r30, r14
    1158:	00 83       	st	Z, r16
    115a:	11 83       	std	Z+1, r17	; 0x01
    115c:	22 83       	std	Z+2, r18	; 0x02
    115e:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
    1160:	00 e0       	ldi	r16, 0x00	; 0
    1162:	1c c1       	rjmp	.+568    	; 0x139c <__stack+0x29d>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	92 e0       	ldi	r25, 0x02	; 2
    1168:	fa 01       	movw	r30, r20
    116a:	91 83       	std	Z+1, r25	; 0x01
    116c:	80 83       	st	Z, r24
			res = RES_OK;
    116e:	00 e0       	ldi	r16, 0x00	; 0
			break;
    1170:	15 c1       	rjmp	.+554    	; 0x139c <__stack+0x29d>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
    1172:	00 91 7e 02 	lds	r16, 0x027E
    1176:	02 ff       	sbrs	r16, 2
    1178:	31 c0       	rjmp	.+98     	; 0x11dc <__stack+0xdd>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
    117a:	8d e8       	ldi	r24, 0x8D	; 141
    117c:	40 e0       	ldi	r20, 0x00	; 0
    117e:	50 e0       	ldi	r21, 0x00	; 0
    1180:	ba 01       	movw	r22, r20
    1182:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    1186:	88 23       	and	r24, r24
    1188:	09 f0       	breq	.+2      	; 0x118c <__stack+0x8d>
    118a:	f3 c0       	rjmp	.+486    	; 0x1372 <__stack+0x273>
					xchg_spi(0xFF);
    118c:	8f ef       	ldi	r24, 0xFF	; 255
    118e:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
    1192:	ce 01       	movw	r24, r28
    1194:	01 96       	adiw	r24, 0x01	; 1
    1196:	40 e1       	ldi	r20, 0x10	; 16
    1198:	50 e0       	ldi	r21, 0x00	; 0
    119a:	60 e0       	ldi	r22, 0x00	; 0
    119c:	70 e0       	ldi	r23, 0x00	; 0
    119e:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    11a2:	00 97       	sbiw	r24, 0x00	; 0
    11a4:	09 f4       	brne	.+2      	; 0x11a8 <__stack+0xa9>
    11a6:	e7 c0       	rjmp	.+462    	; 0x1376 <__stack+0x277>
    11a8:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
    11aa:	8f ef       	ldi	r24, 0xFF	; 255
    11ac:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
    11b0:	01 50       	subi	r16, 0x01	; 1
    11b2:	d9 f7       	brne	.-10     	; 0x11aa <__stack+0xab>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
    11b4:	2b 85       	ldd	r18, Y+11	; 0x0b
    11b6:	22 95       	swap	r18
    11b8:	2f 70       	andi	r18, 0x0F	; 15
    11ba:	80 e1       	ldi	r24, 0x10	; 16
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	a0 e0       	ldi	r26, 0x00	; 0
    11c0:	b0 e0       	ldi	r27, 0x00	; 0
    11c2:	04 c0       	rjmp	.+8      	; 0x11cc <__stack+0xcd>
    11c4:	88 0f       	add	r24, r24
    11c6:	99 1f       	adc	r25, r25
    11c8:	aa 1f       	adc	r26, r26
    11ca:	bb 1f       	adc	r27, r27
    11cc:	2a 95       	dec	r18
    11ce:	d2 f7       	brpl	.-12     	; 0x11c4 <__stack+0xc5>
    11d0:	f7 01       	movw	r30, r14
    11d2:	80 83       	st	Z, r24
    11d4:	91 83       	std	Z+1, r25	; 0x01
    11d6:	a2 83       	std	Z+2, r26	; 0x02
    11d8:	b3 83       	std	Z+3, r27	; 0x03
    11da:	e0 c0       	rjmp	.+448    	; 0x139c <__stack+0x29d>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
    11dc:	89 e0       	ldi	r24, 0x09	; 9
    11de:	40 e0       	ldi	r20, 0x00	; 0
    11e0:	50 e0       	ldi	r21, 0x00	; 0
    11e2:	ba 01       	movw	r22, r20
    11e4:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    11e8:	88 23       	and	r24, r24
    11ea:	09 f0       	breq	.+2      	; 0x11ee <__stack+0xef>
    11ec:	c6 c0       	rjmp	.+396    	; 0x137a <__stack+0x27b>
    11ee:	ce 01       	movw	r24, r28
    11f0:	01 96       	adiw	r24, 0x01	; 1
    11f2:	40 e1       	ldi	r20, 0x10	; 16
    11f4:	50 e0       	ldi	r21, 0x00	; 0
    11f6:	60 e0       	ldi	r22, 0x00	; 0
    11f8:	70 e0       	ldi	r23, 0x00	; 0
    11fa:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    11fe:	00 97       	sbiw	r24, 0x00	; 0
    1200:	09 f4       	brne	.+2      	; 0x1204 <__stack+0x105>
    1202:	bd c0       	rjmp	.+378    	; 0x137e <__stack+0x27f>
					if (CardType & CT_SD1) {	/* SDv1 */
    1204:	01 ff       	sbrs	r16, 1
    1206:	25 c0       	rjmp	.+74     	; 0x1252 <__stack+0x153>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
    1208:	8c 85       	ldd	r24, Y+12	; 0x0c
    120a:	88 1f       	adc	r24, r24
    120c:	88 27       	eor	r24, r24
    120e:	88 1f       	adc	r24, r24
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	01 96       	adiw	r24, 0x01	; 1
    1214:	2b 85       	ldd	r18, Y+11	; 0x0b
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	2f 73       	andi	r18, 0x3F	; 63
    121a:	30 70       	andi	r19, 0x00	; 0
    121c:	22 0f       	add	r18, r18
    121e:	33 1f       	adc	r19, r19
    1220:	28 0f       	add	r18, r24
    1222:	39 1f       	adc	r19, r25
    1224:	8e 85       	ldd	r24, Y+14	; 0x0e
    1226:	82 95       	swap	r24
    1228:	86 95       	lsr	r24
    122a:	86 95       	lsr	r24
    122c:	83 70       	andi	r24, 0x03	; 3
    122e:	90 e0       	ldi	r25, 0x00	; 0
    1230:	01 97       	sbiw	r24, 0x01	; 1
    1232:	89 01       	movw	r16, r18
    1234:	02 c0       	rjmp	.+4      	; 0x123a <__stack+0x13b>
    1236:	00 0f       	add	r16, r16
    1238:	11 1f       	adc	r17, r17
    123a:	8a 95       	dec	r24
    123c:	e2 f7       	brpl	.-8      	; 0x1236 <__stack+0x137>
    123e:	c8 01       	movw	r24, r16
    1240:	a0 e0       	ldi	r26, 0x00	; 0
    1242:	b0 e0       	ldi	r27, 0x00	; 0
    1244:	f7 01       	movw	r30, r14
    1246:	80 83       	st	Z, r24
    1248:	91 83       	std	Z+1, r25	; 0x01
    124a:	a2 83       	std	Z+2, r26	; 0x02
    124c:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
    124e:	00 e0       	ldi	r16, 0x00	; 0
    1250:	a5 c0       	rjmp	.+330    	; 0x139c <__stack+0x29d>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
    1252:	8c 85       	ldd	r24, Y+12	; 0x0c
    1254:	48 2f       	mov	r20, r24
    1256:	50 e0       	ldi	r21, 0x00	; 0
    1258:	43 70       	andi	r20, 0x03	; 3
    125a:	50 70       	andi	r21, 0x00	; 0
    125c:	44 0f       	add	r20, r20
    125e:	55 1f       	adc	r21, r21
    1260:	44 0f       	add	r20, r20
    1262:	55 1f       	adc	r21, r21
    1264:	44 0f       	add	r20, r20
    1266:	55 1f       	adc	r21, r21
    1268:	82 95       	swap	r24
    126a:	86 95       	lsr	r24
    126c:	87 70       	andi	r24, 0x07	; 7
    126e:	48 0f       	add	r20, r24
    1270:	51 1d       	adc	r21, r1
    1272:	4f 5f       	subi	r20, 0xFF	; 255
    1274:	5f 4f       	sbci	r21, 0xFF	; 255
    1276:	2b 85       	ldd	r18, Y+11	; 0x0b
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	2c 77       	andi	r18, 0x7C	; 124
    127c:	30 70       	andi	r19, 0x00	; 0
    127e:	35 95       	asr	r19
    1280:	27 95       	ror	r18
    1282:	35 95       	asr	r19
    1284:	27 95       	ror	r18
    1286:	2f 5f       	subi	r18, 0xFF	; 255
    1288:	3f 4f       	sbci	r19, 0xFF	; 255
    128a:	42 9f       	mul	r20, r18
    128c:	c0 01       	movw	r24, r0
    128e:	43 9f       	mul	r20, r19
    1290:	90 0d       	add	r25, r0
    1292:	52 9f       	mul	r21, r18
    1294:	90 0d       	add	r25, r0
    1296:	11 24       	eor	r1, r1
    1298:	a0 e0       	ldi	r26, 0x00	; 0
    129a:	b0 e0       	ldi	r27, 0x00	; 0
    129c:	f7 01       	movw	r30, r14
    129e:	80 83       	st	Z, r24
    12a0:	91 83       	std	Z+1, r25	; 0x01
    12a2:	a2 83       	std	Z+2, r26	; 0x02
    12a4:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
    12a6:	00 e0       	ldi	r16, 0x00	; 0
    12a8:	79 c0       	rjmp	.+242    	; 0x139c <__stack+0x29d>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
    12aa:	80 91 7e 02 	lds	r24, 0x027E
    12ae:	fa 01       	movw	r30, r20
    12b0:	80 83       	st	Z, r24
			res = RES_OK;
    12b2:	00 e0       	ldi	r16, 0x00	; 0
			break;
    12b4:	73 c0       	rjmp	.+230    	; 0x139c <__stack+0x29d>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
    12b6:	89 e0       	ldi	r24, 0x09	; 9
    12b8:	40 e0       	ldi	r20, 0x00	; 0
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	ba 01       	movw	r22, r20
    12be:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    12c2:	88 23       	and	r24, r24
    12c4:	09 f0       	breq	.+2      	; 0x12c8 <__stack+0x1c9>
    12c6:	5d c0       	rjmp	.+186    	; 0x1382 <__stack+0x283>
				&& rcvr_datablock(ptr, 16))
    12c8:	c7 01       	movw	r24, r14
    12ca:	40 e1       	ldi	r20, 0x10	; 16
    12cc:	50 e0       	ldi	r21, 0x00	; 0
    12ce:	60 e0       	ldi	r22, 0x00	; 0
    12d0:	70 e0       	ldi	r23, 0x00	; 0
    12d2:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    12d6:	00 97       	sbiw	r24, 0x00	; 0
    12d8:	09 f0       	breq	.+2      	; 0x12dc <__stack+0x1dd>
    12da:	55 c0       	rjmp	.+170    	; 0x1386 <__stack+0x287>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    12dc:	01 e0       	ldi	r16, 0x01	; 1
    12de:	5e c0       	rjmp	.+188    	; 0x139c <__stack+0x29d>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
    12e0:	8a e0       	ldi	r24, 0x0A	; 10
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	50 e0       	ldi	r21, 0x00	; 0
    12e6:	ba 01       	movw	r22, r20
    12e8:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    12ec:	88 23       	and	r24, r24
    12ee:	09 f0       	breq	.+2      	; 0x12f2 <__stack+0x1f3>
    12f0:	4c c0       	rjmp	.+152    	; 0x138a <__stack+0x28b>
				&& rcvr_datablock(ptr, 16))
    12f2:	c7 01       	movw	r24, r14
    12f4:	40 e1       	ldi	r20, 0x10	; 16
    12f6:	50 e0       	ldi	r21, 0x00	; 0
    12f8:	60 e0       	ldi	r22, 0x00	; 0
    12fa:	70 e0       	ldi	r23, 0x00	; 0
    12fc:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    1300:	00 97       	sbiw	r24, 0x00	; 0
    1302:	09 f0       	breq	.+2      	; 0x1306 <__stack+0x207>
    1304:	44 c0       	rjmp	.+136    	; 0x138e <__stack+0x28f>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    1306:	01 e0       	ldi	r16, 0x01	; 1
    1308:	49 c0       	rjmp	.+146    	; 0x139c <__stack+0x29d>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
    130a:	8a e3       	ldi	r24, 0x3A	; 58
    130c:	40 e0       	ldi	r20, 0x00	; 0
    130e:	50 e0       	ldi	r21, 0x00	; 0
    1310:	ba 01       	movw	r22, r20
    1312:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    1316:	88 23       	and	r24, r24
    1318:	e1 f5       	brne	.+120    	; 0x1392 <__stack+0x293>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
    131a:	87 01       	movw	r16, r14
    131c:	0c 5f       	subi	r16, 0xFC	; 252
    131e:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
    1326:	f7 01       	movw	r30, r14
    1328:	81 93       	st	Z+, r24
    132a:	7f 01       	movw	r14, r30
    132c:	e0 17       	cp	r30, r16
    132e:	f1 07       	cpc	r31, r17
    1330:	b9 f7       	brne	.-18     	; 0x1320 <__stack+0x221>
				res = RES_OK;
    1332:	00 e0       	ldi	r16, 0x00	; 0
    1334:	33 c0       	rjmp	.+102    	; 0x139c <__stack+0x29d>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
    1336:	8d e8       	ldi	r24, 0x8D	; 141
    1338:	40 e0       	ldi	r20, 0x00	; 0
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	ba 01       	movw	r22, r20
    133e:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <send_cmd>
    1342:	88 23       	and	r24, r24
    1344:	41 f5       	brne	.+80     	; 0x1396 <__stack+0x297>
				xchg_spi(0xFF);
    1346:	8f ef       	ldi	r24, 0xFF	; 255
    1348:	0e 94 41 05 	call	0xa82	; 0xa82 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
    134c:	c7 01       	movw	r24, r14
    134e:	40 e4       	ldi	r20, 0x40	; 64
    1350:	50 e0       	ldi	r21, 0x00	; 0
    1352:	60 e0       	ldi	r22, 0x00	; 0
    1354:	70 e0       	ldi	r23, 0x00	; 0
    1356:	0e 94 71 05 	call	0xae2	; 0xae2 <rcvr_datablock>
    135a:	00 97       	sbiw	r24, 0x00	; 0
    135c:	f1 f4       	brne	.+60     	; 0x139a <__stack+0x29b>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    135e:	01 e0       	ldi	r16, 0x01	; 1
    1360:	1d c0       	rjmp	.+58     	; 0x139c <__stack+0x29d>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
    1362:	04 e0       	ldi	r16, 0x04	; 4
    1364:	1b c0       	rjmp	.+54     	; 0x139c <__stack+0x29d>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    1366:	01 e0       	ldi	r16, 0x01	; 1
    1368:	19 c0       	rjmp	.+50     	; 0x139c <__stack+0x29d>
    136a:	01 e0       	ldi	r16, 0x01	; 1
    136c:	17 c0       	rjmp	.+46     	; 0x139c <__stack+0x29d>
    136e:	01 e0       	ldi	r16, 0x01	; 1
    1370:	15 c0       	rjmp	.+42     	; 0x139c <__stack+0x29d>
    1372:	01 e0       	ldi	r16, 0x01	; 1
    1374:	13 c0       	rjmp	.+38     	; 0x139c <__stack+0x29d>
    1376:	01 e0       	ldi	r16, 0x01	; 1
    1378:	11 c0       	rjmp	.+34     	; 0x139c <__stack+0x29d>
    137a:	01 e0       	ldi	r16, 0x01	; 1
    137c:	0f c0       	rjmp	.+30     	; 0x139c <__stack+0x29d>
    137e:	01 e0       	ldi	r16, 0x01	; 1
    1380:	0d c0       	rjmp	.+26     	; 0x139c <__stack+0x29d>
    1382:	01 e0       	ldi	r16, 0x01	; 1
    1384:	0b c0       	rjmp	.+22     	; 0x139c <__stack+0x29d>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
    1386:	00 e0       	ldi	r16, 0x00	; 0
    1388:	09 c0       	rjmp	.+18     	; 0x139c <__stack+0x29d>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    138a:	01 e0       	ldi	r16, 0x01	; 1
    138c:	07 c0       	rjmp	.+14     	; 0x139c <__stack+0x29d>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
    138e:	00 e0       	ldi	r16, 0x00	; 0
    1390:	05 c0       	rjmp	.+10     	; 0x139c <__stack+0x29d>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
    1392:	01 e0       	ldi	r16, 0x01	; 1
    1394:	03 c0       	rjmp	.+6      	; 0x139c <__stack+0x29d>
    1396:	01 e0       	ldi	r16, 0x01	; 1
    1398:	01 c0       	rjmp	.+2      	; 0x139c <__stack+0x29d>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
    139a:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
    139c:	0e 94 5c 05 	call	0xab8	; 0xab8 <deselect>
    13a0:	05 c0       	rjmp	.+10     	; 0x13ac <__stack+0x2ad>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
    13a2:	04 e0       	ldi	r16, 0x04	; 4
    13a4:	03 c0       	rjmp	.+6      	; 0x13ac <__stack+0x2ad>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
    13a6:	04 e0       	ldi	r16, 0x04	; 4
    13a8:	01 c0       	rjmp	.+2      	; 0x13ac <__stack+0x2ad>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
    13aa:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
    13ac:	80 2f       	mov	r24, r16
    13ae:	60 96       	adiw	r28, 0x10	; 16
    13b0:	0f b6       	in	r0, 0x3f	; 63
    13b2:	f8 94       	cli
    13b4:	de bf       	out	0x3e, r29	; 62
    13b6:	0f be       	out	0x3f, r0	; 63
    13b8:	cd bf       	out	0x3d, r28	; 61
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	1f 91       	pop	r17
    13c0:	0f 91       	pop	r16
    13c2:	ff 90       	pop	r15
    13c4:	ef 90       	pop	r14
    13c6:	08 95       	ret

000013c8 <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
    13c8:	80 91 7d 02 	lds	r24, 0x027D
	if (n) Timer1 = --n;
    13cc:	88 23       	and	r24, r24
    13ce:	19 f0       	breq	.+6      	; 0x13d6 <disk_timerproc+0xe>
    13d0:	81 50       	subi	r24, 0x01	; 1
    13d2:	80 93 7d 02 	sts	0x027D, r24
	n = Timer2;
    13d6:	80 91 7c 02 	lds	r24, 0x027C
	if (n) Timer2 = --n;
    13da:	88 23       	and	r24, r24
    13dc:	19 f0       	breq	.+6      	; 0x13e4 <disk_timerproc+0x1c>
    13de:	81 50       	subi	r24, 0x01	; 1
    13e0:	80 93 7c 02 	sts	0x027C, r24

	s = Stat;
    13e4:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
    13e8:	18 9b       	sbis	0x03, 0	; 3
    13ea:	02 c0       	rjmp	.+4      	; 0x13f0 <disk_timerproc+0x28>
		s |= STA_PROTECT;
    13ec:	84 60       	ori	r24, 0x04	; 4
    13ee:	01 c0       	rjmp	.+2      	; 0x13f2 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
    13f0:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
    13f2:	19 99       	sbic	0x03, 1	; 3
    13f4:	02 c0       	rjmp	.+4      	; 0x13fa <disk_timerproc+0x32>
		s &= ~STA_NODISK;
    13f6:	8d 7f       	andi	r24, 0xFD	; 253
    13f8:	01 c0       	rjmp	.+2      	; 0x13fc <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
    13fa:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
    13fc:	80 93 8a 01 	sts	0x018A, r24
}
    1400:	08 95       	ret

00001402 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    1402:	e6 2f       	mov	r30, r22
    1404:	f7 2f       	mov	r31, r23
    1406:	ba 01       	movw	r22, r20
    1408:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    140a:	41 15       	cp	r20, r1
    140c:	51 05       	cpc	r21, r1
    140e:	61 05       	cpc	r22, r1
    1410:	71 05       	cpc	r23, r1
    1412:	59 f0       	breq	.+22     	; 0x142a <mem_cpy+0x28>
    1414:	ae 2f       	mov	r26, r30
    1416:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    1418:	e8 2f       	mov	r30, r24
    141a:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    141c:	8d 91       	ld	r24, X+
    141e:	81 93       	st	Z+, r24
    1420:	41 50       	subi	r20, 0x01	; 1
    1422:	50 40       	sbci	r21, 0x00	; 0
    1424:	60 40       	sbci	r22, 0x00	; 0
    1426:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    1428:	c9 f7       	brne	.-14     	; 0x141c <mem_cpy+0x1a>
    142a:	08 95       	ret

0000142c <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    142c:	a6 2f       	mov	r26, r22
    142e:	ba 01       	movw	r22, r20
    1430:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    1432:	41 15       	cp	r20, r1
    1434:	51 05       	cpc	r21, r1
    1436:	61 05       	cpc	r22, r1
    1438:	71 05       	cpc	r23, r1
    143a:	41 f0       	breq	.+16     	; 0x144c <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    143c:	e8 2f       	mov	r30, r24
    143e:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    1440:	a1 93       	st	Z+, r26
    1442:	41 50       	subi	r20, 0x01	; 1
    1444:	50 40       	sbci	r21, 0x00	; 0
    1446:	60 40       	sbci	r22, 0x00	; 0
    1448:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    144a:	d1 f7       	brne	.-12     	; 0x1440 <mem_set+0x14>
    144c:	08 95       	ret

0000144e <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    144e:	0f 93       	push	r16
    1450:	1f 93       	push	r17
    1452:	dc 01       	movw	r26, r24
    1454:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    1456:	93 8d       	ldd	r25, Z+27	; 0x1b
    1458:	80 e0       	ldi	r24, 0x00	; 0
    145a:	02 8d       	ldd	r16, Z+26	; 0x1a
    145c:	10 e0       	ldi	r17, 0x00	; 0
    145e:	08 2b       	or	r16, r24
    1460:	19 2b       	or	r17, r25
    1462:	20 e0       	ldi	r18, 0x00	; 0
    1464:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    1466:	8c 91       	ld	r24, X
    1468:	83 30       	cpi	r24, 0x03	; 3
    146a:	79 f4       	brne	.+30     	; 0x148a <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    146c:	55 89       	ldd	r21, Z+21	; 0x15
    146e:	40 e0       	ldi	r20, 0x00	; 0
    1470:	84 89       	ldd	r24, Z+20	; 0x14
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	84 2b       	or	r24, r20
    1476:	95 2b       	or	r25, r21
    1478:	a0 e0       	ldi	r26, 0x00	; 0
    147a:	b0 e0       	ldi	r27, 0x00	; 0
    147c:	dc 01       	movw	r26, r24
    147e:	99 27       	eor	r25, r25
    1480:	88 27       	eor	r24, r24
    1482:	08 2b       	or	r16, r24
    1484:	19 2b       	or	r17, r25
    1486:	2a 2b       	or	r18, r26
    1488:	3b 2b       	or	r19, r27

	return cl;
}
    148a:	60 2f       	mov	r22, r16
    148c:	71 2f       	mov	r23, r17
    148e:	82 2f       	mov	r24, r18
    1490:	93 2f       	mov	r25, r19
    1492:	1f 91       	pop	r17
    1494:	0f 91       	pop	r16
    1496:	08 95       	ret

00001498 <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    1498:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    149a:	42 8f       	std	Z+26, r20	; 0x1a
    149c:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    149e:	ab 01       	movw	r20, r22
    14a0:	66 27       	eor	r22, r22
    14a2:	77 27       	eor	r23, r23
    14a4:	44 8b       	std	Z+20, r20	; 0x14
    14a6:	55 8b       	std	Z+21, r21	; 0x15
}
    14a8:	08 95       	ret

000014aa <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    14aa:	ef 92       	push	r14
    14ac:	ff 92       	push	r15
    14ae:	0f 93       	push	r16
    14b0:	1f 93       	push	r17
    14b2:	cf 93       	push	r28
    14b4:	df 93       	push	r29
    14b6:	fc 01       	movw	r30, r24
    14b8:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    14ba:	8b 01       	movw	r16, r22
    14bc:	07 5f       	subi	r16, 0xF7	; 247
    14be:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    14c0:	86 85       	ldd	r24, Z+14	; 0x0e
    14c2:	97 85       	ldd	r25, Z+15	; 0x0f
    14c4:	a0 89       	ldd	r26, Z+16	; 0x10
    14c6:	b1 89       	ldd	r27, Z+17	; 0x11
    14c8:	00 97       	sbiw	r24, 0x00	; 0
    14ca:	a1 05       	cpc	r26, r1
    14cc:	b1 05       	cpc	r27, r1
    14ce:	09 f4       	brne	.+2      	; 0x14d2 <get_fileinfo+0x28>
    14d0:	65 c0       	rjmp	.+202    	; 0x159c <get_fileinfo+0xf2>
		dir = dj->dir;
    14d2:	c2 89       	ldd	r28, Z+18	; 0x12
    14d4:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    14d6:	28 81       	ld	r18, Y
			if (c == ' ') break;
    14d8:	20 32       	cpi	r18, 0x20	; 32
    14da:	99 f0       	breq	.+38     	; 0x1502 <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    14dc:	de 01       	movw	r26, r28
    14de:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    14e0:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    14e6:	35 ee       	ldi	r19, 0xE5	; 229
    14e8:	04 c0       	rjmp	.+8      	; 0x14f2 <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    14ea:	2d 91       	ld	r18, X+
    14ec:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    14ee:	20 32       	cpi	r18, 0x20	; 32
    14f0:	41 f0       	breq	.+16     	; 0x1502 <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    14f2:	25 30       	cpi	r18, 0x05	; 5
    14f4:	09 f4       	brne	.+2      	; 0x14f8 <get_fileinfo+0x4e>
    14f6:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    14f8:	21 93       	st	Z+, r18
    14fa:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    14fc:	87 30       	cpi	r24, 0x07	; 7
    14fe:	91 05       	cpc	r25, r1
    1500:	a1 f7       	brne	.-24     	; 0x14ea <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    1502:	88 85       	ldd	r24, Y+8	; 0x08
    1504:	80 32       	cpi	r24, 0x20	; 32
    1506:	81 f0       	breq	.+32     	; 0x1528 <get_fileinfo+0x7e>
			*p++ = '.';
    1508:	8e e2       	ldi	r24, 0x2E	; 46
    150a:	f8 01       	movw	r30, r16
    150c:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    150e:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    1510:	80 32       	cpi	r24, 0x20	; 32
    1512:	09 f0       	breq	.+2      	; 0x1516 <get_fileinfo+0x6c>
    1514:	4c c0       	rjmp	.+152    	; 0x15ae <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    1516:	0f 5f       	subi	r16, 0xFF	; 255
    1518:	1f 4f       	sbci	r17, 0xFF	; 255
    151a:	06 c0       	rjmp	.+12     	; 0x1528 <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    151c:	8c 01       	movw	r16, r24
    151e:	04 c0       	rjmp	.+8      	; 0x1528 <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1520:	f8 01       	movw	r30, r16
    1522:	23 83       	std	Z+3, r18	; 0x03
    1524:	0c 5f       	subi	r16, 0xFC	; 252
    1526:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    1528:	8b 85       	ldd	r24, Y+11	; 0x0b
    152a:	f7 01       	movw	r30, r14
    152c:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    152e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	a0 e0       	ldi	r26, 0x00	; 0
    1534:	b0 e0       	ldi	r27, 0x00	; 0
    1536:	b8 2f       	mov	r27, r24
    1538:	aa 27       	eor	r26, r26
    153a:	99 27       	eor	r25, r25
    153c:	88 27       	eor	r24, r24
    153e:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	60 e0       	ldi	r22, 0x00	; 0
    1544:	70 e0       	ldi	r23, 0x00	; 0
    1546:	ba 01       	movw	r22, r20
    1548:	55 27       	eor	r21, r21
    154a:	44 27       	eor	r20, r20
    154c:	48 2b       	or	r20, r24
    154e:	59 2b       	or	r21, r25
    1550:	6a 2b       	or	r22, r26
    1552:	7b 2b       	or	r23, r27
    1554:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1556:	90 e0       	ldi	r25, 0x00	; 0
    1558:	a0 e0       	ldi	r26, 0x00	; 0
    155a:	b0 e0       	ldi	r27, 0x00	; 0
    155c:	48 2b       	or	r20, r24
    155e:	59 2b       	or	r21, r25
    1560:	6a 2b       	or	r22, r26
    1562:	7b 2b       	or	r23, r27
    1564:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	a0 e0       	ldi	r26, 0x00	; 0
    156a:	b0 e0       	ldi	r27, 0x00	; 0
    156c:	84 2b       	or	r24, r20
    156e:	95 2b       	or	r25, r21
    1570:	a6 2b       	or	r26, r22
    1572:	b7 2b       	or	r27, r23
    1574:	80 83       	st	Z, r24
    1576:	91 83       	std	Z+1, r25	; 0x01
    1578:	a2 83       	std	Z+2, r26	; 0x02
    157a:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    157c:	39 8d       	ldd	r19, Y+25	; 0x19
    157e:	20 e0       	ldi	r18, 0x00	; 0
    1580:	88 8d       	ldd	r24, Y+24	; 0x18
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	82 2b       	or	r24, r18
    1586:	93 2b       	or	r25, r19
    1588:	95 83       	std	Z+5, r25	; 0x05
    158a:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    158c:	9f 89       	ldd	r25, Y+23	; 0x17
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	2e 89       	ldd	r18, Y+22	; 0x16
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	82 2b       	or	r24, r18
    1596:	93 2b       	or	r25, r19
    1598:	97 83       	std	Z+7, r25	; 0x07
    159a:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    159c:	f8 01       	movw	r30, r16
    159e:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	ff 90       	pop	r15
    15aa:	ef 90       	pop	r14
    15ac:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15ae:	f8 01       	movw	r30, r16
    15b0:	81 83       	std	Z+1, r24	; 0x01
    15b2:	c8 01       	movw	r24, r16
    15b4:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    15b6:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    15b8:	20 32       	cpi	r18, 0x20	; 32
    15ba:	09 f4       	brne	.+2      	; 0x15be <get_fileinfo+0x114>
    15bc:	af cf       	rjmp	.-162    	; 0x151c <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15be:	22 83       	std	Z+2, r18	; 0x02
    15c0:	c8 01       	movw	r24, r16
    15c2:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    15c4:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    15c6:	20 32       	cpi	r18, 0x20	; 32
    15c8:	09 f0       	breq	.+2      	; 0x15cc <get_fileinfo+0x122>
    15ca:	aa cf       	rjmp	.-172    	; 0x1520 <get_fileinfo+0x76>
    15cc:	a7 cf       	rjmp	.-178    	; 0x151c <get_fileinfo+0x72>

000015ce <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    15ce:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    15d0:	ed 91       	ld	r30, X+
    15d2:	fc 91       	ld	r31, X
    15d4:	11 97       	sbiw	r26, 0x01	; 1
    15d6:	30 97       	sbiw	r30, 0x00	; 0
    15d8:	99 f0       	breq	.+38     	; 0x1600 <validate+0x32>
    15da:	80 81       	ld	r24, Z
    15dc:	88 23       	and	r24, r24
    15de:	91 f0       	breq	.+36     	; 0x1604 <validate+0x36>
    15e0:	26 81       	ldd	r18, Z+6	; 0x06
    15e2:	37 81       	ldd	r19, Z+7	; 0x07
    15e4:	12 96       	adiw	r26, 0x02	; 2
    15e6:	8d 91       	ld	r24, X+
    15e8:	9c 91       	ld	r25, X
    15ea:	13 97       	sbiw	r26, 0x03	; 3
    15ec:	28 17       	cp	r18, r24
    15ee:	39 07       	cpc	r19, r25
    15f0:	59 f4       	brne	.+22     	; 0x1608 <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    15f2:	81 81       	ldd	r24, Z+1	; 0x01
    15f4:	0e 94 11 07 	call	0xe22	; 0xe22 <disk_status>
    15f8:	80 ff       	sbrs	r24, 0
    15fa:	08 c0       	rjmp	.+16     	; 0x160c <validate+0x3e>
		return FR_NOT_READY;
    15fc:	83 e0       	ldi	r24, 0x03	; 3
    15fe:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    1600:	89 e0       	ldi	r24, 0x09	; 9
    1602:	08 95       	ret
    1604:	89 e0       	ldi	r24, 0x09	; 9
    1606:	08 95       	ret
    1608:	89 e0       	ldi	r24, 0x09	; 9
    160a:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    160c:	80 e0       	ldi	r24, 0x00	; 0
}
    160e:	08 95       	ret

00001610 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    1610:	0f 93       	push	r16
    1612:	cf 93       	push	r28
    1614:	df 93       	push	r29
    1616:	ec 01       	movw	r28, r24
    1618:	9a 01       	movw	r18, r20
    161a:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    161c:	bc 01       	movw	r22, r24
    161e:	6e 5c       	subi	r22, 0xCE	; 206
    1620:	7f 4f       	sbci	r23, 0xFF	; 255
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	01 e0       	ldi	r16, 0x01	; 1
    1626:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    162a:	88 23       	and	r24, r24
    162c:	09 f0       	breq	.+2      	; 0x1630 <check_fs+0x20>
    162e:	83 c0       	rjmp	.+262    	; 0x1736 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    1630:	fe 01       	movw	r30, r28
    1632:	ef 5c       	subi	r30, 0xCF	; 207
    1634:	fd 4f       	sbci	r31, 0xFD	; 253
    1636:	90 81       	ld	r25, Z
    1638:	80 e0       	ldi	r24, 0x00	; 0
    163a:	fe 01       	movw	r30, r28
    163c:	e0 5d       	subi	r30, 0xD0	; 208
    163e:	fd 4f       	sbci	r31, 0xFD	; 253
    1640:	20 81       	ld	r18, Z
    1642:	30 e0       	ldi	r19, 0x00	; 0
    1644:	82 2b       	or	r24, r18
    1646:	93 2b       	or	r25, r19
    1648:	2a ea       	ldi	r18, 0xAA	; 170
    164a:	85 35       	cpi	r24, 0x55	; 85
    164c:	92 07       	cpc	r25, r18
    164e:	09 f0       	breq	.+2      	; 0x1652 <check_fs+0x42>
    1650:	74 c0       	rjmp	.+232    	; 0x173a <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    1652:	fe 01       	movw	r30, r28
    1654:	e5 59       	subi	r30, 0x95	; 149
    1656:	ff 4f       	sbci	r31, 0xFF	; 255
    1658:	80 81       	ld	r24, Z
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	a0 e0       	ldi	r26, 0x00	; 0
    165e:	b0 e0       	ldi	r27, 0x00	; 0
    1660:	b8 2f       	mov	r27, r24
    1662:	aa 27       	eor	r26, r26
    1664:	99 27       	eor	r25, r25
    1666:	88 27       	eor	r24, r24
    1668:	fe 01       	movw	r30, r28
    166a:	e6 59       	subi	r30, 0x96	; 150
    166c:	ff 4f       	sbci	r31, 0xFF	; 255
    166e:	40 81       	ld	r20, Z
    1670:	50 e0       	ldi	r21, 0x00	; 0
    1672:	60 e0       	ldi	r22, 0x00	; 0
    1674:	70 e0       	ldi	r23, 0x00	; 0
    1676:	ba 01       	movw	r22, r20
    1678:	55 27       	eor	r21, r21
    167a:	44 27       	eor	r20, r20
    167c:	48 2b       	or	r20, r24
    167e:	59 2b       	or	r21, r25
    1680:	6a 2b       	or	r22, r26
    1682:	7b 2b       	or	r23, r27
    1684:	fe 01       	movw	r30, r28
    1686:	e8 59       	subi	r30, 0x98	; 152
    1688:	ff 4f       	sbci	r31, 0xFF	; 255
    168a:	80 81       	ld	r24, Z
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	a0 e0       	ldi	r26, 0x00	; 0
    1690:	b0 e0       	ldi	r27, 0x00	; 0
    1692:	48 2b       	or	r20, r24
    1694:	59 2b       	or	r21, r25
    1696:	6a 2b       	or	r22, r26
    1698:	7b 2b       	or	r23, r27
    169a:	fe 01       	movw	r30, r28
    169c:	e7 59       	subi	r30, 0x97	; 151
    169e:	ff 4f       	sbci	r31, 0xFF	; 255
    16a0:	90 81       	ld	r25, Z
    16a2:	80 e0       	ldi	r24, 0x00	; 0
    16a4:	a0 e0       	ldi	r26, 0x00	; 0
    16a6:	b0 e0       	ldi	r27, 0x00	; 0
    16a8:	48 2b       	or	r20, r24
    16aa:	59 2b       	or	r21, r25
    16ac:	6a 2b       	or	r22, r26
    16ae:	7b 2b       	or	r23, r27
    16b0:	70 70       	andi	r23, 0x00	; 0
    16b2:	46 34       	cpi	r20, 0x46	; 70
    16b4:	81 e4       	ldi	r24, 0x41	; 65
    16b6:	58 07       	cpc	r21, r24
    16b8:	84 e5       	ldi	r24, 0x54	; 84
    16ba:	68 07       	cpc	r22, r24
    16bc:	80 e0       	ldi	r24, 0x00	; 0
    16be:	78 07       	cpc	r23, r24
    16c0:	f1 f1       	breq	.+124    	; 0x173e <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    16c2:	fe 01       	movw	r30, r28
    16c4:	e9 57       	subi	r30, 0x79	; 121
    16c6:	ff 4f       	sbci	r31, 0xFF	; 255
    16c8:	80 81       	ld	r24, Z
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	a0 e0       	ldi	r26, 0x00	; 0
    16ce:	b0 e0       	ldi	r27, 0x00	; 0
    16d0:	b8 2f       	mov	r27, r24
    16d2:	aa 27       	eor	r26, r26
    16d4:	99 27       	eor	r25, r25
    16d6:	88 27       	eor	r24, r24
    16d8:	fe 01       	movw	r30, r28
    16da:	ea 57       	subi	r30, 0x7A	; 122
    16dc:	ff 4f       	sbci	r31, 0xFF	; 255
    16de:	40 81       	ld	r20, Z
    16e0:	50 e0       	ldi	r21, 0x00	; 0
    16e2:	60 e0       	ldi	r22, 0x00	; 0
    16e4:	70 e0       	ldi	r23, 0x00	; 0
    16e6:	ba 01       	movw	r22, r20
    16e8:	55 27       	eor	r21, r21
    16ea:	44 27       	eor	r20, r20
    16ec:	48 2b       	or	r20, r24
    16ee:	59 2b       	or	r21, r25
    16f0:	6a 2b       	or	r22, r26
    16f2:	7b 2b       	or	r23, r27
    16f4:	fe 01       	movw	r30, r28
    16f6:	ec 57       	subi	r30, 0x7C	; 124
    16f8:	ff 4f       	sbci	r31, 0xFF	; 255
    16fa:	80 81       	ld	r24, Z
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	a0 e0       	ldi	r26, 0x00	; 0
    1700:	b0 e0       	ldi	r27, 0x00	; 0
    1702:	48 2b       	or	r20, r24
    1704:	59 2b       	or	r21, r25
    1706:	6a 2b       	or	r22, r26
    1708:	7b 2b       	or	r23, r27
    170a:	cb 57       	subi	r28, 0x7B	; 123
    170c:	df 4f       	sbci	r29, 0xFF	; 255
    170e:	98 81       	ld	r25, Y
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	a0 e0       	ldi	r26, 0x00	; 0
    1714:	b0 e0       	ldi	r27, 0x00	; 0
    1716:	48 2b       	or	r20, r24
    1718:	59 2b       	or	r21, r25
    171a:	6a 2b       	or	r22, r26
    171c:	7b 2b       	or	r23, r27
    171e:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	46 34       	cpi	r20, 0x46	; 70
    1724:	91 e4       	ldi	r25, 0x41	; 65
    1726:	59 07       	cpc	r21, r25
    1728:	94 e5       	ldi	r25, 0x54	; 84
    172a:	69 07       	cpc	r22, r25
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	79 07       	cpc	r23, r25
    1730:	39 f4       	brne	.+14     	; 0x1740 <check_fs+0x130>
    1732:	80 e0       	ldi	r24, 0x00	; 0
    1734:	05 c0       	rjmp	.+10     	; 0x1740 <check_fs+0x130>
    1736:	83 e0       	ldi	r24, 0x03	; 3
    1738:	03 c0       	rjmp	.+6      	; 0x1740 <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    173a:	82 e0       	ldi	r24, 0x02	; 2
    173c:	01 c0       	rjmp	.+2      	; 0x1740 <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    173e:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	0f 91       	pop	r16
    1746:	08 95       	ret

00001748 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    1748:	2f 92       	push	r2
    174a:	3f 92       	push	r3
    174c:	4f 92       	push	r4
    174e:	5f 92       	push	r5
    1750:	6f 92       	push	r6
    1752:	7f 92       	push	r7
    1754:	8f 92       	push	r8
    1756:	9f 92       	push	r9
    1758:	af 92       	push	r10
    175a:	bf 92       	push	r11
    175c:	cf 92       	push	r12
    175e:	df 92       	push	r13
    1760:	ef 92       	push	r14
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	cd b7       	in	r28, 0x3d	; 61
    176e:	de b7       	in	r29, 0x3e	; 62
    1770:	60 97       	sbiw	r28, 0x10	; 16
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	de bf       	out	0x3e, r29	; 62
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	8b 01       	movw	r16, r22
    177e:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    1780:	dc 01       	movw	r26, r24
    1782:	ed 91       	ld	r30, X+
    1784:	fc 91       	ld	r31, X
    1786:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    1788:	40 81       	ld	r20, Z
    178a:	50 e0       	ldi	r21, 0x00	; 0
    178c:	40 53       	subi	r20, 0x30	; 48
    178e:	50 40       	sbci	r21, 0x00	; 0
    1790:	66 27       	eor	r22, r22
    1792:	57 fd       	sbrc	r21, 7
    1794:	60 95       	com	r22
    1796:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    1798:	4a 30       	cpi	r20, 0x0A	; 10
    179a:	51 05       	cpc	r21, r1
    179c:	61 05       	cpc	r22, r1
    179e:	71 05       	cpc	r23, r1
    17a0:	48 f4       	brcc	.+18     	; 0x17b4 <chk_mounted+0x6c>
    17a2:	81 81       	ldd	r24, Z+1	; 0x01
    17a4:	8a 33       	cpi	r24, 0x3A	; 58
    17a6:	31 f4       	brne	.+12     	; 0x17b4 <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    17a8:	cf 01       	movw	r24, r30
    17aa:	02 96       	adiw	r24, 0x02	; 2
    17ac:	11 96       	adiw	r26, 0x01	; 1
    17ae:	9c 93       	st	X, r25
    17b0:	8e 93       	st	-X, r24
    17b2:	05 c0       	rjmp	.+10     	; 0x17be <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    17b4:	40 91 81 02 	lds	r20, 0x0281
    17b8:	50 e0       	ldi	r21, 0x00	; 0
    17ba:	60 e0       	ldi	r22, 0x00	; 0
    17bc:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    17be:	f8 01       	movw	r30, r16
    17c0:	11 82       	std	Z+1, r1	; 0x01
    17c2:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    17c4:	41 15       	cp	r20, r1
    17c6:	51 05       	cpc	r21, r1
    17c8:	61 05       	cpc	r22, r1
    17ca:	71 05       	cpc	r23, r1
    17cc:	09 f0       	breq	.+2      	; 0x17d0 <chk_mounted+0x88>
    17ce:	a3 c3       	rjmp	.+1862   	; 0x1f16 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    17d0:	e0 90 7f 02 	lds	r14, 0x027F
    17d4:	f0 90 80 02 	lds	r15, 0x0280
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    17d8:	e1 14       	cp	r14, r1
    17da:	f1 04       	cpc	r15, r1
    17dc:	09 f4       	brne	.+2      	; 0x17e0 <chk_mounted+0x98>
    17de:	9d c3       	rjmp	.+1850   	; 0x1f1a <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    17e0:	f1 82       	std	Z+1, r15	; 0x01
    17e2:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    17e4:	d7 01       	movw	r26, r14
    17e6:	8c 91       	ld	r24, X
    17e8:	88 23       	and	r24, r24
    17ea:	69 f0       	breq	.+26     	; 0x1806 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    17ec:	11 96       	adiw	r26, 0x01	; 1
    17ee:	8c 91       	ld	r24, X
    17f0:	0e 94 11 07 	call	0xe22	; 0xe22 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    17f4:	80 fd       	sbrc	r24, 0
    17f6:	07 c0       	rjmp	.+14     	; 0x1806 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    17f8:	dd 20       	and	r13, r13
    17fa:	09 f4       	brne	.+2      	; 0x17fe <chk_mounted+0xb6>
    17fc:	90 c3       	rjmp	.+1824   	; 0x1f1e <chk_mounted+0x7d6>
    17fe:	82 fd       	sbrc	r24, 2
    1800:	90 c3       	rjmp	.+1824   	; 0x1f22 <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1802:	80 e0       	ldi	r24, 0x00	; 0
    1804:	af c3       	rjmp	.+1886   	; 0x1f64 <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    1806:	f7 01       	movw	r30, r14
    1808:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    180a:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    180c:	80 e0       	ldi	r24, 0x00	; 0
    180e:	0e 94 41 06 	call	0xc82	; 0xc82 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    1812:	80 fd       	sbrc	r24, 0
    1814:	88 c3       	rjmp	.+1808   	; 0x1f26 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    1816:	dd 20       	and	r13, r13
    1818:	11 f0       	breq	.+4      	; 0x181e <chk_mounted+0xd6>
    181a:	82 fd       	sbrc	r24, 2
    181c:	86 c3       	rjmp	.+1804   	; 0x1f2a <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    181e:	c7 01       	movw	r24, r14
    1820:	40 e0       	ldi	r20, 0x00	; 0
    1822:	50 e0       	ldi	r21, 0x00	; 0
    1824:	ba 01       	movw	r22, r20
    1826:	0e 94 08 0b 	call	0x1610	; 0x1610 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	e9 f5       	brne	.+122    	; 0x18a8 <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    182e:	f7 01       	movw	r30, r14
    1830:	ec 50       	subi	r30, 0x0C	; 12
    1832:	fe 4f       	sbci	r31, 0xFE	; 254
    1834:	80 81       	ld	r24, Z
    1836:	88 23       	and	r24, r24
    1838:	09 f4       	brne	.+2      	; 0x183c <chk_mounted+0xf4>
    183a:	79 c3       	rjmp	.+1778   	; 0x1f2e <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    183c:	f7 01       	movw	r30, r14
    183e:	e5 50       	subi	r30, 0x05	; 5
    1840:	fe 4f       	sbci	r31, 0xFE	; 254
    1842:	80 81       	ld	r24, Z
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	a0 e0       	ldi	r26, 0x00	; 0
    1848:	b0 e0       	ldi	r27, 0x00	; 0
    184a:	b8 2f       	mov	r27, r24
    184c:	aa 27       	eor	r26, r26
    184e:	99 27       	eor	r25, r25
    1850:	88 27       	eor	r24, r24
    1852:	f7 01       	movw	r30, r14
    1854:	e6 50       	subi	r30, 0x06	; 6
    1856:	fe 4f       	sbci	r31, 0xFE	; 254
    1858:	40 81       	ld	r20, Z
    185a:	50 e0       	ldi	r21, 0x00	; 0
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	70 e0       	ldi	r23, 0x00	; 0
    1860:	ba 01       	movw	r22, r20
    1862:	55 27       	eor	r21, r21
    1864:	44 27       	eor	r20, r20
    1866:	84 2b       	or	r24, r20
    1868:	95 2b       	or	r25, r21
    186a:	a6 2b       	or	r26, r22
    186c:	b7 2b       	or	r27, r23
    186e:	f7 01       	movw	r30, r14
    1870:	e8 50       	subi	r30, 0x08	; 8
    1872:	fe 4f       	sbci	r31, 0xFE	; 254
    1874:	40 81       	ld	r20, Z
    1876:	50 e0       	ldi	r21, 0x00	; 0
    1878:	60 e0       	ldi	r22, 0x00	; 0
    187a:	70 e0       	ldi	r23, 0x00	; 0
    187c:	48 2b       	or	r20, r24
    187e:	59 2b       	or	r21, r25
    1880:	6a 2b       	or	r22, r26
    1882:	7b 2b       	or	r23, r27
    1884:	f7 01       	movw	r30, r14
    1886:	e7 50       	subi	r30, 0x07	; 7
    1888:	fe 4f       	sbci	r31, 0xFE	; 254
    188a:	90 81       	ld	r25, Z
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	4c 01       	movw	r8, r24
    1890:	aa 24       	eor	r10, r10
    1892:	bb 24       	eor	r11, r11
    1894:	84 2a       	or	r8, r20
    1896:	95 2a       	or	r9, r21
    1898:	a6 2a       	or	r10, r22
    189a:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    189c:	c7 01       	movw	r24, r14
    189e:	b5 01       	movw	r22, r10
    18a0:	a4 01       	movw	r20, r8
    18a2:	0e 94 08 0b 	call	0x1610	; 0x1610 <check_fs>
    18a6:	03 c0       	rjmp	.+6      	; 0x18ae <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    18a8:	88 24       	eor	r8, r8
    18aa:	99 24       	eor	r9, r9
    18ac:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    18ae:	83 30       	cpi	r24, 0x03	; 3
    18b0:	09 f4       	brne	.+2      	; 0x18b4 <chk_mounted+0x16c>
    18b2:	3f c3       	rjmp	.+1662   	; 0x1f32 <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    18b4:	88 23       	and	r24, r24
    18b6:	09 f0       	breq	.+2      	; 0x18ba <chk_mounted+0x172>
    18b8:	3e c3       	rjmp	.+1660   	; 0x1f36 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    18ba:	d7 01       	movw	r26, r14
    18bc:	de 96       	adiw	r26, 0x3e	; 62
    18be:	9c 91       	ld	r25, X
    18c0:	de 97       	sbiw	r26, 0x3e	; 62
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	dd 96       	adiw	r26, 0x3d	; 61
    18c6:	2c 91       	ld	r18, X
    18c8:	dd 97       	sbiw	r26, 0x3d	; 61
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	82 2b       	or	r24, r18
    18ce:	93 2b       	or	r25, r19
    18d0:	b2 e0       	ldi	r27, 0x02	; 2
    18d2:	80 30       	cpi	r24, 0x00	; 0
    18d4:	9b 07       	cpc	r25, r27
    18d6:	09 f0       	breq	.+2      	; 0x18da <chk_mounted+0x192>
    18d8:	30 c3       	rjmp	.+1632   	; 0x1f3a <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    18da:	f7 01       	movw	r30, r14
    18dc:	e7 5b       	subi	r30, 0xB7	; 183
    18de:	ff 4f       	sbci	r31, 0xFF	; 255
    18e0:	30 81       	ld	r19, Z
    18e2:	20 e0       	ldi	r18, 0x00	; 0
    18e4:	f7 01       	movw	r30, r14
    18e6:	e8 5b       	subi	r30, 0xB8	; 184
    18e8:	ff 4f       	sbci	r31, 0xFF	; 255
    18ea:	80 81       	ld	r24, Z
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	82 2b       	or	r24, r18
    18f0:	93 2b       	or	r25, r19
    18f2:	2c 01       	movw	r4, r24
    18f4:	66 24       	eor	r6, r6
    18f6:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    18f8:	41 14       	cp	r4, r1
    18fa:	51 04       	cpc	r5, r1
    18fc:	61 04       	cpc	r6, r1
    18fe:	71 04       	cpc	r7, r1
    1900:	89 f5       	brne	.+98     	; 0x1964 <chk_mounted+0x21c>
    1902:	f7 01       	movw	r30, r14
    1904:	e7 5a       	subi	r30, 0xA7	; 167
    1906:	ff 4f       	sbci	r31, 0xFF	; 255
    1908:	40 81       	ld	r20, Z
    190a:	50 e0       	ldi	r21, 0x00	; 0
    190c:	60 e0       	ldi	r22, 0x00	; 0
    190e:	70 e0       	ldi	r23, 0x00	; 0
    1910:	74 2f       	mov	r23, r20
    1912:	66 27       	eor	r22, r22
    1914:	55 27       	eor	r21, r21
    1916:	44 27       	eor	r20, r20
    1918:	f7 01       	movw	r30, r14
    191a:	e8 5a       	subi	r30, 0xA8	; 168
    191c:	ff 4f       	sbci	r31, 0xFF	; 255
    191e:	80 81       	ld	r24, Z
    1920:	90 e0       	ldi	r25, 0x00	; 0
    1922:	a0 e0       	ldi	r26, 0x00	; 0
    1924:	b0 e0       	ldi	r27, 0x00	; 0
    1926:	dc 01       	movw	r26, r24
    1928:	99 27       	eor	r25, r25
    192a:	88 27       	eor	r24, r24
    192c:	48 2b       	or	r20, r24
    192e:	59 2b       	or	r21, r25
    1930:	6a 2b       	or	r22, r26
    1932:	7b 2b       	or	r23, r27
    1934:	f7 01       	movw	r30, r14
    1936:	ea 5a       	subi	r30, 0xAA	; 170
    1938:	ff 4f       	sbci	r31, 0xFF	; 255
    193a:	80 81       	ld	r24, Z
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	a0 e0       	ldi	r26, 0x00	; 0
    1940:	b0 e0       	ldi	r27, 0x00	; 0
    1942:	48 2b       	or	r20, r24
    1944:	59 2b       	or	r21, r25
    1946:	6a 2b       	or	r22, r26
    1948:	7b 2b       	or	r23, r27
    194a:	f7 01       	movw	r30, r14
    194c:	e9 5a       	subi	r30, 0xA9	; 169
    194e:	ff 4f       	sbci	r31, 0xFF	; 255
    1950:	90 81       	ld	r25, Z
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	a0 e0       	ldi	r26, 0x00	; 0
    1956:	b0 e0       	ldi	r27, 0x00	; 0
    1958:	2a 01       	movw	r4, r20
    195a:	3b 01       	movw	r6, r22
    195c:	48 2a       	or	r4, r24
    195e:	59 2a       	or	r5, r25
    1960:	6a 2a       	or	r6, r26
    1962:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    1964:	f7 01       	movw	r30, r14
    1966:	46 8e       	std	Z+30, r4	; 0x1e
    1968:	57 8e       	std	Z+31, r5	; 0x1f
    196a:	60 a2       	lds	r22, 0x90
    196c:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    196e:	ee 5b       	subi	r30, 0xBE	; 190
    1970:	ff 4f       	sbci	r31, 0xFF	; 255
    1972:	c0 80       	ld	r12, Z
    1974:	d7 01       	movw	r26, r14
    1976:	13 96       	adiw	r26, 0x03	; 3
    1978:	cc 92       	st	X, r12
    197a:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    197c:	8c 2d       	mov	r24, r12
    197e:	81 50       	subi	r24, 0x01	; 1
    1980:	82 30       	cpi	r24, 0x02	; 2
    1982:	08 f0       	brcs	.+2      	; 0x1986 <chk_mounted+0x23e>
    1984:	dc c2       	rjmp	.+1464   	; 0x1f3e <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1986:	df 96       	adiw	r26, 0x3f	; 63
    1988:	dc 90       	ld	r13, X
    198a:	df 97       	sbiw	r26, 0x3f	; 63
    198c:	12 96       	adiw	r26, 0x02	; 2
    198e:	dc 92       	st	X, r13
    1990:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1992:	dd 20       	and	r13, r13
    1994:	09 f4       	brne	.+2      	; 0x1998 <chk_mounted+0x250>
    1996:	d5 c2       	rjmp	.+1450   	; 0x1f42 <chk_mounted+0x7fa>
    1998:	8d 2d       	mov	r24, r13
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	9c 01       	movw	r18, r24
    199e:	21 50       	subi	r18, 0x01	; 1
    19a0:	30 40       	sbci	r19, 0x00	; 0
    19a2:	82 23       	and	r24, r18
    19a4:	93 23       	and	r25, r19
    19a6:	00 97       	sbiw	r24, 0x00	; 0
    19a8:	09 f0       	breq	.+2      	; 0x19ac <chk_mounted+0x264>
    19aa:	cd c2       	rjmp	.+1434   	; 0x1f46 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    19ac:	f7 01       	movw	r30, r14
    19ae:	ec 5b       	subi	r30, 0xBC	; 188
    19b0:	ff 4f       	sbci	r31, 0xFF	; 255
    19b2:	30 81       	ld	r19, Z
    19b4:	20 e0       	ldi	r18, 0x00	; 0
    19b6:	f7 01       	movw	r30, r14
    19b8:	ed 5b       	subi	r30, 0xBD	; 189
    19ba:	ff 4f       	sbci	r31, 0xFF	; 255
    19bc:	80 81       	ld	r24, Z
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	19 01       	movw	r2, r18
    19c2:	28 2a       	or	r2, r24
    19c4:	39 2a       	or	r3, r25
    19c6:	f7 01       	movw	r30, r14
    19c8:	31 86       	std	Z+9, r3	; 0x09
    19ca:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    19cc:	c1 01       	movw	r24, r2
    19ce:	8f 70       	andi	r24, 0x0F	; 15
    19d0:	90 70       	andi	r25, 0x00	; 0
    19d2:	00 97       	sbiw	r24, 0x00	; 0
    19d4:	09 f0       	breq	.+2      	; 0x19d8 <chk_mounted+0x290>
    19d6:	b9 c2       	rjmp	.+1394   	; 0x1f4a <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    19d8:	ea 5b       	subi	r30, 0xBA	; 186
    19da:	ff 4f       	sbci	r31, 0xFF	; 255
    19dc:	30 81       	ld	r19, Z
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	f7 01       	movw	r30, r14
    19e2:	eb 5b       	subi	r30, 0xBB	; 187
    19e4:	ff 4f       	sbci	r31, 0xFF	; 255
    19e6:	80 81       	ld	r24, Z
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	82 2b       	or	r24, r18
    19ec:	93 2b       	or	r25, r19
    19ee:	8c 01       	movw	r16, r24
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	09 83       	std	Y+1, r16	; 0x01
    19f6:	1a 83       	std	Y+2, r17	; 0x02
    19f8:	2b 83       	std	Y+3, r18	; 0x03
    19fa:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    19fc:	01 15       	cp	r16, r1
    19fe:	11 05       	cpc	r17, r1
    1a00:	21 05       	cpc	r18, r1
    1a02:	31 05       	cpc	r19, r1
    1a04:	a9 f5       	brne	.+106    	; 0x1a70 <chk_mounted+0x328>
    1a06:	f7 01       	movw	r30, r14
    1a08:	eb 5a       	subi	r30, 0xAB	; 171
    1a0a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a0c:	80 81       	ld	r24, Z
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	a0 e0       	ldi	r26, 0x00	; 0
    1a12:	b0 e0       	ldi	r27, 0x00	; 0
    1a14:	78 2f       	mov	r23, r24
    1a16:	66 27       	eor	r22, r22
    1a18:	55 27       	eor	r21, r21
    1a1a:	44 27       	eor	r20, r20
    1a1c:	f7 01       	movw	r30, r14
    1a1e:	ec 5a       	subi	r30, 0xAC	; 172
    1a20:	ff 4f       	sbci	r31, 0xFF	; 255
    1a22:	80 81       	ld	r24, Z
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	a0 e0       	ldi	r26, 0x00	; 0
    1a28:	b0 e0       	ldi	r27, 0x00	; 0
    1a2a:	dc 01       	movw	r26, r24
    1a2c:	99 27       	eor	r25, r25
    1a2e:	88 27       	eor	r24, r24
    1a30:	48 2b       	or	r20, r24
    1a32:	59 2b       	or	r21, r25
    1a34:	6a 2b       	or	r22, r26
    1a36:	7b 2b       	or	r23, r27
    1a38:	f7 01       	movw	r30, r14
    1a3a:	ee 5a       	subi	r30, 0xAE	; 174
    1a3c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a3e:	80 81       	ld	r24, Z
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	a0 e0       	ldi	r26, 0x00	; 0
    1a44:	b0 e0       	ldi	r27, 0x00	; 0
    1a46:	48 2b       	or	r20, r24
    1a48:	59 2b       	or	r21, r25
    1a4a:	6a 2b       	or	r22, r26
    1a4c:	7b 2b       	or	r23, r27
    1a4e:	f7 01       	movw	r30, r14
    1a50:	ed 5a       	subi	r30, 0xAD	; 173
    1a52:	ff 4f       	sbci	r31, 0xFF	; 255
    1a54:	90 81       	ld	r25, Z
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	a0 e0       	ldi	r26, 0x00	; 0
    1a5a:	b0 e0       	ldi	r27, 0x00	; 0
    1a5c:	8a 01       	movw	r16, r20
    1a5e:	9b 01       	movw	r18, r22
    1a60:	08 2b       	or	r16, r24
    1a62:	19 2b       	or	r17, r25
    1a64:	2a 2b       	or	r18, r26
    1a66:	3b 2b       	or	r19, r27
    1a68:	09 83       	std	Y+1, r16	; 0x01
    1a6a:	1a 83       	std	Y+2, r17	; 0x02
    1a6c:	2b 83       	std	Y+3, r18	; 0x03
    1a6e:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    1a70:	f7 01       	movw	r30, r14
    1a72:	ef 5b       	subi	r30, 0xBF	; 191
    1a74:	ff 4f       	sbci	r31, 0xFF	; 255
    1a76:	30 81       	ld	r19, Z
    1a78:	20 e0       	ldi	r18, 0x00	; 0
    1a7a:	f7 01       	movw	r30, r14
    1a7c:	e0 5c       	subi	r30, 0xC0	; 192
    1a7e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a80:	80 81       	ld	r24, Z
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	89 01       	movw	r16, r18
    1a86:	08 2b       	or	r16, r24
    1a88:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1a8a:	01 15       	cp	r16, r1
    1a8c:	11 05       	cpc	r17, r1
    1a8e:	09 f4       	brne	.+2      	; 0x1a92 <chk_mounted+0x34a>
    1a90:	5e c2       	rjmp	.+1212   	; 0x1f4e <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    1a92:	2c 2d       	mov	r18, r12
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	40 e0       	ldi	r20, 0x00	; 0
    1a98:	50 e0       	ldi	r21, 0x00	; 0
    1a9a:	c3 01       	movw	r24, r6
    1a9c:	b2 01       	movw	r22, r4
    1a9e:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    1aa2:	6d 87       	std	Y+13, r22	; 0x0d
    1aa4:	7e 87       	std	Y+14, r23	; 0x0e
    1aa6:	8f 87       	std	Y+15, r24	; 0x0f
    1aa8:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1aaa:	98 01       	movw	r18, r16
    1aac:	40 e0       	ldi	r20, 0x00	; 0
    1aae:	50 e0       	ldi	r21, 0x00	; 0
    1ab0:	29 87       	std	Y+9, r18	; 0x09
    1ab2:	3a 87       	std	Y+10, r19	; 0x0a
    1ab4:	4b 87       	std	Y+11, r20	; 0x0b
    1ab6:	5c 87       	std	Y+12, r21	; 0x0c
    1ab8:	c1 01       	movw	r24, r2
    1aba:	92 95       	swap	r25
    1abc:	82 95       	swap	r24
    1abe:	8f 70       	andi	r24, 0x0F	; 15
    1ac0:	89 27       	eor	r24, r25
    1ac2:	9f 70       	andi	r25, 0x0F	; 15
    1ac4:	89 27       	eor	r24, r25
    1ac6:	a0 e0       	ldi	r26, 0x00	; 0
    1ac8:	b0 e0       	ldi	r27, 0x00	; 0
    1aca:	82 0f       	add	r24, r18
    1acc:	93 1f       	adc	r25, r19
    1ace:	a4 1f       	adc	r26, r20
    1ad0:	b5 1f       	adc	r27, r21
    1ad2:	0d 85       	ldd	r16, Y+13	; 0x0d
    1ad4:	1e 85       	ldd	r17, Y+14	; 0x0e
    1ad6:	2f 85       	ldd	r18, Y+15	; 0x0f
    1ad8:	38 89       	ldd	r19, Y+16	; 0x10
    1ada:	08 0f       	add	r16, r24
    1adc:	19 1f       	adc	r17, r25
    1ade:	2a 1f       	adc	r18, r26
    1ae0:	3b 1f       	adc	r19, r27
    1ae2:	0d 83       	std	Y+5, r16	; 0x05
    1ae4:	1e 83       	std	Y+6, r17	; 0x06
    1ae6:	2f 83       	std	Y+7, r18	; 0x07
    1ae8:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	ab 81       	ldd	r26, Y+3	; 0x03
    1af0:	bc 81       	ldd	r27, Y+4	; 0x04
    1af2:	80 17       	cp	r24, r16
    1af4:	91 07       	cpc	r25, r17
    1af6:	a2 07       	cpc	r26, r18
    1af8:	b3 07       	cpc	r27, r19
    1afa:	08 f4       	brcc	.+2      	; 0x1afe <chk_mounted+0x3b6>
    1afc:	2a c2       	rjmp	.+1108   	; 0x1f52 <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1afe:	bc 01       	movw	r22, r24
    1b00:	cd 01       	movw	r24, r26
    1b02:	60 1b       	sub	r22, r16
    1b04:	71 0b       	sbc	r23, r17
    1b06:	82 0b       	sbc	r24, r18
    1b08:	93 0b       	sbc	r25, r19
    1b0a:	2d 2d       	mov	r18, r13
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	40 e0       	ldi	r20, 0x00	; 0
    1b10:	50 e0       	ldi	r21, 0x00	; 0
    1b12:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>
    1b16:	89 01       	movw	r16, r18
    1b18:	9a 01       	movw	r18, r20
    1b1a:	d9 01       	movw	r26, r18
    1b1c:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1b1e:	01 15       	cp	r16, r1
    1b20:	11 05       	cpc	r17, r1
    1b22:	21 05       	cpc	r18, r1
    1b24:	31 05       	cpc	r19, r1
    1b26:	09 f4       	brne	.+2      	; 0x1b2a <chk_mounted+0x3e2>
    1b28:	16 c2       	rjmp	.+1068   	; 0x1f56 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1b2a:	06 3f       	cpi	r16, 0xF6	; 246
    1b2c:	ef e0       	ldi	r30, 0x0F	; 15
    1b2e:	1e 07       	cpc	r17, r30
    1b30:	e0 e0       	ldi	r30, 0x00	; 0
    1b32:	2e 07       	cpc	r18, r30
    1b34:	e0 e0       	ldi	r30, 0x00	; 0
    1b36:	3e 07       	cpc	r19, r30
    1b38:	18 f4       	brcc	.+6      	; 0x1b40 <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1b3a:	dd 24       	eor	r13, r13
    1b3c:	d3 94       	inc	r13
    1b3e:	03 c0       	rjmp	.+6      	; 0x1b46 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1b40:	dd 24       	eor	r13, r13
    1b42:	68 94       	set
    1b44:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1b46:	86 3f       	cpi	r24, 0xF6	; 246
    1b48:	ff ef       	ldi	r31, 0xFF	; 255
    1b4a:	9f 07       	cpc	r25, r31
    1b4c:	f0 e0       	ldi	r31, 0x00	; 0
    1b4e:	af 07       	cpc	r26, r31
    1b50:	f0 e0       	ldi	r31, 0x00	; 0
    1b52:	bf 07       	cpc	r27, r31
    1b54:	08 f0       	brcs	.+2      	; 0x1b58 <chk_mounted+0x410>
    1b56:	1f c2       	rjmp	.+1086   	; 0x1f96 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1b58:	b9 01       	movw	r22, r18
    1b5a:	a8 01       	movw	r20, r16
    1b5c:	4e 5f       	subi	r20, 0xFE	; 254
    1b5e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b60:	6f 4f       	sbci	r22, 0xFF	; 255
    1b62:	7f 4f       	sbci	r23, 0xFF	; 255
    1b64:	d7 01       	movw	r26, r14
    1b66:	5a 96       	adiw	r26, 0x1a	; 26
    1b68:	4d 93       	st	X+, r20
    1b6a:	5d 93       	st	X+, r21
    1b6c:	6d 93       	st	X+, r22
    1b6e:	7c 93       	st	X, r23
    1b70:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    1b72:	8d 81       	ldd	r24, Y+5	; 0x05
    1b74:	9e 81       	ldd	r25, Y+6	; 0x06
    1b76:	af 81       	ldd	r26, Y+7	; 0x07
    1b78:	b8 85       	ldd	r27, Y+8	; 0x08
    1b7a:	88 0d       	add	r24, r8
    1b7c:	99 1d       	adc	r25, r9
    1b7e:	aa 1d       	adc	r26, r10
    1b80:	bb 1d       	adc	r27, r11
    1b82:	f7 01       	movw	r30, r14
    1b84:	82 a7       	lds	r24, 0x72
    1b86:	93 a7       	lds	r25, 0x73
    1b88:	a4 a7       	lds	r26, 0x74
    1b8a:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1b8c:	89 85       	ldd	r24, Y+9	; 0x09
    1b8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b90:	ab 85       	ldd	r26, Y+11	; 0x0b
    1b92:	bc 85       	ldd	r27, Y+12	; 0x0c
    1b94:	88 0d       	add	r24, r8
    1b96:	99 1d       	adc	r25, r9
    1b98:	aa 1d       	adc	r26, r10
    1b9a:	bb 1d       	adc	r27, r11
    1b9c:	82 a3       	lds	r24, 0x52
    1b9e:	93 a3       	lds	r25, 0x53
    1ba0:	a4 a3       	lds	r26, 0x54
    1ba2:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    1ba4:	f3 e0       	ldi	r31, 0x03	; 3
    1ba6:	df 16       	cp	r13, r31
    1ba8:	09 f0       	breq	.+2      	; 0x1bac <chk_mounted+0x464>
    1baa:	41 c0       	rjmp	.+130    	; 0x1c2e <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1bac:	21 14       	cp	r2, r1
    1bae:	31 04       	cpc	r3, r1
    1bb0:	09 f0       	breq	.+2      	; 0x1bb4 <chk_mounted+0x46c>
    1bb2:	d3 c1       	rjmp	.+934    	; 0x1f5a <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    1bb4:	f7 01       	movw	r30, r14
    1bb6:	ef 59       	subi	r30, 0x9F	; 159
    1bb8:	ff 4f       	sbci	r31, 0xFF	; 255
    1bba:	80 81       	ld	r24, Z
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	a0 e0       	ldi	r26, 0x00	; 0
    1bc0:	b0 e0       	ldi	r27, 0x00	; 0
    1bc2:	38 2f       	mov	r19, r24
    1bc4:	22 27       	eor	r18, r18
    1bc6:	11 27       	eor	r17, r17
    1bc8:	00 27       	eor	r16, r16
    1bca:	f7 01       	movw	r30, r14
    1bcc:	e0 5a       	subi	r30, 0xA0	; 160
    1bce:	ff 4f       	sbci	r31, 0xFF	; 255
    1bd0:	80 81       	ld	r24, Z
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	a0 e0       	ldi	r26, 0x00	; 0
    1bd6:	b0 e0       	ldi	r27, 0x00	; 0
    1bd8:	dc 01       	movw	r26, r24
    1bda:	99 27       	eor	r25, r25
    1bdc:	88 27       	eor	r24, r24
    1bde:	08 2b       	or	r16, r24
    1be0:	19 2b       	or	r17, r25
    1be2:	2a 2b       	or	r18, r26
    1be4:	3b 2b       	or	r19, r27
    1be6:	f7 01       	movw	r30, r14
    1be8:	e2 5a       	subi	r30, 0xA2	; 162
    1bea:	ff 4f       	sbci	r31, 0xFF	; 255
    1bec:	80 81       	ld	r24, Z
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	a0 e0       	ldi	r26, 0x00	; 0
    1bf2:	b0 e0       	ldi	r27, 0x00	; 0
    1bf4:	08 2b       	or	r16, r24
    1bf6:	19 2b       	or	r17, r25
    1bf8:	2a 2b       	or	r18, r26
    1bfa:	3b 2b       	or	r19, r27
    1bfc:	f7 01       	movw	r30, r14
    1bfe:	e1 5a       	subi	r30, 0xA1	; 161
    1c00:	ff 4f       	sbci	r31, 0xFF	; 255
    1c02:	90 81       	ld	r25, Z
    1c04:	80 e0       	ldi	r24, 0x00	; 0
    1c06:	a0 e0       	ldi	r26, 0x00	; 0
    1c08:	b0 e0       	ldi	r27, 0x00	; 0
    1c0a:	80 2b       	or	r24, r16
    1c0c:	91 2b       	or	r25, r17
    1c0e:	a2 2b       	or	r26, r18
    1c10:	b3 2b       	or	r27, r19
    1c12:	f7 01       	movw	r30, r14
    1c14:	86 a3       	lds	r24, 0x56
    1c16:	97 a3       	lds	r25, 0x57
    1c18:	a0 a7       	lds	r26, 0x70
    1c1a:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1c1c:	44 0f       	add	r20, r20
    1c1e:	55 1f       	adc	r21, r21
    1c20:	66 1f       	adc	r22, r22
    1c22:	77 1f       	adc	r23, r23
    1c24:	44 0f       	add	r20, r20
    1c26:	55 1f       	adc	r21, r21
    1c28:	66 1f       	adc	r22, r22
    1c2a:	77 1f       	adc	r23, r23
    1c2c:	2f c0       	rjmp	.+94     	; 0x1c8c <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1c2e:	21 14       	cp	r2, r1
    1c30:	31 04       	cpc	r3, r1
    1c32:	09 f4       	brne	.+2      	; 0x1c36 <chk_mounted+0x4ee>
    1c34:	94 c1       	rjmp	.+808    	; 0x1f5e <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1c36:	0d 85       	ldd	r16, Y+13	; 0x0d
    1c38:	1e 85       	ldd	r17, Y+14	; 0x0e
    1c3a:	2f 85       	ldd	r18, Y+15	; 0x0f
    1c3c:	38 89       	ldd	r19, Y+16	; 0x10
    1c3e:	80 0f       	add	r24, r16
    1c40:	91 1f       	adc	r25, r17
    1c42:	a2 1f       	adc	r26, r18
    1c44:	b3 1f       	adc	r27, r19
    1c46:	f7 01       	movw	r30, r14
    1c48:	86 a3       	lds	r24, 0x56
    1c4a:	97 a3       	lds	r25, 0x57
    1c4c:	a0 a7       	lds	r26, 0x70
    1c4e:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    1c50:	f2 e0       	ldi	r31, 0x02	; 2
    1c52:	df 16       	cp	r13, r31
    1c54:	29 f4       	brne	.+10     	; 0x1c60 <chk_mounted+0x518>
    1c56:	44 0f       	add	r20, r20
    1c58:	55 1f       	adc	r21, r21
    1c5a:	66 1f       	adc	r22, r22
    1c5c:	77 1f       	adc	r23, r23
    1c5e:	16 c0       	rjmp	.+44     	; 0x1c8c <chk_mounted+0x544>
    1c60:	db 01       	movw	r26, r22
    1c62:	ca 01       	movw	r24, r20
    1c64:	88 0f       	add	r24, r24
    1c66:	99 1f       	adc	r25, r25
    1c68:	aa 1f       	adc	r26, r26
    1c6a:	bb 1f       	adc	r27, r27
    1c6c:	84 0f       	add	r24, r20
    1c6e:	95 1f       	adc	r25, r21
    1c70:	a6 1f       	adc	r26, r22
    1c72:	b7 1f       	adc	r27, r23
    1c74:	b6 95       	lsr	r27
    1c76:	a7 95       	ror	r26
    1c78:	97 95       	ror	r25
    1c7a:	87 95       	ror	r24
    1c7c:	41 70       	andi	r20, 0x01	; 1
    1c7e:	50 70       	andi	r21, 0x00	; 0
    1c80:	60 70       	andi	r22, 0x00	; 0
    1c82:	70 70       	andi	r23, 0x00	; 0
    1c84:	48 0f       	add	r20, r24
    1c86:	59 1f       	adc	r21, r25
    1c88:	6a 1f       	adc	r22, r26
    1c8a:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1c8c:	db 01       	movw	r26, r22
    1c8e:	ca 01       	movw	r24, r20
    1c90:	81 50       	subi	r24, 0x01	; 1
    1c92:	9e 4f       	sbci	r25, 0xFE	; 254
    1c94:	af 4f       	sbci	r26, 0xFF	; 255
    1c96:	bf 4f       	sbci	r27, 0xFF	; 255
    1c98:	07 2e       	mov	r0, r23
    1c9a:	79 e0       	ldi	r23, 0x09	; 9
    1c9c:	b6 95       	lsr	r27
    1c9e:	a7 95       	ror	r26
    1ca0:	97 95       	ror	r25
    1ca2:	87 95       	ror	r24
    1ca4:	7a 95       	dec	r23
    1ca6:	d1 f7       	brne	.-12     	; 0x1c9c <chk_mounted+0x554>
    1ca8:	70 2d       	mov	r23, r0
    1caa:	48 16       	cp	r4, r24
    1cac:	59 06       	cpc	r5, r25
    1cae:	6a 06       	cpc	r6, r26
    1cb0:	7b 06       	cpc	r7, r27
    1cb2:	08 f4       	brcc	.+2      	; 0x1cb6 <chk_mounted+0x56e>
    1cb4:	56 c1       	rjmp	.+684    	; 0x1f62 <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1cb6:	8f ef       	ldi	r24, 0xFF	; 255
    1cb8:	9f ef       	ldi	r25, 0xFF	; 255
    1cba:	dc 01       	movw	r26, r24
    1cbc:	f7 01       	movw	r30, r14
    1cbe:	86 87       	std	Z+14, r24	; 0x0e
    1cc0:	97 87       	std	Z+15, r25	; 0x0f
    1cc2:	a0 8b       	std	Z+16, r26	; 0x10
    1cc4:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1cc6:	12 86       	std	Z+10, r1	; 0x0a
    1cc8:	13 86       	std	Z+11, r1	; 0x0b
    1cca:	14 86       	std	Z+12, r1	; 0x0c
    1ccc:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1cce:	b3 e0       	ldi	r27, 0x03	; 3
    1cd0:	db 16       	cp	r13, r27
    1cd2:	09 f0       	breq	.+2      	; 0x1cd6 <chk_mounted+0x58e>
    1cd4:	03 c1       	rjmp	.+518    	; 0x1edc <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1cd6:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1cd8:	ed 59       	subi	r30, 0x9D	; 157
    1cda:	ff 4f       	sbci	r31, 0xFF	; 255
    1cdc:	30 81       	ld	r19, Z
    1cde:	20 e0       	ldi	r18, 0x00	; 0
    1ce0:	f7 01       	movw	r30, r14
    1ce2:	ee 59       	subi	r30, 0x9E	; 158
    1ce4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ce6:	80 81       	ld	r24, Z
    1ce8:	90 e0       	ldi	r25, 0x00	; 0
    1cea:	82 2b       	or	r24, r18
    1cec:	93 2b       	or	r25, r19
    1cee:	a0 e0       	ldi	r26, 0x00	; 0
    1cf0:	b0 e0       	ldi	r27, 0x00	; 0
    1cf2:	a5 01       	movw	r20, r10
    1cf4:	94 01       	movw	r18, r8
    1cf6:	28 0f       	add	r18, r24
    1cf8:	39 1f       	adc	r19, r25
    1cfa:	4a 1f       	adc	r20, r26
    1cfc:	5b 1f       	adc	r21, r27
    1cfe:	d7 01       	movw	r26, r14
    1d00:	52 96       	adiw	r26, 0x12	; 18
    1d02:	2d 93       	st	X+, r18
    1d04:	3d 93       	st	X+, r19
    1d06:	4d 93       	st	X+, r20
    1d08:	5c 93       	st	X, r21
    1d0a:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d0c:	b7 01       	movw	r22, r14
    1d0e:	6e 5c       	subi	r22, 0xCE	; 206
    1d10:	7f 4f       	sbci	r23, 0xFF	; 255
    1d12:	11 96       	adiw	r26, 0x01	; 1
    1d14:	8c 91       	ld	r24, X
    1d16:	01 e0       	ldi	r16, 0x01	; 1
    1d18:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    1d1c:	88 23       	and	r24, r24
    1d1e:	09 f0       	breq	.+2      	; 0x1d22 <chk_mounted+0x5da>
    1d20:	dd c0       	rjmp	.+442    	; 0x1edc <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1d22:	f7 01       	movw	r30, r14
    1d24:	ef 5c       	subi	r30, 0xCF	; 207
    1d26:	fd 4f       	sbci	r31, 0xFD	; 253
    1d28:	30 81       	ld	r19, Z
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
    1d2c:	f7 01       	movw	r30, r14
    1d2e:	e0 5d       	subi	r30, 0xD0	; 208
    1d30:	fd 4f       	sbci	r31, 0xFD	; 253
    1d32:	80 81       	ld	r24, Z
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	82 2b       	or	r24, r18
    1d38:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d3a:	ba ea       	ldi	r27, 0xAA	; 170
    1d3c:	85 35       	cpi	r24, 0x55	; 85
    1d3e:	9b 07       	cpc	r25, r27
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <chk_mounted+0x5fc>
    1d42:	cc c0       	rjmp	.+408    	; 0x1edc <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1d44:	f7 01       	movw	r30, r14
    1d46:	45 a9       	sts	0x45, r20
    1d48:	50 e0       	ldi	r21, 0x00	; 0
    1d4a:	60 e0       	ldi	r22, 0x00	; 0
    1d4c:	70 e0       	ldi	r23, 0x00	; 0
    1d4e:	74 2f       	mov	r23, r20
    1d50:	66 27       	eor	r22, r22
    1d52:	55 27       	eor	r21, r21
    1d54:	44 27       	eor	r20, r20
    1d56:	84 a9       	sts	0x44, r24
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	a0 e0       	ldi	r26, 0x00	; 0
    1d5c:	b0 e0       	ldi	r27, 0x00	; 0
    1d5e:	dc 01       	movw	r26, r24
    1d60:	99 27       	eor	r25, r25
    1d62:	88 27       	eor	r24, r24
    1d64:	48 2b       	or	r20, r24
    1d66:	59 2b       	or	r21, r25
    1d68:	6a 2b       	or	r22, r26
    1d6a:	7b 2b       	or	r23, r27
    1d6c:	82 a9       	sts	0x42, r24
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	a0 e0       	ldi	r26, 0x00	; 0
    1d72:	b0 e0       	ldi	r27, 0x00	; 0
    1d74:	48 2b       	or	r20, r24
    1d76:	59 2b       	or	r21, r25
    1d78:	6a 2b       	or	r22, r26
    1d7a:	7b 2b       	or	r23, r27
    1d7c:	93 a9       	sts	0x43, r25
    1d7e:	80 e0       	ldi	r24, 0x00	; 0
    1d80:	a0 e0       	ldi	r26, 0x00	; 0
    1d82:	b0 e0       	ldi	r27, 0x00	; 0
    1d84:	84 2b       	or	r24, r20
    1d86:	95 2b       	or	r25, r21
    1d88:	a6 2b       	or	r26, r22
    1d8a:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1d8c:	82 35       	cpi	r24, 0x52	; 82
    1d8e:	f2 e5       	ldi	r31, 0x52	; 82
    1d90:	9f 07       	cpc	r25, r31
    1d92:	f1 e6       	ldi	r31, 0x61	; 97
    1d94:	af 07       	cpc	r26, r31
    1d96:	f1 e4       	ldi	r31, 0x41	; 65
    1d98:	bf 07       	cpc	r27, r31
    1d9a:	09 f0       	breq	.+2      	; 0x1d9e <chk_mounted+0x656>
    1d9c:	9f c0       	rjmp	.+318    	; 0x1edc <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1d9e:	f7 01       	movw	r30, r14
    1da0:	e7 5e       	subi	r30, 0xE7	; 231
    1da2:	fd 4f       	sbci	r31, 0xFD	; 253
    1da4:	80 81       	ld	r24, Z
    1da6:	90 e0       	ldi	r25, 0x00	; 0
    1da8:	a0 e0       	ldi	r26, 0x00	; 0
    1daa:	b0 e0       	ldi	r27, 0x00	; 0
    1dac:	b8 2f       	mov	r27, r24
    1dae:	aa 27       	eor	r26, r26
    1db0:	99 27       	eor	r25, r25
    1db2:	88 27       	eor	r24, r24
    1db4:	f7 01       	movw	r30, r14
    1db6:	e8 5e       	subi	r30, 0xE8	; 232
    1db8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dba:	40 81       	ld	r20, Z
    1dbc:	50 e0       	ldi	r21, 0x00	; 0
    1dbe:	60 e0       	ldi	r22, 0x00	; 0
    1dc0:	70 e0       	ldi	r23, 0x00	; 0
    1dc2:	ba 01       	movw	r22, r20
    1dc4:	55 27       	eor	r21, r21
    1dc6:	44 27       	eor	r20, r20
    1dc8:	84 2b       	or	r24, r20
    1dca:	95 2b       	or	r25, r21
    1dcc:	a6 2b       	or	r26, r22
    1dce:	b7 2b       	or	r27, r23
    1dd0:	f7 01       	movw	r30, r14
    1dd2:	ea 5e       	subi	r30, 0xEA	; 234
    1dd4:	fd 4f       	sbci	r31, 0xFD	; 253
    1dd6:	40 81       	ld	r20, Z
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	60 e0       	ldi	r22, 0x00	; 0
    1ddc:	70 e0       	ldi	r23, 0x00	; 0
    1dde:	48 2b       	or	r20, r24
    1de0:	59 2b       	or	r21, r25
    1de2:	6a 2b       	or	r22, r26
    1de4:	7b 2b       	or	r23, r27
    1de6:	f7 01       	movw	r30, r14
    1de8:	e9 5e       	subi	r30, 0xE9	; 233
    1dea:	fd 4f       	sbci	r31, 0xFD	; 253
    1dec:	90 81       	ld	r25, Z
    1dee:	80 e0       	ldi	r24, 0x00	; 0
    1df0:	a0 e0       	ldi	r26, 0x00	; 0
    1df2:	b0 e0       	ldi	r27, 0x00	; 0
    1df4:	84 2b       	or	r24, r20
    1df6:	95 2b       	or	r25, r21
    1df8:	a6 2b       	or	r26, r22
    1dfa:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1dfc:	82 37       	cpi	r24, 0x72	; 114
    1dfe:	02 e7       	ldi	r16, 0x72	; 114
    1e00:	90 07       	cpc	r25, r16
    1e02:	01 e4       	ldi	r16, 0x41	; 65
    1e04:	a0 07       	cpc	r26, r16
    1e06:	01 e6       	ldi	r16, 0x61	; 97
    1e08:	b0 07       	cpc	r27, r16
    1e0a:	09 f0       	breq	.+2      	; 0x1e0e <chk_mounted+0x6c6>
    1e0c:	67 c0       	rjmp	.+206    	; 0x1edc <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1e0e:	f7 01       	movw	r30, r14
    1e10:	ef 5d       	subi	r30, 0xDF	; 223
    1e12:	fd 4f       	sbci	r31, 0xFD	; 253
    1e14:	80 81       	ld	r24, Z
    1e16:	90 e0       	ldi	r25, 0x00	; 0
    1e18:	a0 e0       	ldi	r26, 0x00	; 0
    1e1a:	b0 e0       	ldi	r27, 0x00	; 0
    1e1c:	b8 2f       	mov	r27, r24
    1e1e:	aa 27       	eor	r26, r26
    1e20:	99 27       	eor	r25, r25
    1e22:	88 27       	eor	r24, r24
    1e24:	f7 01       	movw	r30, r14
    1e26:	e0 5e       	subi	r30, 0xE0	; 224
    1e28:	fd 4f       	sbci	r31, 0xFD	; 253
    1e2a:	40 81       	ld	r20, Z
    1e2c:	50 e0       	ldi	r21, 0x00	; 0
    1e2e:	60 e0       	ldi	r22, 0x00	; 0
    1e30:	70 e0       	ldi	r23, 0x00	; 0
    1e32:	ba 01       	movw	r22, r20
    1e34:	55 27       	eor	r21, r21
    1e36:	44 27       	eor	r20, r20
    1e38:	84 2b       	or	r24, r20
    1e3a:	95 2b       	or	r25, r21
    1e3c:	a6 2b       	or	r26, r22
    1e3e:	b7 2b       	or	r27, r23
    1e40:	f7 01       	movw	r30, r14
    1e42:	e2 5e       	subi	r30, 0xE2	; 226
    1e44:	fd 4f       	sbci	r31, 0xFD	; 253
    1e46:	40 81       	ld	r20, Z
    1e48:	50 e0       	ldi	r21, 0x00	; 0
    1e4a:	60 e0       	ldi	r22, 0x00	; 0
    1e4c:	70 e0       	ldi	r23, 0x00	; 0
    1e4e:	48 2b       	or	r20, r24
    1e50:	59 2b       	or	r21, r25
    1e52:	6a 2b       	or	r22, r26
    1e54:	7b 2b       	or	r23, r27
    1e56:	f7 01       	movw	r30, r14
    1e58:	e1 5e       	subi	r30, 0xE1	; 225
    1e5a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e5c:	90 81       	ld	r25, Z
    1e5e:	80 e0       	ldi	r24, 0x00	; 0
    1e60:	a0 e0       	ldi	r26, 0x00	; 0
    1e62:	b0 e0       	ldi	r27, 0x00	; 0
    1e64:	84 2b       	or	r24, r20
    1e66:	95 2b       	or	r25, r21
    1e68:	a6 2b       	or	r26, r22
    1e6a:	b7 2b       	or	r27, r23
    1e6c:	f7 01       	movw	r30, r14
    1e6e:	82 87       	std	Z+10, r24	; 0x0a
    1e70:	93 87       	std	Z+11, r25	; 0x0b
    1e72:	a4 87       	std	Z+12, r26	; 0x0c
    1e74:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1e76:	e3 5e       	subi	r30, 0xE3	; 227
    1e78:	fd 4f       	sbci	r31, 0xFD	; 253
    1e7a:	80 81       	ld	r24, Z
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	a0 e0       	ldi	r26, 0x00	; 0
    1e80:	b0 e0       	ldi	r27, 0x00	; 0
    1e82:	b8 2f       	mov	r27, r24
    1e84:	aa 27       	eor	r26, r26
    1e86:	99 27       	eor	r25, r25
    1e88:	88 27       	eor	r24, r24
    1e8a:	f7 01       	movw	r30, r14
    1e8c:	e4 5e       	subi	r30, 0xE4	; 228
    1e8e:	fd 4f       	sbci	r31, 0xFD	; 253
    1e90:	40 81       	ld	r20, Z
    1e92:	50 e0       	ldi	r21, 0x00	; 0
    1e94:	60 e0       	ldi	r22, 0x00	; 0
    1e96:	70 e0       	ldi	r23, 0x00	; 0
    1e98:	ba 01       	movw	r22, r20
    1e9a:	55 27       	eor	r21, r21
    1e9c:	44 27       	eor	r20, r20
    1e9e:	84 2b       	or	r24, r20
    1ea0:	95 2b       	or	r25, r21
    1ea2:	a6 2b       	or	r26, r22
    1ea4:	b7 2b       	or	r27, r23
    1ea6:	f7 01       	movw	r30, r14
    1ea8:	e6 5e       	subi	r30, 0xE6	; 230
    1eaa:	fd 4f       	sbci	r31, 0xFD	; 253
    1eac:	40 81       	ld	r20, Z
    1eae:	50 e0       	ldi	r21, 0x00	; 0
    1eb0:	60 e0       	ldi	r22, 0x00	; 0
    1eb2:	70 e0       	ldi	r23, 0x00	; 0
    1eb4:	48 2b       	or	r20, r24
    1eb6:	59 2b       	or	r21, r25
    1eb8:	6a 2b       	or	r22, r26
    1eba:	7b 2b       	or	r23, r27
    1ebc:	f7 01       	movw	r30, r14
    1ebe:	e5 5e       	subi	r30, 0xE5	; 229
    1ec0:	fd 4f       	sbci	r31, 0xFD	; 253
    1ec2:	90 81       	ld	r25, Z
    1ec4:	80 e0       	ldi	r24, 0x00	; 0
    1ec6:	a0 e0       	ldi	r26, 0x00	; 0
    1ec8:	b0 e0       	ldi	r27, 0x00	; 0
    1eca:	84 2b       	or	r24, r20
    1ecc:	95 2b       	or	r25, r21
    1ece:	a6 2b       	or	r26, r22
    1ed0:	b7 2b       	or	r27, r23
    1ed2:	f7 01       	movw	r30, r14
    1ed4:	86 87       	std	Z+14, r24	; 0x0e
    1ed6:	97 87       	std	Z+15, r25	; 0x0f
    1ed8:	a0 8b       	std	Z+16, r26	; 0x10
    1eda:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1edc:	d7 01       	movw	r26, r14
    1ede:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    1ee0:	80 91 82 02 	lds	r24, 0x0282
    1ee4:	90 91 83 02 	lds	r25, 0x0283
    1ee8:	01 96       	adiw	r24, 0x01	; 1
    1eea:	90 93 83 02 	sts	0x0283, r25
    1eee:	80 93 82 02 	sts	0x0282, r24
    1ef2:	17 96       	adiw	r26, 0x07	; 7
    1ef4:	9c 93       	st	X, r25
    1ef6:	8e 93       	st	-X, r24
    1ef8:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    1efa:	f7 01       	movw	r30, r14
    1efc:	16 a6       	lds	r17, 0xb6
    1efe:	17 a6       	lds	r17, 0xb7
    1f00:	10 aa       	sts	0x90, r17
    1f02:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    1f04:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    1f06:	56 96       	adiw	r26, 0x16	; 22
    1f08:	1d 92       	st	X+, r1
    1f0a:	1d 92       	st	X+, r1
    1f0c:	1d 92       	st	X+, r1
    1f0e:	1c 92       	st	X, r1
    1f10:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    1f12:	80 e0       	ldi	r24, 0x00	; 0
    1f14:	27 c0       	rjmp	.+78     	; 0x1f64 <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    1f16:	8b e0       	ldi	r24, 0x0B	; 11
    1f18:	25 c0       	rjmp	.+74     	; 0x1f64 <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1f1a:	8c e0       	ldi	r24, 0x0C	; 12
    1f1c:	23 c0       	rjmp	.+70     	; 0x1f64 <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1f1e:	80 e0       	ldi	r24, 0x00	; 0
    1f20:	21 c0       	rjmp	.+66     	; 0x1f64 <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    1f22:	8a e0       	ldi	r24, 0x0A	; 10
    1f24:	1f c0       	rjmp	.+62     	; 0x1f64 <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    1f26:	83 e0       	ldi	r24, 0x03	; 3
    1f28:	1d c0       	rjmp	.+58     	; 0x1f64 <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    1f2a:	8a e0       	ldi	r24, 0x0A	; 10
    1f2c:	1b c0       	rjmp	.+54     	; 0x1f64 <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1f2e:	8d e0       	ldi	r24, 0x0D	; 13
    1f30:	19 c0       	rjmp	.+50     	; 0x1f64 <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	17 c0       	rjmp	.+46     	; 0x1f64 <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1f36:	8d e0       	ldi	r24, 0x0D	; 13
    1f38:	15 c0       	rjmp	.+42     	; 0x1f64 <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    1f3a:	8d e0       	ldi	r24, 0x0D	; 13
    1f3c:	13 c0       	rjmp	.+38     	; 0x1f64 <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1f3e:	8d e0       	ldi	r24, 0x0D	; 13
    1f40:	11 c0       	rjmp	.+34     	; 0x1f64 <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1f42:	8d e0       	ldi	r24, 0x0D	; 13
    1f44:	0f c0       	rjmp	.+30     	; 0x1f64 <chk_mounted+0x81c>
    1f46:	8d e0       	ldi	r24, 0x0D	; 13
    1f48:	0d c0       	rjmp	.+26     	; 0x1f64 <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1f4a:	8d e0       	ldi	r24, 0x0D	; 13
    1f4c:	0b c0       	rjmp	.+22     	; 0x1f64 <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1f4e:	8d e0       	ldi	r24, 0x0D	; 13
    1f50:	09 c0       	rjmp	.+18     	; 0x1f64 <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1f52:	8d e0       	ldi	r24, 0x0D	; 13
    1f54:	07 c0       	rjmp	.+14     	; 0x1f64 <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1f56:	8d e0       	ldi	r24, 0x0D	; 13
    1f58:	05 c0       	rjmp	.+10     	; 0x1f64 <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1f5a:	8d e0       	ldi	r24, 0x0D	; 13
    1f5c:	03 c0       	rjmp	.+6      	; 0x1f64 <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1f5e:	8d e0       	ldi	r24, 0x0D	; 13
    1f60:	01 c0       	rjmp	.+2      	; 0x1f64 <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    1f62:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    1f64:	60 96       	adiw	r28, 0x10	; 16
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	de bf       	out	0x3e, r29	; 62
    1f6c:	0f be       	out	0x3f, r0	; 63
    1f6e:	cd bf       	out	0x3d, r28	; 61
    1f70:	df 91       	pop	r29
    1f72:	cf 91       	pop	r28
    1f74:	1f 91       	pop	r17
    1f76:	0f 91       	pop	r16
    1f78:	ff 90       	pop	r15
    1f7a:	ef 90       	pop	r14
    1f7c:	df 90       	pop	r13
    1f7e:	cf 90       	pop	r12
    1f80:	bf 90       	pop	r11
    1f82:	af 90       	pop	r10
    1f84:	9f 90       	pop	r9
    1f86:	8f 90       	pop	r8
    1f88:	7f 90       	pop	r7
    1f8a:	6f 90       	pop	r6
    1f8c:	5f 90       	pop	r5
    1f8e:	4f 90       	pop	r4
    1f90:	3f 90       	pop	r3
    1f92:	2f 90       	pop	r2
    1f94:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1f96:	b9 01       	movw	r22, r18
    1f98:	a8 01       	movw	r20, r16
    1f9a:	4e 5f       	subi	r20, 0xFE	; 254
    1f9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1f9e:	6f 4f       	sbci	r22, 0xFF	; 255
    1fa0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fa2:	f7 01       	movw	r30, r14
    1fa4:	42 8f       	std	Z+26, r20	; 0x1a
    1fa6:	53 8f       	std	Z+27, r21	; 0x1b
    1fa8:	64 8f       	std	Z+28, r22	; 0x1c
    1faa:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    1fac:	8d 81       	ldd	r24, Y+5	; 0x05
    1fae:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb0:	af 81       	ldd	r26, Y+7	; 0x07
    1fb2:	b8 85       	ldd	r27, Y+8	; 0x08
    1fb4:	88 0d       	add	r24, r8
    1fb6:	99 1d       	adc	r25, r9
    1fb8:	aa 1d       	adc	r26, r10
    1fba:	bb 1d       	adc	r27, r11
    1fbc:	82 a7       	lds	r24, 0x72
    1fbe:	93 a7       	lds	r25, 0x73
    1fc0:	a4 a7       	lds	r26, 0x74
    1fc2:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1fc4:	89 85       	ldd	r24, Y+9	; 0x09
    1fc6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fc8:	ab 85       	ldd	r26, Y+11	; 0x0b
    1fca:	bc 85       	ldd	r27, Y+12	; 0x0c
    1fcc:	88 0d       	add	r24, r8
    1fce:	99 1d       	adc	r25, r9
    1fd0:	aa 1d       	adc	r26, r10
    1fd2:	bb 1d       	adc	r27, r11
    1fd4:	82 a3       	lds	r24, 0x52
    1fd6:	93 a3       	lds	r25, 0x53
    1fd8:	a4 a3       	lds	r26, 0x54
    1fda:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1fdc:	0f 2e       	mov	r0, r31
    1fde:	f3 e0       	ldi	r31, 0x03	; 3
    1fe0:	df 2e       	mov	r13, r31
    1fe2:	f0 2d       	mov	r31, r0
    1fe4:	e3 cd       	rjmp	.-1082   	; 0x1bac <chk_mounted+0x464>

00001fe6 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    1fe6:	4f 92       	push	r4
    1fe8:	5f 92       	push	r5
    1fea:	6f 92       	push	r6
    1fec:	7f 92       	push	r7
    1fee:	8f 92       	push	r8
    1ff0:	9f 92       	push	r9
    1ff2:	af 92       	push	r10
    1ff4:	bf 92       	push	r11
    1ff6:	cf 92       	push	r12
    1ff8:	df 92       	push	r13
    1ffa:	ef 92       	push	r14
    1ffc:	ff 92       	push	r15
    1ffe:	0f 93       	push	r16
    2000:	cf 93       	push	r28
    2002:	5c 01       	movw	r10, r24
    2004:	2a 01       	movw	r4, r20
    2006:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    2008:	fc 01       	movw	r30, r24
    200a:	c6 a4       	lds	r28, 0xa6
    200c:	d7 a4       	lds	r29, 0xa7
    200e:	e0 a8       	sts	0x00, r30
    2010:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    2012:	c4 16       	cp	r12, r20
    2014:	d5 06       	cpc	r13, r21
    2016:	e6 06       	cpc	r14, r22
    2018:	f7 06       	cpc	r15, r23
    201a:	09 f4       	brne	.+2      	; 0x201e <move_window+0x38>
    201c:	54 c0       	rjmp	.+168    	; 0x20c6 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    201e:	84 81       	ldd	r24, Z+4	; 0x04
    2020:	88 23       	and	r24, r24
    2022:	d1 f1       	breq	.+116    	; 0x2098 <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    2024:	0f 2e       	mov	r0, r31
    2026:	f2 e3       	ldi	r31, 0x32	; 50
    2028:	8f 2e       	mov	r8, r31
    202a:	99 24       	eor	r9, r9
    202c:	f0 2d       	mov	r31, r0
    202e:	8a 0c       	add	r8, r10
    2030:	9b 1c       	adc	r9, r11
    2032:	81 81       	ldd	r24, Z+1	; 0x01
    2034:	b4 01       	movw	r22, r8
    2036:	a7 01       	movw	r20, r14
    2038:	96 01       	movw	r18, r12
    203a:	01 e0       	ldi	r16, 0x01	; 1
    203c:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    2040:	88 23       	and	r24, r24
    2042:	09 f0       	breq	.+2      	; 0x2046 <move_window+0x60>
    2044:	42 c0       	rjmp	.+132    	; 0x20ca <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    2046:	f5 01       	movw	r30, r10
    2048:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    204a:	46 8d       	ldd	r20, Z+30	; 0x1e
    204c:	57 8d       	ldd	r21, Z+31	; 0x1f
    204e:	60 a1       	lds	r22, 0x40
    2050:	71 a1       	lds	r23, 0x41
    2052:	82 a1       	lds	r24, 0x42
    2054:	93 a1       	lds	r25, 0x43
    2056:	a4 a1       	lds	r26, 0x44
    2058:	b5 a1       	lds	r27, 0x45
    205a:	84 0f       	add	r24, r20
    205c:	95 1f       	adc	r25, r21
    205e:	a6 1f       	adc	r26, r22
    2060:	b7 1f       	adc	r27, r23
    2062:	c8 16       	cp	r12, r24
    2064:	d9 06       	cpc	r13, r25
    2066:	ea 06       	cpc	r14, r26
    2068:	fb 06       	cpc	r15, r27
    206a:	b0 f4       	brcc	.+44     	; 0x2098 <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    206c:	c3 81       	ldd	r28, Z+3	; 0x03
    206e:	c2 30       	cpi	r28, 0x02	; 2
    2070:	98 f0       	brcs	.+38     	; 0x2098 <move_window+0xb2>
					wsect += fs->fsize;
    2072:	f5 01       	movw	r30, r10
    2074:	86 8d       	ldd	r24, Z+30	; 0x1e
    2076:	97 8d       	ldd	r25, Z+31	; 0x1f
    2078:	a0 a1       	lds	r26, 0x40
    207a:	b1 a1       	lds	r27, 0x41
    207c:	c8 0e       	add	r12, r24
    207e:	d9 1e       	adc	r13, r25
    2080:	ea 1e       	adc	r14, r26
    2082:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    2084:	81 81       	ldd	r24, Z+1	; 0x01
    2086:	b4 01       	movw	r22, r8
    2088:	a7 01       	movw	r20, r14
    208a:	96 01       	movw	r18, r12
    208c:	01 e0       	ldi	r16, 0x01	; 1
    208e:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    2092:	c1 50       	subi	r28, 0x01	; 1
    2094:	c1 30       	cpi	r28, 0x01	; 1
    2096:	69 f7       	brne	.-38     	; 0x2072 <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    2098:	41 14       	cp	r4, r1
    209a:	51 04       	cpc	r5, r1
    209c:	61 04       	cpc	r6, r1
    209e:	71 04       	cpc	r7, r1
    20a0:	b1 f0       	breq	.+44     	; 0x20ce <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    20a2:	b5 01       	movw	r22, r10
    20a4:	6e 5c       	subi	r22, 0xCE	; 206
    20a6:	7f 4f       	sbci	r23, 0xFF	; 255
    20a8:	f5 01       	movw	r30, r10
    20aa:	81 81       	ldd	r24, Z+1	; 0x01
    20ac:	a3 01       	movw	r20, r6
    20ae:	92 01       	movw	r18, r4
    20b0:	01 e0       	ldi	r16, 0x01	; 1
    20b2:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    20b6:	88 23       	and	r24, r24
    20b8:	61 f4       	brne	.+24     	; 0x20d2 <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    20ba:	f5 01       	movw	r30, r10
    20bc:	46 a6       	lds	r20, 0xb6
    20be:	57 a6       	lds	r21, 0xb7
    20c0:	60 aa       	sts	0x90, r22
    20c2:	71 aa       	sts	0x91, r23
    20c4:	07 c0       	rjmp	.+14     	; 0x20d4 <move_window+0xee>
		}
	}

	return FR_OK;
    20c6:	80 e0       	ldi	r24, 0x00	; 0
    20c8:	05 c0       	rjmp	.+10     	; 0x20d4 <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	03 c0       	rjmp	.+6      	; 0x20d4 <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    20d2:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    20d4:	cf 91       	pop	r28
    20d6:	0f 91       	pop	r16
    20d8:	ff 90       	pop	r15
    20da:	ef 90       	pop	r14
    20dc:	df 90       	pop	r13
    20de:	cf 90       	pop	r12
    20e0:	bf 90       	pop	r11
    20e2:	af 90       	pop	r10
    20e4:	9f 90       	pop	r9
    20e6:	8f 90       	pop	r8
    20e8:	7f 90       	pop	r7
    20ea:	6f 90       	pop	r6
    20ec:	5f 90       	pop	r5
    20ee:	4f 90       	pop	r4
    20f0:	08 95       	ret

000020f2 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    20f2:	ef 92       	push	r14
    20f4:	ff 92       	push	r15
    20f6:	0f 93       	push	r16
    20f8:	1f 93       	push	r17
    20fa:	cf 93       	push	r28
    20fc:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    20fe:	40 e0       	ldi	r20, 0x00	; 0
    2100:	50 e0       	ldi	r21, 0x00	; 0
    2102:	ba 01       	movw	r22, r20
    2104:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2108:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    210a:	88 23       	and	r24, r24
    210c:	09 f0       	breq	.+2      	; 0x2110 <sync+0x1e>
    210e:	78 c0       	rjmp	.+240    	; 0x2200 <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    2110:	f7 01       	movw	r30, r14
    2112:	80 81       	ld	r24, Z
    2114:	83 30       	cpi	r24, 0x03	; 3
    2116:	09 f0       	breq	.+2      	; 0x211a <sync+0x28>
    2118:	6a c0       	rjmp	.+212    	; 0x21ee <sync+0xfc>
    211a:	85 81       	ldd	r24, Z+5	; 0x05
    211c:	88 23       	and	r24, r24
    211e:	09 f4       	brne	.+2      	; 0x2122 <sync+0x30>
    2120:	66 c0       	rjmp	.+204    	; 0x21ee <sync+0xfc>
			fs->winsect = 0;
    2122:	16 a6       	lds	r17, 0xb6
    2124:	17 a6       	lds	r17, 0xb7
    2126:	10 aa       	sts	0x90, r17
    2128:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    212a:	87 01       	movw	r16, r14
    212c:	0e 5c       	subi	r16, 0xCE	; 206
    212e:	1f 4f       	sbci	r17, 0xFF	; 255
    2130:	c8 01       	movw	r24, r16
    2132:	60 e0       	ldi	r22, 0x00	; 0
    2134:	70 e0       	ldi	r23, 0x00	; 0
    2136:	20 e0       	ldi	r18, 0x00	; 0
    2138:	32 e0       	ldi	r19, 0x02	; 2
    213a:	40 e0       	ldi	r20, 0x00	; 0
    213c:	50 e0       	ldi	r21, 0x00	; 0
    213e:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    2142:	f7 01       	movw	r30, r14
    2144:	e0 5d       	subi	r30, 0xD0	; 208
    2146:	fd 4f       	sbci	r31, 0xFD	; 253
    2148:	85 e5       	ldi	r24, 0x55	; 85
    214a:	80 83       	st	Z, r24
    214c:	f7 01       	movw	r30, r14
    214e:	ef 5c       	subi	r30, 0xCF	; 207
    2150:	fd 4f       	sbci	r31, 0xFD	; 253
    2152:	8a ea       	ldi	r24, 0xAA	; 170
    2154:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    2156:	82 e5       	ldi	r24, 0x52	; 82
    2158:	f7 01       	movw	r30, r14
    215a:	82 ab       	sts	0x52, r24
    215c:	83 ab       	sts	0x53, r24
    215e:	81 e6       	ldi	r24, 0x61	; 97
    2160:	84 ab       	sts	0x54, r24
    2162:	91 e4       	ldi	r25, 0x41	; 65
    2164:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    2166:	ea 5e       	subi	r30, 0xEA	; 234
    2168:	fd 4f       	sbci	r31, 0xFD	; 253
    216a:	22 e7       	ldi	r18, 0x72	; 114
    216c:	20 83       	st	Z, r18
    216e:	f7 01       	movw	r30, r14
    2170:	e9 5e       	subi	r30, 0xE9	; 233
    2172:	fd 4f       	sbci	r31, 0xFD	; 253
    2174:	20 83       	st	Z, r18
    2176:	f7 01       	movw	r30, r14
    2178:	e8 5e       	subi	r30, 0xE8	; 232
    217a:	fd 4f       	sbci	r31, 0xFD	; 253
    217c:	90 83       	st	Z, r25
    217e:	f7 01       	movw	r30, r14
    2180:	e7 5e       	subi	r30, 0xE7	; 231
    2182:	fd 4f       	sbci	r31, 0xFD	; 253
    2184:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    2186:	f7 01       	movw	r30, r14
    2188:	36 85       	ldd	r19, Z+14	; 0x0e
    218a:	27 85       	ldd	r18, Z+15	; 0x0f
    218c:	90 89       	ldd	r25, Z+16	; 0x10
    218e:	81 89       	ldd	r24, Z+17	; 0x11
    2190:	e6 5e       	subi	r30, 0xE6	; 230
    2192:	fd 4f       	sbci	r31, 0xFD	; 253
    2194:	30 83       	st	Z, r19
    2196:	f7 01       	movw	r30, r14
    2198:	e5 5e       	subi	r30, 0xE5	; 229
    219a:	fd 4f       	sbci	r31, 0xFD	; 253
    219c:	20 83       	st	Z, r18
    219e:	f7 01       	movw	r30, r14
    21a0:	e4 5e       	subi	r30, 0xE4	; 228
    21a2:	fd 4f       	sbci	r31, 0xFD	; 253
    21a4:	90 83       	st	Z, r25
    21a6:	f7 01       	movw	r30, r14
    21a8:	e3 5e       	subi	r30, 0xE3	; 227
    21aa:	fd 4f       	sbci	r31, 0xFD	; 253
    21ac:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    21ae:	f7 01       	movw	r30, r14
    21b0:	32 85       	ldd	r19, Z+10	; 0x0a
    21b2:	23 85       	ldd	r18, Z+11	; 0x0b
    21b4:	94 85       	ldd	r25, Z+12	; 0x0c
    21b6:	85 85       	ldd	r24, Z+13	; 0x0d
    21b8:	e2 5e       	subi	r30, 0xE2	; 226
    21ba:	fd 4f       	sbci	r31, 0xFD	; 253
    21bc:	30 83       	st	Z, r19
    21be:	f7 01       	movw	r30, r14
    21c0:	e1 5e       	subi	r30, 0xE1	; 225
    21c2:	fd 4f       	sbci	r31, 0xFD	; 253
    21c4:	20 83       	st	Z, r18
    21c6:	f7 01       	movw	r30, r14
    21c8:	e0 5e       	subi	r30, 0xE0	; 224
    21ca:	fd 4f       	sbci	r31, 0xFD	; 253
    21cc:	90 83       	st	Z, r25
    21ce:	f7 01       	movw	r30, r14
    21d0:	ef 5d       	subi	r30, 0xDF	; 223
    21d2:	fd 4f       	sbci	r31, 0xFD	; 253
    21d4:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    21d6:	f7 01       	movw	r30, r14
    21d8:	22 89       	ldd	r18, Z+18	; 0x12
    21da:	33 89       	ldd	r19, Z+19	; 0x13
    21dc:	44 89       	ldd	r20, Z+20	; 0x14
    21de:	55 89       	ldd	r21, Z+21	; 0x15
    21e0:	81 81       	ldd	r24, Z+1	; 0x01
    21e2:	b8 01       	movw	r22, r16
    21e4:	01 e0       	ldi	r16, 0x01	; 1
    21e6:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
			fs->fsi_flag = 0;
    21ea:	f7 01       	movw	r30, r14
    21ec:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    21ee:	f7 01       	movw	r30, r14
    21f0:	81 81       	ldd	r24, Z+1	; 0x01
    21f2:	60 e0       	ldi	r22, 0x00	; 0
    21f4:	40 e0       	ldi	r20, 0x00	; 0
    21f6:	50 e0       	ldi	r21, 0x00	; 0
    21f8:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    21fc:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    21fe:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    2200:	8c 2f       	mov	r24, r28
    2202:	cf 91       	pop	r28
    2204:	1f 91       	pop	r17
    2206:	0f 91       	pop	r16
    2208:	ff 90       	pop	r15
    220a:	ef 90       	pop	r14
    220c:	08 95       	ret

0000220e <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    220e:	60 e0       	ldi	r22, 0x00	; 0
    2210:	70 e0       	ldi	r23, 0x00	; 0
    2212:	cb 01       	movw	r24, r22
    2214:	08 95       	ret

00002216 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    2216:	0f 93       	push	r16
    2218:	1f 93       	push	r17
    221a:	cf 93       	push	r28
    221c:	df 93       	push	r29
    221e:	ec 01       	movw	r28, r24
    2220:	db 01       	movw	r26, r22
    2222:	ca 01       	movw	r24, r20
	clst -= 2;
    2224:	02 97       	sbiw	r24, 0x02	; 2
    2226:	a1 09       	sbc	r26, r1
    2228:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    222a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    222c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    222e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2230:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2232:	42 50       	subi	r20, 0x02	; 2
    2234:	50 40       	sbci	r21, 0x00	; 0
    2236:	60 40       	sbci	r22, 0x00	; 0
    2238:	70 40       	sbci	r23, 0x00	; 0
    223a:	84 17       	cp	r24, r20
    223c:	95 07       	cpc	r25, r21
    223e:	a6 07       	cpc	r26, r22
    2240:	b7 07       	cpc	r27, r23
    2242:	98 f4       	brcc	.+38     	; 0x226a <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    2244:	2a 81       	ldd	r18, Y+2	; 0x02
    2246:	30 e0       	ldi	r19, 0x00	; 0
    2248:	40 e0       	ldi	r20, 0x00	; 0
    224a:	50 e0       	ldi	r21, 0x00	; 0
    224c:	bc 01       	movw	r22, r24
    224e:	cd 01       	movw	r24, r26
    2250:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    2254:	8b 01       	movw	r16, r22
    2256:	9c 01       	movw	r18, r24
    2258:	8a a5       	lds	r24, 0x6a
    225a:	9b a5       	lds	r25, 0x6b
    225c:	ac a5       	lds	r26, 0x6c
    225e:	bd a5       	lds	r27, 0x6d
    2260:	08 0f       	add	r16, r24
    2262:	19 1f       	adc	r17, r25
    2264:	2a 1f       	adc	r18, r26
    2266:	3b 1f       	adc	r19, r27
    2268:	03 c0       	rjmp	.+6      	; 0x2270 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    226a:	00 e0       	ldi	r16, 0x00	; 0
    226c:	10 e0       	ldi	r17, 0x00	; 0
    226e:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    2270:	60 2f       	mov	r22, r16
    2272:	71 2f       	mov	r23, r17
    2274:	82 2f       	mov	r24, r18
    2276:	93 2f       	mov	r25, r19
    2278:	df 91       	pop	r29
    227a:	cf 91       	pop	r28
    227c:	1f 91       	pop	r17
    227e:	0f 91       	pop	r16
    2280:	08 95       	ret

00002282 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    2282:	8f 92       	push	r8
    2284:	9f 92       	push	r9
    2286:	af 92       	push	r10
    2288:	bf 92       	push	r11
    228a:	cf 92       	push	r12
    228c:	df 92       	push	r13
    228e:	ef 92       	push	r14
    2290:	ff 92       	push	r15
    2292:	0f 93       	push	r16
    2294:	1f 93       	push	r17
    2296:	cf 93       	push	r28
    2298:	df 93       	push	r29
    229a:	ec 01       	movw	r28, r24
    229c:	6a 01       	movw	r12, r20
    229e:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    22a0:	42 30       	cpi	r20, 0x02	; 2
    22a2:	51 05       	cpc	r21, r1
    22a4:	61 05       	cpc	r22, r1
    22a6:	71 05       	cpc	r23, r1
    22a8:	08 f4       	brcc	.+2      	; 0x22ac <get_fat+0x2a>
    22aa:	f4 c0       	rjmp	.+488    	; 0x2494 <get_fat+0x212>
    22ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    22b0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    22b2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    22b4:	48 17       	cp	r20, r24
    22b6:	59 07       	cpc	r21, r25
    22b8:	6a 07       	cpc	r22, r26
    22ba:	7b 07       	cpc	r23, r27
    22bc:	08 f0       	brcs	.+2      	; 0x22c0 <get_fat+0x3e>
    22be:	ef c0       	rjmp	.+478    	; 0x249e <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    22c0:	88 81       	ld	r24, Y
    22c2:	82 30       	cpi	r24, 0x02	; 2
    22c4:	09 f4       	brne	.+2      	; 0x22c8 <get_fat+0x46>
    22c6:	81 c0       	rjmp	.+258    	; 0x23ca <get_fat+0x148>
    22c8:	83 30       	cpi	r24, 0x03	; 3
    22ca:	09 f4       	brne	.+2      	; 0x22ce <get_fat+0x4c>
    22cc:	a0 c0       	rjmp	.+320    	; 0x240e <get_fat+0x18c>
    22ce:	81 30       	cpi	r24, 0x01	; 1
    22d0:	09 f0       	breq	.+2      	; 0x22d4 <get_fat+0x52>
    22d2:	ea c0       	rjmp	.+468    	; 0x24a8 <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    22d4:	4a 01       	movw	r8, r20
    22d6:	5b 01       	movw	r10, r22
    22d8:	b6 94       	lsr	r11
    22da:	a7 94       	ror	r10
    22dc:	97 94       	ror	r9
    22de:	87 94       	ror	r8
    22e0:	84 0e       	add	r8, r20
    22e2:	95 1e       	adc	r9, r21
    22e4:	a6 1e       	adc	r10, r22
    22e6:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    22e8:	b5 01       	movw	r22, r10
    22ea:	a4 01       	movw	r20, r8
    22ec:	03 2e       	mov	r0, r19
    22ee:	39 e0       	ldi	r19, 0x09	; 9
    22f0:	76 95       	lsr	r23
    22f2:	67 95       	ror	r22
    22f4:	57 95       	ror	r21
    22f6:	47 95       	ror	r20
    22f8:	3a 95       	dec	r19
    22fa:	d1 f7       	brne	.-12     	; 0x22f0 <get_fat+0x6e>
    22fc:	30 2d       	mov	r19, r0
    22fe:	8a a1       	lds	r24, 0x4a
    2300:	9b a1       	lds	r25, 0x4b
    2302:	ac a1       	lds	r26, 0x4c
    2304:	bd a1       	lds	r27, 0x4d
    2306:	48 0f       	add	r20, r24
    2308:	59 1f       	adc	r21, r25
    230a:	6a 1f       	adc	r22, r26
    230c:	7b 1f       	adc	r23, r27
    230e:	ce 01       	movw	r24, r28
    2310:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2314:	88 23       	and	r24, r24
    2316:	09 f0       	breq	.+2      	; 0x231a <get_fat+0x98>
    2318:	cb c0       	rjmp	.+406    	; 0x24b0 <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    231a:	d5 01       	movw	r26, r10
    231c:	c4 01       	movw	r24, r8
    231e:	91 70       	andi	r25, 0x01	; 1
    2320:	a0 70       	andi	r26, 0x00	; 0
    2322:	b0 70       	andi	r27, 0x00	; 0
    2324:	fe 01       	movw	r30, r28
    2326:	e8 0f       	add	r30, r24
    2328:	f9 1f       	adc	r31, r25
    232a:	12 a9       	sts	0x42, r17
    232c:	08 94       	sec
    232e:	81 1c       	adc	r8, r1
    2330:	91 1c       	adc	r9, r1
    2332:	a1 1c       	adc	r10, r1
    2334:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    2336:	b5 01       	movw	r22, r10
    2338:	a4 01       	movw	r20, r8
    233a:	03 2e       	mov	r0, r19
    233c:	39 e0       	ldi	r19, 0x09	; 9
    233e:	76 95       	lsr	r23
    2340:	67 95       	ror	r22
    2342:	57 95       	ror	r21
    2344:	47 95       	ror	r20
    2346:	3a 95       	dec	r19
    2348:	d1 f7       	brne	.-12     	; 0x233e <get_fat+0xbc>
    234a:	30 2d       	mov	r19, r0
    234c:	8a a1       	lds	r24, 0x4a
    234e:	9b a1       	lds	r25, 0x4b
    2350:	ac a1       	lds	r26, 0x4c
    2352:	bd a1       	lds	r27, 0x4d
    2354:	48 0f       	add	r20, r24
    2356:	59 1f       	adc	r21, r25
    2358:	6a 1f       	adc	r22, r26
    235a:	7b 1f       	adc	r23, r27
    235c:	ce 01       	movw	r24, r28
    235e:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2362:	88 23       	and	r24, r24
    2364:	09 f0       	breq	.+2      	; 0x2368 <get_fat+0xe6>
    2366:	a8 c0       	rjmp	.+336    	; 0x24b8 <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    2368:	41 2f       	mov	r20, r17
    236a:	50 e0       	ldi	r21, 0x00	; 0
    236c:	60 e0       	ldi	r22, 0x00	; 0
    236e:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    2370:	8f ef       	ldi	r24, 0xFF	; 255
    2372:	91 e0       	ldi	r25, 0x01	; 1
    2374:	a0 e0       	ldi	r26, 0x00	; 0
    2376:	b0 e0       	ldi	r27, 0x00	; 0
    2378:	88 22       	and	r8, r24
    237a:	99 22       	and	r9, r25
    237c:	aa 22       	and	r10, r26
    237e:	bb 22       	and	r11, r27
    2380:	fe 01       	movw	r30, r28
    2382:	e8 0d       	add	r30, r8
    2384:	f9 1d       	adc	r31, r9
    2386:	92 a9       	sts	0x42, r25
    2388:	80 e0       	ldi	r24, 0x00	; 0
    238a:	8c 01       	movw	r16, r24
    238c:	22 27       	eor	r18, r18
    238e:	17 fd       	sbrc	r17, 7
    2390:	20 95       	com	r18
    2392:	32 2f       	mov	r19, r18
    2394:	40 2b       	or	r20, r16
    2396:	51 2b       	or	r21, r17
    2398:	62 2b       	or	r22, r18
    239a:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    239c:	91 e0       	ldi	r25, 0x01	; 1
    239e:	c9 22       	and	r12, r25
    23a0:	dd 24       	eor	r13, r13
    23a2:	c1 14       	cp	r12, r1
    23a4:	d1 04       	cpc	r13, r1
    23a6:	59 f0       	breq	.+22     	; 0x23be <get_fat+0x13c>
    23a8:	8a 01       	movw	r16, r20
    23aa:	9b 01       	movw	r18, r22
    23ac:	68 94       	set
    23ae:	13 f8       	bld	r1, 3
    23b0:	36 95       	lsr	r19
    23b2:	27 95       	ror	r18
    23b4:	17 95       	ror	r17
    23b6:	07 95       	ror	r16
    23b8:	16 94       	lsr	r1
    23ba:	d1 f7       	brne	.-12     	; 0x23b0 <get_fat+0x12e>
    23bc:	88 c0       	rjmp	.+272    	; 0x24ce <get_fat+0x24c>
    23be:	8a 01       	movw	r16, r20
    23c0:	9b 01       	movw	r18, r22
    23c2:	1f 70       	andi	r17, 0x0F	; 15
    23c4:	20 70       	andi	r18, 0x00	; 0
    23c6:	30 70       	andi	r19, 0x00	; 0
    23c8:	82 c0       	rjmp	.+260    	; 0x24ce <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    23ca:	45 2f       	mov	r20, r21
    23cc:	56 2f       	mov	r21, r22
    23ce:	67 2f       	mov	r22, r23
    23d0:	77 27       	eor	r23, r23
    23d2:	8a a1       	lds	r24, 0x4a
    23d4:	9b a1       	lds	r25, 0x4b
    23d6:	ac a1       	lds	r26, 0x4c
    23d8:	bd a1       	lds	r27, 0x4d
    23da:	48 0f       	add	r20, r24
    23dc:	59 1f       	adc	r21, r25
    23de:	6a 1f       	adc	r22, r26
    23e0:	7b 1f       	adc	r23, r27
    23e2:	ce 01       	movw	r24, r28
    23e4:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    23e8:	88 23       	and	r24, r24
    23ea:	09 f0       	breq	.+2      	; 0x23ee <get_fat+0x16c>
    23ec:	69 c0       	rjmp	.+210    	; 0x24c0 <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    23ee:	f6 01       	movw	r30, r12
    23f0:	ee 0f       	add	r30, r30
    23f2:	ff 1f       	adc	r31, r31
    23f4:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    23f6:	ce 0f       	add	r28, r30
    23f8:	df 1f       	adc	r29, r31
    23fa:	9b a9       	sts	0x4b, r25
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	0a a9       	sts	0x4a, r16
    2400:	10 e0       	ldi	r17, 0x00	; 0
    2402:	80 2b       	or	r24, r16
    2404:	91 2b       	or	r25, r17
    2406:	8c 01       	movw	r16, r24
    2408:	20 e0       	ldi	r18, 0x00	; 0
    240a:	30 e0       	ldi	r19, 0x00	; 0
    240c:	60 c0       	rjmp	.+192    	; 0x24ce <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    240e:	68 94       	set
    2410:	16 f8       	bld	r1, 6
    2412:	76 95       	lsr	r23
    2414:	67 95       	ror	r22
    2416:	57 95       	ror	r21
    2418:	47 95       	ror	r20
    241a:	16 94       	lsr	r1
    241c:	d1 f7       	brne	.-12     	; 0x2412 <get_fat+0x190>
    241e:	8a a1       	lds	r24, 0x4a
    2420:	9b a1       	lds	r25, 0x4b
    2422:	ac a1       	lds	r26, 0x4c
    2424:	bd a1       	lds	r27, 0x4d
    2426:	48 0f       	add	r20, r24
    2428:	59 1f       	adc	r21, r25
    242a:	6a 1f       	adc	r22, r26
    242c:	7b 1f       	adc	r23, r27
    242e:	ce 01       	movw	r24, r28
    2430:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2434:	88 23       	and	r24, r24
    2436:	09 f0       	breq	.+2      	; 0x243a <get_fat+0x1b8>
    2438:	47 c0       	rjmp	.+142    	; 0x24c8 <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    243a:	f6 01       	movw	r30, r12
    243c:	ee 0f       	add	r30, r30
    243e:	ff 1f       	adc	r31, r31
    2440:	ee 0f       	add	r30, r30
    2442:	ff 1f       	adc	r31, r31
    2444:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    2446:	ce 0f       	add	r28, r30
    2448:	df 1f       	adc	r29, r31
    244a:	0d a9       	sts	0x4d, r16
    244c:	10 e0       	ldi	r17, 0x00	; 0
    244e:	20 e0       	ldi	r18, 0x00	; 0
    2450:	30 e0       	ldi	r19, 0x00	; 0
    2452:	30 2f       	mov	r19, r16
    2454:	22 27       	eor	r18, r18
    2456:	11 27       	eor	r17, r17
    2458:	00 27       	eor	r16, r16
    245a:	8c a9       	sts	0x4c, r24
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	a0 e0       	ldi	r26, 0x00	; 0
    2460:	b0 e0       	ldi	r27, 0x00	; 0
    2462:	dc 01       	movw	r26, r24
    2464:	99 27       	eor	r25, r25
    2466:	88 27       	eor	r24, r24
    2468:	08 2b       	or	r16, r24
    246a:	19 2b       	or	r17, r25
    246c:	2a 2b       	or	r18, r26
    246e:	3b 2b       	or	r19, r27
    2470:	8a a9       	sts	0x4a, r24
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	a0 e0       	ldi	r26, 0x00	; 0
    2476:	b0 e0       	ldi	r27, 0x00	; 0
    2478:	08 2b       	or	r16, r24
    247a:	19 2b       	or	r17, r25
    247c:	2a 2b       	or	r18, r26
    247e:	3b 2b       	or	r19, r27
    2480:	9b a9       	sts	0x4b, r25
    2482:	80 e0       	ldi	r24, 0x00	; 0
    2484:	a0 e0       	ldi	r26, 0x00	; 0
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	08 2b       	or	r16, r24
    248a:	19 2b       	or	r17, r25
    248c:	2a 2b       	or	r18, r26
    248e:	3b 2b       	or	r19, r27
    2490:	3f 70       	andi	r19, 0x0F	; 15
    2492:	1d c0       	rjmp	.+58     	; 0x24ce <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    2494:	01 e0       	ldi	r16, 0x01	; 1
    2496:	10 e0       	ldi	r17, 0x00	; 0
    2498:	20 e0       	ldi	r18, 0x00	; 0
    249a:	30 e0       	ldi	r19, 0x00	; 0
    249c:	18 c0       	rjmp	.+48     	; 0x24ce <get_fat+0x24c>
    249e:	01 e0       	ldi	r16, 0x01	; 1
    24a0:	10 e0       	ldi	r17, 0x00	; 0
    24a2:	20 e0       	ldi	r18, 0x00	; 0
    24a4:	30 e0       	ldi	r19, 0x00	; 0
    24a6:	13 c0       	rjmp	.+38     	; 0x24ce <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    24a8:	0f ef       	ldi	r16, 0xFF	; 255
    24aa:	1f ef       	ldi	r17, 0xFF	; 255
    24ac:	98 01       	movw	r18, r16
    24ae:	0f c0       	rjmp	.+30     	; 0x24ce <get_fat+0x24c>
    24b0:	0f ef       	ldi	r16, 0xFF	; 255
    24b2:	1f ef       	ldi	r17, 0xFF	; 255
    24b4:	98 01       	movw	r18, r16
    24b6:	0b c0       	rjmp	.+22     	; 0x24ce <get_fat+0x24c>
    24b8:	0f ef       	ldi	r16, 0xFF	; 255
    24ba:	1f ef       	ldi	r17, 0xFF	; 255
    24bc:	98 01       	movw	r18, r16
    24be:	07 c0       	rjmp	.+14     	; 0x24ce <get_fat+0x24c>
    24c0:	0f ef       	ldi	r16, 0xFF	; 255
    24c2:	1f ef       	ldi	r17, 0xFF	; 255
    24c4:	98 01       	movw	r18, r16
    24c6:	03 c0       	rjmp	.+6      	; 0x24ce <get_fat+0x24c>
    24c8:	0f ef       	ldi	r16, 0xFF	; 255
    24ca:	1f ef       	ldi	r17, 0xFF	; 255
    24cc:	98 01       	movw	r18, r16
}
    24ce:	60 2f       	mov	r22, r16
    24d0:	71 2f       	mov	r23, r17
    24d2:	82 2f       	mov	r24, r18
    24d4:	93 2f       	mov	r25, r19
    24d6:	df 91       	pop	r29
    24d8:	cf 91       	pop	r28
    24da:	1f 91       	pop	r17
    24dc:	0f 91       	pop	r16
    24de:	ff 90       	pop	r15
    24e0:	ef 90       	pop	r14
    24e2:	df 90       	pop	r13
    24e4:	cf 90       	pop	r12
    24e6:	bf 90       	pop	r11
    24e8:	af 90       	pop	r10
    24ea:	9f 90       	pop	r9
    24ec:	8f 90       	pop	r8
    24ee:	08 95       	ret

000024f0 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    24f0:	ef 92       	push	r14
    24f2:	ff 92       	push	r15
    24f4:	0f 93       	push	r16
    24f6:	1f 93       	push	r17
    24f8:	cf 93       	push	r28
    24fa:	df 93       	push	r29
    24fc:	ec 01       	movw	r28, r24
    24fe:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    2500:	7d 83       	std	Y+5, r23	; 0x05
    2502:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    2504:	4e 81       	ldd	r20, Y+6	; 0x06
    2506:	5f 81       	ldd	r21, Y+7	; 0x07
    2508:	68 85       	ldd	r22, Y+8	; 0x08
    250a:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    250c:	41 30       	cpi	r20, 0x01	; 1
    250e:	51 05       	cpc	r21, r1
    2510:	61 05       	cpc	r22, r1
    2512:	71 05       	cpc	r23, r1
    2514:	09 f4       	brne	.+2      	; 0x2518 <dir_sdi+0x28>
    2516:	9f c0       	rjmp	.+318    	; 0x2656 <dir_sdi+0x166>
    2518:	e8 81       	ld	r30, Y
    251a:	f9 81       	ldd	r31, Y+1	; 0x01
    251c:	82 8d       	ldd	r24, Z+26	; 0x1a
    251e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2520:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2522:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2524:	48 17       	cp	r20, r24
    2526:	59 07       	cpc	r21, r25
    2528:	6a 07       	cpc	r22, r26
    252a:	7b 07       	cpc	r23, r27
    252c:	08 f0       	brcs	.+2      	; 0x2530 <dir_sdi+0x40>
    252e:	95 c0       	rjmp	.+298    	; 0x265a <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    2530:	41 15       	cp	r20, r1
    2532:	51 05       	cpc	r21, r1
    2534:	61 05       	cpc	r22, r1
    2536:	71 05       	cpc	r23, r1
    2538:	69 f5       	brne	.+90     	; 0x2594 <dir_sdi+0xa4>
    253a:	80 81       	ld	r24, Z
    253c:	83 30       	cpi	r24, 0x03	; 3
    253e:	49 f4       	brne	.+18     	; 0x2552 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    2540:	46 a1       	lds	r20, 0x46
    2542:	57 a1       	lds	r21, 0x47
    2544:	60 a5       	lds	r22, 0x60
    2546:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    2548:	41 15       	cp	r20, r1
    254a:	51 05       	cpc	r21, r1
    254c:	61 05       	cpc	r22, r1
    254e:	71 05       	cpc	r23, r1
    2550:	09 f5       	brne	.+66     	; 0x2594 <dir_sdi+0xa4>
		dj->clust = clst;
    2552:	1a 86       	std	Y+10, r1	; 0x0a
    2554:	1b 86       	std	Y+11, r1	; 0x0b
    2556:	1c 86       	std	Y+12, r1	; 0x0c
    2558:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    255a:	80 85       	ldd	r24, Z+8	; 0x08
    255c:	91 85       	ldd	r25, Z+9	; 0x09
    255e:	08 17       	cp	r16, r24
    2560:	19 07       	cpc	r17, r25
    2562:	08 f0       	brcs	.+2      	; 0x2566 <dir_sdi+0x76>
    2564:	7c c0       	rjmp	.+248    	; 0x265e <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2566:	c8 01       	movw	r24, r16
    2568:	92 95       	swap	r25
    256a:	82 95       	swap	r24
    256c:	8f 70       	andi	r24, 0x0F	; 15
    256e:	89 27       	eor	r24, r25
    2570:	9f 70       	andi	r25, 0x0F	; 15
    2572:	89 27       	eor	r24, r25
    2574:	ac 01       	movw	r20, r24
    2576:	60 e0       	ldi	r22, 0x00	; 0
    2578:	70 e0       	ldi	r23, 0x00	; 0
    257a:	86 a1       	lds	r24, 0x46
    257c:	97 a1       	lds	r25, 0x47
    257e:	a0 a5       	lds	r26, 0x60
    2580:	b1 a5       	lds	r27, 0x61
    2582:	84 0f       	add	r24, r20
    2584:	95 1f       	adc	r25, r21
    2586:	a6 1f       	adc	r26, r22
    2588:	b7 1f       	adc	r27, r23
    258a:	8e 87       	std	Y+14, r24	; 0x0e
    258c:	9f 87       	std	Y+15, r25	; 0x0f
    258e:	a8 8b       	std	Y+16, r26	; 0x10
    2590:	b9 8b       	std	Y+17, r27	; 0x11
    2592:	4e c0       	rjmp	.+156    	; 0x2630 <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    2594:	82 81       	ldd	r24, Z+2	; 0x02
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	7c 01       	movw	r14, r24
    259a:	ee 0c       	add	r14, r14
    259c:	ff 1c       	adc	r15, r15
    259e:	ee 0c       	add	r14, r14
    25a0:	ff 1c       	adc	r15, r15
    25a2:	ee 0c       	add	r14, r14
    25a4:	ff 1c       	adc	r15, r15
    25a6:	ee 0c       	add	r14, r14
    25a8:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    25aa:	0e 15       	cp	r16, r14
    25ac:	1f 05       	cpc	r17, r15
    25ae:	28 f1       	brcs	.+74     	; 0x25fa <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    25b0:	88 81       	ld	r24, Y
    25b2:	99 81       	ldd	r25, Y+1	; 0x01
    25b4:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    25b8:	ab 01       	movw	r20, r22
    25ba:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    25bc:	4f 3f       	cpi	r20, 0xFF	; 255
    25be:	8f ef       	ldi	r24, 0xFF	; 255
    25c0:	58 07       	cpc	r21, r24
    25c2:	8f ef       	ldi	r24, 0xFF	; 255
    25c4:	68 07       	cpc	r22, r24
    25c6:	8f ef       	ldi	r24, 0xFF	; 255
    25c8:	78 07       	cpc	r23, r24
    25ca:	09 f4       	brne	.+2      	; 0x25ce <dir_sdi+0xde>
    25cc:	4a c0       	rjmp	.+148    	; 0x2662 <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    25ce:	42 30       	cpi	r20, 0x02	; 2
    25d0:	51 05       	cpc	r21, r1
    25d2:	61 05       	cpc	r22, r1
    25d4:	71 05       	cpc	r23, r1
    25d6:	08 f4       	brcc	.+2      	; 0x25da <dir_sdi+0xea>
    25d8:	46 c0       	rjmp	.+140    	; 0x2666 <dir_sdi+0x176>
    25da:	e8 81       	ld	r30, Y
    25dc:	f9 81       	ldd	r31, Y+1	; 0x01
    25de:	82 8d       	ldd	r24, Z+26	; 0x1a
    25e0:	93 8d       	ldd	r25, Z+27	; 0x1b
    25e2:	a4 8d       	ldd	r26, Z+28	; 0x1c
    25e4:	b5 8d       	ldd	r27, Z+29	; 0x1d
    25e6:	48 17       	cp	r20, r24
    25e8:	59 07       	cpc	r21, r25
    25ea:	6a 07       	cpc	r22, r26
    25ec:	7b 07       	cpc	r23, r27
    25ee:	e8 f5       	brcc	.+122    	; 0x266a <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    25f0:	0e 19       	sub	r16, r14
    25f2:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    25f4:	0e 15       	cp	r16, r14
    25f6:	1f 05       	cpc	r17, r15
    25f8:	d8 f6       	brcc	.-74     	; 0x25b0 <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    25fa:	4a 87       	std	Y+10, r20	; 0x0a
    25fc:	5b 87       	std	Y+11, r21	; 0x0b
    25fe:	6c 87       	std	Y+12, r22	; 0x0c
    2600:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2602:	88 81       	ld	r24, Y
    2604:	99 81       	ldd	r25, Y+1	; 0x01
    2606:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    260a:	ab 01       	movw	r20, r22
    260c:	bc 01       	movw	r22, r24
    260e:	c8 01       	movw	r24, r16
    2610:	92 95       	swap	r25
    2612:	82 95       	swap	r24
    2614:	8f 70       	andi	r24, 0x0F	; 15
    2616:	89 27       	eor	r24, r25
    2618:	9f 70       	andi	r25, 0x0F	; 15
    261a:	89 27       	eor	r24, r25
    261c:	a0 e0       	ldi	r26, 0x00	; 0
    261e:	b0 e0       	ldi	r27, 0x00	; 0
    2620:	84 0f       	add	r24, r20
    2622:	95 1f       	adc	r25, r21
    2624:	a6 1f       	adc	r26, r22
    2626:	b7 1f       	adc	r27, r23
    2628:	8e 87       	std	Y+14, r24	; 0x0e
    262a:	9f 87       	std	Y+15, r25	; 0x0f
    262c:	a8 8b       	std	Y+16, r26	; 0x10
    262e:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    2630:	88 81       	ld	r24, Y
    2632:	99 81       	ldd	r25, Y+1	; 0x01
    2634:	c2 96       	adiw	r24, 0x32	; 50
    2636:	0f 70       	andi	r16, 0x0F	; 15
    2638:	10 70       	andi	r17, 0x00	; 0
    263a:	00 0f       	add	r16, r16
    263c:	11 1f       	adc	r17, r17
    263e:	02 95       	swap	r16
    2640:	12 95       	swap	r17
    2642:	10 7f       	andi	r17, 0xF0	; 240
    2644:	10 27       	eor	r17, r16
    2646:	00 7f       	andi	r16, 0xF0	; 240
    2648:	10 27       	eor	r17, r16
    264a:	80 0f       	add	r24, r16
    264c:	91 1f       	adc	r25, r17
    264e:	9b 8b       	std	Y+19, r25	; 0x13
    2650:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	0b c0       	rjmp	.+22     	; 0x266c <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    2656:	82 e0       	ldi	r24, 0x02	; 2
    2658:	09 c0       	rjmp	.+18     	; 0x266c <dir_sdi+0x17c>
    265a:	82 e0       	ldi	r24, 0x02	; 2
    265c:	07 c0       	rjmp	.+14     	; 0x266c <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    265e:	82 e0       	ldi	r24, 0x02	; 2
    2660:	05 c0       	rjmp	.+10     	; 0x266c <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	03 c0       	rjmp	.+6      	; 0x266c <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    2666:	82 e0       	ldi	r24, 0x02	; 2
    2668:	01 c0       	rjmp	.+2      	; 0x266c <dir_sdi+0x17c>
    266a:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    266c:	df 91       	pop	r29
    266e:	cf 91       	pop	r28
    2670:	1f 91       	pop	r17
    2672:	0f 91       	pop	r16
    2674:	ff 90       	pop	r15
    2676:	ef 90       	pop	r14
    2678:	08 95       	ret

0000267a <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    2680:	6c 81       	ldd	r22, Y+4	; 0x04
    2682:	7d 81       	ldd	r23, Y+5	; 0x05
    2684:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
	if (res == FR_OK) {
    2688:	88 23       	and	r24, r24
    268a:	91 f4       	brne	.+36     	; 0x26b0 <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    268c:	4e 85       	ldd	r20, Y+14	; 0x0e
    268e:	5f 85       	ldd	r21, Y+15	; 0x0f
    2690:	68 89       	ldd	r22, Y+16	; 0x10
    2692:	79 89       	ldd	r23, Y+17	; 0x11
    2694:	88 81       	ld	r24, Y
    2696:	99 81       	ldd	r25, Y+1	; 0x01
    2698:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
		if (res == FR_OK) {
    269c:	88 23       	and	r24, r24
    269e:	41 f4       	brne	.+16     	; 0x26b0 <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    26a0:	ea 89       	ldd	r30, Y+18	; 0x12
    26a2:	fb 89       	ldd	r31, Y+19	; 0x13
    26a4:	95 ee       	ldi	r25, 0xE5	; 229
    26a6:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    26a8:	e8 81       	ld	r30, Y
    26aa:	f9 81       	ldd	r31, Y+1	; 0x01
    26ac:	91 e0       	ldi	r25, 0x01	; 1
    26ae:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    26b0:	df 91       	pop	r29
    26b2:	cf 91       	pop	r28
    26b4:	08 95       	ret

000026b6 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    26b6:	4f 92       	push	r4
    26b8:	5f 92       	push	r5
    26ba:	6f 92       	push	r6
    26bc:	7f 92       	push	r7
    26be:	8f 92       	push	r8
    26c0:	9f 92       	push	r9
    26c2:	af 92       	push	r10
    26c4:	bf 92       	push	r11
    26c6:	cf 92       	push	r12
    26c8:	df 92       	push	r13
    26ca:	ef 92       	push	r14
    26cc:	ff 92       	push	r15
    26ce:	0f 93       	push	r16
    26d0:	1f 93       	push	r17
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	ec 01       	movw	r28, r24
    26d8:	6a 01       	movw	r12, r20
    26da:	7b 01       	movw	r14, r22
    26dc:	48 01       	movw	r8, r16
    26de:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    26e0:	42 30       	cpi	r20, 0x02	; 2
    26e2:	51 05       	cpc	r21, r1
    26e4:	61 05       	cpc	r22, r1
    26e6:	71 05       	cpc	r23, r1
    26e8:	08 f4       	brcc	.+2      	; 0x26ec <put_fat+0x36>
    26ea:	e0 c0       	rjmp	.+448    	; 0x28ac <put_fat+0x1f6>
    26ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26ee:	9b 8d       	ldd	r25, Y+27	; 0x1b
    26f0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    26f2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    26f4:	48 17       	cp	r20, r24
    26f6:	59 07       	cpc	r21, r25
    26f8:	6a 07       	cpc	r22, r26
    26fa:	7b 07       	cpc	r23, r27
    26fc:	08 f0       	brcs	.+2      	; 0x2700 <put_fat+0x4a>
    26fe:	d8 c0       	rjmp	.+432    	; 0x28b0 <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    2700:	88 81       	ld	r24, Y
    2702:	82 30       	cpi	r24, 0x02	; 2
    2704:	09 f4       	brne	.+2      	; 0x2708 <put_fat+0x52>
    2706:	80 c0       	rjmp	.+256    	; 0x2808 <put_fat+0x152>
    2708:	83 30       	cpi	r24, 0x03	; 3
    270a:	09 f4       	brne	.+2      	; 0x270e <put_fat+0x58>
    270c:	98 c0       	rjmp	.+304    	; 0x283e <put_fat+0x188>
    270e:	81 30       	cpi	r24, 0x01	; 1
    2710:	09 f0       	breq	.+2      	; 0x2714 <put_fat+0x5e>
    2712:	c8 c0       	rjmp	.+400    	; 0x28a4 <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    2714:	db 01       	movw	r26, r22
    2716:	ca 01       	movw	r24, r20
    2718:	b6 95       	lsr	r27
    271a:	a7 95       	ror	r26
    271c:	97 95       	ror	r25
    271e:	87 95       	ror	r24
    2720:	2c 01       	movw	r4, r24
    2722:	3d 01       	movw	r6, r26
    2724:	44 0e       	add	r4, r20
    2726:	55 1e       	adc	r5, r21
    2728:	66 1e       	adc	r6, r22
    272a:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    272c:	b3 01       	movw	r22, r6
    272e:	a2 01       	movw	r20, r4
    2730:	03 2e       	mov	r0, r19
    2732:	39 e0       	ldi	r19, 0x09	; 9
    2734:	76 95       	lsr	r23
    2736:	67 95       	ror	r22
    2738:	57 95       	ror	r21
    273a:	47 95       	ror	r20
    273c:	3a 95       	dec	r19
    273e:	d1 f7       	brne	.-12     	; 0x2734 <put_fat+0x7e>
    2740:	30 2d       	mov	r19, r0
    2742:	8a a1       	lds	r24, 0x4a
    2744:	9b a1       	lds	r25, 0x4b
    2746:	ac a1       	lds	r26, 0x4c
    2748:	bd a1       	lds	r27, 0x4d
    274a:	48 0f       	add	r20, r24
    274c:	59 1f       	adc	r21, r25
    274e:	6a 1f       	adc	r22, r26
    2750:	7b 1f       	adc	r23, r27
    2752:	ce 01       	movw	r24, r28
    2754:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
			if (res != FR_OK) break;
    2758:	88 23       	and	r24, r24
    275a:	09 f0       	breq	.+2      	; 0x275e <put_fat+0xa8>
    275c:	a4 c0       	rjmp	.+328    	; 0x28a6 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    275e:	c2 01       	movw	r24, r4
    2760:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    2762:	31 e0       	ldi	r19, 0x01	; 1
    2764:	c3 22       	and	r12, r19
    2766:	dd 24       	eor	r13, r13
    2768:	c1 14       	cp	r12, r1
    276a:	d1 04       	cpc	r13, r1
    276c:	51 f0       	breq	.+20     	; 0x2782 <put_fat+0xcc>
    276e:	fe 01       	movw	r30, r28
    2770:	e8 0f       	add	r30, r24
    2772:	f9 1f       	adc	r31, r25
    2774:	22 a9       	sts	0x42, r18
    2776:	2f 70       	andi	r18, 0x0F	; 15
    2778:	38 2d       	mov	r19, r8
    277a:	32 95       	swap	r19
    277c:	30 7f       	andi	r19, 0xF0	; 240
    277e:	23 2b       	or	r18, r19
    2780:	01 c0       	rjmp	.+2      	; 0x2784 <put_fat+0xce>
    2782:	28 2d       	mov	r18, r8
    2784:	fe 01       	movw	r30, r28
    2786:	e8 0f       	add	r30, r24
    2788:	f9 1f       	adc	r31, r25
    278a:	22 ab       	sts	0x52, r18
			bc++;
    278c:	08 94       	sec
    278e:	41 1c       	adc	r4, r1
    2790:	51 1c       	adc	r5, r1
    2792:	61 1c       	adc	r6, r1
    2794:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    279a:	b3 01       	movw	r22, r6
    279c:	a2 01       	movw	r20, r4
    279e:	03 2e       	mov	r0, r19
    27a0:	39 e0       	ldi	r19, 0x09	; 9
    27a2:	76 95       	lsr	r23
    27a4:	67 95       	ror	r22
    27a6:	57 95       	ror	r21
    27a8:	47 95       	ror	r20
    27aa:	3a 95       	dec	r19
    27ac:	d1 f7       	brne	.-12     	; 0x27a2 <put_fat+0xec>
    27ae:	30 2d       	mov	r19, r0
    27b0:	8a a1       	lds	r24, 0x4a
    27b2:	9b a1       	lds	r25, 0x4b
    27b4:	ac a1       	lds	r26, 0x4c
    27b6:	bd a1       	lds	r27, 0x4d
    27b8:	48 0f       	add	r20, r24
    27ba:	59 1f       	adc	r21, r25
    27bc:	6a 1f       	adc	r22, r26
    27be:	7b 1f       	adc	r23, r27
    27c0:	ce 01       	movw	r24, r28
    27c2:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
			if (res != FR_OK) break;
    27c6:	88 23       	and	r24, r24
    27c8:	09 f0       	breq	.+2      	; 0x27cc <put_fat+0x116>
    27ca:	6d c0       	rjmp	.+218    	; 0x28a6 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    27cc:	ef ef       	ldi	r30, 0xFF	; 255
    27ce:	f1 e0       	ldi	r31, 0x01	; 1
    27d0:	4e 22       	and	r4, r30
    27d2:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    27d4:	c1 14       	cp	r12, r1
    27d6:	d1 04       	cpc	r13, r1
    27d8:	49 f0       	breq	.+18     	; 0x27ec <put_fat+0x136>
    27da:	68 94       	set
    27dc:	13 f8       	bld	r1, 3
    27de:	b6 94       	lsr	r11
    27e0:	a7 94       	ror	r10
    27e2:	97 94       	ror	r9
    27e4:	87 94       	ror	r8
    27e6:	16 94       	lsr	r1
    27e8:	d1 f7       	brne	.-12     	; 0x27de <put_fat+0x128>
    27ea:	09 c0       	rjmp	.+18     	; 0x27fe <put_fat+0x148>
    27ec:	fe 01       	movw	r30, r28
    27ee:	e4 0d       	add	r30, r4
    27f0:	f5 1d       	adc	r31, r5
    27f2:	22 a9       	sts	0x42, r18
    27f4:	20 7f       	andi	r18, 0xF0	; 240
    27f6:	99 2d       	mov	r25, r9
    27f8:	9f 70       	andi	r25, 0x0F	; 15
    27fa:	82 2e       	mov	r8, r18
    27fc:	89 2a       	or	r8, r25
    27fe:	4c 0e       	add	r4, r28
    2800:	5d 1e       	adc	r5, r29
    2802:	f2 01       	movw	r30, r4
    2804:	82 aa       	sts	0x92, r24
			break;
    2806:	4f c0       	rjmp	.+158    	; 0x28a6 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    2808:	45 2f       	mov	r20, r21
    280a:	56 2f       	mov	r21, r22
    280c:	67 2f       	mov	r22, r23
    280e:	77 27       	eor	r23, r23
    2810:	8a a1       	lds	r24, 0x4a
    2812:	9b a1       	lds	r25, 0x4b
    2814:	ac a1       	lds	r26, 0x4c
    2816:	bd a1       	lds	r27, 0x4d
    2818:	48 0f       	add	r20, r24
    281a:	59 1f       	adc	r21, r25
    281c:	6a 1f       	adc	r22, r26
    281e:	7b 1f       	adc	r23, r27
    2820:	ce 01       	movw	r24, r28
    2822:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
			if (res != FR_OK) break;
    2826:	88 23       	and	r24, r24
    2828:	09 f0       	breq	.+2      	; 0x282c <put_fat+0x176>
    282a:	3d c0       	rjmp	.+122    	; 0x28a6 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    282c:	f6 01       	movw	r30, r12
    282e:	ee 0f       	add	r30, r30
    2830:	ff 1f       	adc	r31, r31
    2832:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    2834:	ec 0f       	add	r30, r28
    2836:	fd 1f       	adc	r31, r29
    2838:	82 aa       	sts	0x92, r24
    283a:	93 aa       	sts	0x93, r25
			break;
    283c:	34 c0       	rjmp	.+104    	; 0x28a6 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    283e:	68 94       	set
    2840:	16 f8       	bld	r1, 6
    2842:	76 95       	lsr	r23
    2844:	67 95       	ror	r22
    2846:	57 95       	ror	r21
    2848:	47 95       	ror	r20
    284a:	16 94       	lsr	r1
    284c:	d1 f7       	brne	.-12     	; 0x2842 <put_fat+0x18c>
    284e:	8a a1       	lds	r24, 0x4a
    2850:	9b a1       	lds	r25, 0x4b
    2852:	ac a1       	lds	r26, 0x4c
    2854:	bd a1       	lds	r27, 0x4d
    2856:	48 0f       	add	r20, r24
    2858:	59 1f       	adc	r21, r25
    285a:	6a 1f       	adc	r22, r26
    285c:	7b 1f       	adc	r23, r27
    285e:	ce 01       	movw	r24, r28
    2860:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
			if (res != FR_OK) break;
    2864:	88 23       	and	r24, r24
    2866:	f9 f4       	brne	.+62     	; 0x28a6 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    2868:	96 01       	movw	r18, r12
    286a:	22 0f       	add	r18, r18
    286c:	33 1f       	adc	r19, r19
    286e:	22 0f       	add	r18, r18
    2870:	33 1f       	adc	r19, r19
    2872:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    2874:	fe 01       	movw	r30, r28
    2876:	e2 0f       	add	r30, r18
    2878:	f3 1f       	adc	r31, r19
    287a:	45 a9       	sts	0x45, r20
    287c:	50 e0       	ldi	r21, 0x00	; 0
    287e:	60 e0       	ldi	r22, 0x00	; 0
    2880:	70 e0       	ldi	r23, 0x00	; 0
    2882:	74 2f       	mov	r23, r20
    2884:	66 27       	eor	r22, r22
    2886:	55 27       	eor	r21, r21
    2888:	44 27       	eor	r20, r20
    288a:	40 70       	andi	r20, 0x00	; 0
    288c:	50 70       	andi	r21, 0x00	; 0
    288e:	60 70       	andi	r22, 0x00	; 0
    2890:	70 7f       	andi	r23, 0xF0	; 240
    2892:	48 29       	or	r20, r8
    2894:	59 29       	or	r21, r9
    2896:	6a 29       	or	r22, r10
    2898:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    289a:	42 ab       	sts	0x52, r20
    289c:	53 ab       	sts	0x53, r21
    289e:	64 ab       	sts	0x54, r22
    28a0:	75 ab       	sts	0x55, r23
			break;
    28a2:	01 c0       	rjmp	.+2      	; 0x28a6 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    28a4:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    28a6:	91 e0       	ldi	r25, 0x01	; 1
    28a8:	9c 83       	std	Y+4, r25	; 0x04
    28aa:	03 c0       	rjmp	.+6      	; 0x28b2 <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    28ac:	82 e0       	ldi	r24, 0x02	; 2
    28ae:	01 c0       	rjmp	.+2      	; 0x28b2 <put_fat+0x1fc>
    28b0:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    28b2:	df 91       	pop	r29
    28b4:	cf 91       	pop	r28
    28b6:	1f 91       	pop	r17
    28b8:	0f 91       	pop	r16
    28ba:	ff 90       	pop	r15
    28bc:	ef 90       	pop	r14
    28be:	df 90       	pop	r13
    28c0:	cf 90       	pop	r12
    28c2:	bf 90       	pop	r11
    28c4:	af 90       	pop	r10
    28c6:	9f 90       	pop	r9
    28c8:	8f 90       	pop	r8
    28ca:	7f 90       	pop	r7
    28cc:	6f 90       	pop	r6
    28ce:	5f 90       	pop	r5
    28d0:	4f 90       	pop	r4
    28d2:	08 95       	ret

000028d4 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    28d4:	2f 92       	push	r2
    28d6:	3f 92       	push	r3
    28d8:	4f 92       	push	r4
    28da:	5f 92       	push	r5
    28dc:	6f 92       	push	r6
    28de:	7f 92       	push	r7
    28e0:	8f 92       	push	r8
    28e2:	9f 92       	push	r9
    28e4:	af 92       	push	r10
    28e6:	bf 92       	push	r11
    28e8:	cf 92       	push	r12
    28ea:	df 92       	push	r13
    28ec:	ef 92       	push	r14
    28ee:	ff 92       	push	r15
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	00 d0       	rcall	.+0      	; 0x28fa <create_chain+0x26>
    28fa:	00 d0       	rcall	.+0      	; 0x28fc <create_chain+0x28>
    28fc:	cd b7       	in	r28, 0x3d	; 61
    28fe:	de b7       	in	r29, 0x3e	; 62
    2900:	1c 01       	movw	r2, r24
    2902:	49 83       	std	Y+1, r20	; 0x01
    2904:	5a 83       	std	Y+2, r21	; 0x02
    2906:	6b 83       	std	Y+3, r22	; 0x03
    2908:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    290a:	41 15       	cp	r20, r1
    290c:	51 05       	cpc	r21, r1
    290e:	61 05       	cpc	r22, r1
    2910:	71 05       	cpc	r23, r1
    2912:	c1 f4       	brne	.+48     	; 0x2944 <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    2914:	dc 01       	movw	r26, r24
    2916:	1a 96       	adiw	r26, 0x0a	; 10
    2918:	8d 90       	ld	r8, X+
    291a:	9d 90       	ld	r9, X+
    291c:	ad 90       	ld	r10, X+
    291e:	bc 90       	ld	r11, X
    2920:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2922:	81 14       	cp	r8, r1
    2924:	91 04       	cpc	r9, r1
    2926:	a1 04       	cpc	r10, r1
    2928:	b1 04       	cpc	r11, r1
    292a:	51 f1       	breq	.+84     	; 0x2980 <create_chain+0xac>
    292c:	5a 96       	adiw	r26, 0x1a	; 26
    292e:	8d 91       	ld	r24, X+
    2930:	9d 91       	ld	r25, X+
    2932:	0d 90       	ld	r0, X+
    2934:	bc 91       	ld	r27, X
    2936:	a0 2d       	mov	r26, r0
    2938:	88 16       	cp	r8, r24
    293a:	99 06       	cpc	r9, r25
    293c:	aa 06       	cpc	r10, r26
    293e:	bb 06       	cpc	r11, r27
    2940:	20 f5       	brcc	.+72     	; 0x298a <create_chain+0xb6>
    2942:	27 c0       	rjmp	.+78     	; 0x2992 <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    2944:	49 81       	ldd	r20, Y+1	; 0x01
    2946:	5a 81       	ldd	r21, Y+2	; 0x02
    2948:	6b 81       	ldd	r22, Y+3	; 0x03
    294a:	7c 81       	ldd	r23, Y+4	; 0x04
    294c:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    2950:	8b 01       	movw	r16, r22
    2952:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2954:	62 30       	cpi	r22, 0x02	; 2
    2956:	71 05       	cpc	r23, r1
    2958:	81 05       	cpc	r24, r1
    295a:	91 05       	cpc	r25, r1
    295c:	08 f4       	brcc	.+2      	; 0x2960 <create_chain+0x8c>
    295e:	ad c0       	rjmp	.+346    	; 0x2aba <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    2960:	f1 01       	movw	r30, r2
    2962:	82 8d       	ldd	r24, Z+26	; 0x1a
    2964:	93 8d       	ldd	r25, Z+27	; 0x1b
    2966:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2968:	b5 8d       	ldd	r27, Z+29	; 0x1d
    296a:	08 17       	cp	r16, r24
    296c:	19 07       	cpc	r17, r25
    296e:	2a 07       	cpc	r18, r26
    2970:	3b 07       	cpc	r19, r27
    2972:	08 f4       	brcc	.+2      	; 0x2976 <create_chain+0xa2>
    2974:	b6 c0       	rjmp	.+364    	; 0x2ae2 <create_chain+0x20e>
		scl = clst;
    2976:	89 80       	ldd	r8, Y+1	; 0x01
    2978:	9a 80       	ldd	r9, Y+2	; 0x02
    297a:	ab 80       	ldd	r10, Y+3	; 0x03
    297c:	bc 80       	ldd	r11, Y+4	; 0x04
    297e:	09 c0       	rjmp	.+18     	; 0x2992 <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2980:	88 24       	eor	r8, r8
    2982:	99 24       	eor	r9, r9
    2984:	54 01       	movw	r10, r8
    2986:	83 94       	inc	r8
    2988:	04 c0       	rjmp	.+8      	; 0x2992 <create_chain+0xbe>
    298a:	88 24       	eor	r8, r8
    298c:	99 24       	eor	r9, r9
    298e:	54 01       	movw	r10, r8
    2990:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    2992:	75 01       	movw	r14, r10
    2994:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2996:	44 24       	eor	r4, r4
    2998:	55 24       	eor	r5, r5
    299a:	32 01       	movw	r6, r4
    299c:	68 94       	set
    299e:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    29a0:	08 94       	sec
    29a2:	c1 1c       	adc	r12, r1
    29a4:	d1 1c       	adc	r13, r1
    29a6:	e1 1c       	adc	r14, r1
    29a8:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    29aa:	f1 01       	movw	r30, r2
    29ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    29ae:	93 8d       	ldd	r25, Z+27	; 0x1b
    29b0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    29b2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    29b4:	c8 16       	cp	r12, r24
    29b6:	d9 06       	cpc	r13, r25
    29b8:	ea 06       	cpc	r14, r26
    29ba:	fb 06       	cpc	r15, r27
    29bc:	48 f0       	brcs	.+18     	; 0x29d0 <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    29be:	f2 e0       	ldi	r31, 0x02	; 2
    29c0:	8f 16       	cp	r8, r31
    29c2:	91 04       	cpc	r9, r1
    29c4:	a1 04       	cpc	r10, r1
    29c6:	b1 04       	cpc	r11, r1
    29c8:	08 f4       	brcc	.+2      	; 0x29cc <create_chain+0xf8>
    29ca:	7c c0       	rjmp	.+248    	; 0x2ac4 <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    29cc:	73 01       	movw	r14, r6
    29ce:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    29d0:	c1 01       	movw	r24, r2
    29d2:	b7 01       	movw	r22, r14
    29d4:	a6 01       	movw	r20, r12
    29d6:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    29da:	8b 01       	movw	r16, r22
    29dc:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    29de:	61 15       	cp	r22, r1
    29e0:	71 05       	cpc	r23, r1
    29e2:	81 05       	cpc	r24, r1
    29e4:	91 05       	cpc	r25, r1
    29e6:	a9 f0       	breq	.+42     	; 0x2a12 <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    29e8:	0f 3f       	cpi	r16, 0xFF	; 255
    29ea:	8f ef       	ldi	r24, 0xFF	; 255
    29ec:	18 07       	cpc	r17, r24
    29ee:	8f ef       	ldi	r24, 0xFF	; 255
    29f0:	28 07       	cpc	r18, r24
    29f2:	8f ef       	ldi	r24, 0xFF	; 255
    29f4:	38 07       	cpc	r19, r24
    29f6:	09 f4       	brne	.+2      	; 0x29fa <create_chain+0x126>
    29f8:	74 c0       	rjmp	.+232    	; 0x2ae2 <create_chain+0x20e>
    29fa:	01 30       	cpi	r16, 0x01	; 1
    29fc:	11 05       	cpc	r17, r1
    29fe:	21 05       	cpc	r18, r1
    2a00:	31 05       	cpc	r19, r1
    2a02:	09 f4       	brne	.+2      	; 0x2a06 <create_chain+0x132>
    2a04:	6e c0       	rjmp	.+220    	; 0x2ae2 <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2a06:	c8 14       	cp	r12, r8
    2a08:	d9 04       	cpc	r13, r9
    2a0a:	ea 04       	cpc	r14, r10
    2a0c:	fb 04       	cpc	r15, r11
    2a0e:	41 f6       	brne	.-112    	; 0x29a0 <create_chain+0xcc>
    2a10:	5d c0       	rjmp	.+186    	; 0x2acc <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    2a12:	8c 2c       	mov	r8, r12
    2a14:	4d 2c       	mov	r4, r13
    2a16:	be 2c       	mov	r11, r14
    2a18:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2a1a:	c1 01       	movw	r24, r2
    2a1c:	4c 2d       	mov	r20, r12
    2a1e:	5d 2d       	mov	r21, r13
    2a20:	6e 2d       	mov	r22, r14
    2a22:	7f 2d       	mov	r23, r15
    2a24:	0f ef       	ldi	r16, 0xFF	; 255
    2a26:	1f ef       	ldi	r17, 0xFF	; 255
    2a28:	2f ef       	ldi	r18, 0xFF	; 255
    2a2a:	3f e0       	ldi	r19, 0x0F	; 15
    2a2c:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <put_fat>
	if (res == FR_OK && clst != 0) {
    2a30:	88 23       	and	r24, r24
    2a32:	e9 f5       	brne	.+122    	; 0x2aae <create_chain+0x1da>
    2a34:	89 81       	ldd	r24, Y+1	; 0x01
    2a36:	9a 81       	ldd	r25, Y+2	; 0x02
    2a38:	ab 81       	ldd	r26, Y+3	; 0x03
    2a3a:	bc 81       	ldd	r27, Y+4	; 0x04
    2a3c:	00 97       	sbiw	r24, 0x00	; 0
    2a3e:	a1 05       	cpc	r26, r1
    2a40:	b1 05       	cpc	r27, r1
    2a42:	69 f0       	breq	.+26     	; 0x2a5e <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    2a44:	c1 01       	movw	r24, r2
    2a46:	49 81       	ldd	r20, Y+1	; 0x01
    2a48:	5a 81       	ldd	r21, Y+2	; 0x02
    2a4a:	6b 81       	ldd	r22, Y+3	; 0x03
    2a4c:	7c 81       	ldd	r23, Y+4	; 0x04
    2a4e:	0c 2d       	mov	r16, r12
    2a50:	1d 2d       	mov	r17, r13
    2a52:	2e 2d       	mov	r18, r14
    2a54:	3f 2d       	mov	r19, r15
    2a56:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <put_fat>
	}
	if (res == FR_OK) {
    2a5a:	88 23       	and	r24, r24
    2a5c:	41 f5       	brne	.+80     	; 0x2aae <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2a5e:	d1 01       	movw	r26, r2
    2a60:	1a 96       	adiw	r26, 0x0a	; 10
    2a62:	8c 92       	st	X, r8
    2a64:	1a 97       	sbiw	r26, 0x0a	; 10
    2a66:	1b 96       	adiw	r26, 0x0b	; 11
    2a68:	4c 92       	st	X, r4
    2a6a:	1b 97       	sbiw	r26, 0x0b	; 11
    2a6c:	1c 96       	adiw	r26, 0x0c	; 12
    2a6e:	bc 92       	st	X, r11
    2a70:	1c 97       	sbiw	r26, 0x0c	; 12
    2a72:	1d 96       	adiw	r26, 0x0d	; 13
    2a74:	ac 92       	st	X, r10
    2a76:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2a78:	1e 96       	adiw	r26, 0x0e	; 14
    2a7a:	8d 91       	ld	r24, X+
    2a7c:	9d 91       	ld	r25, X+
    2a7e:	0d 90       	ld	r0, X+
    2a80:	bc 91       	ld	r27, X
    2a82:	a0 2d       	mov	r26, r0
    2a84:	8f 3f       	cpi	r24, 0xFF	; 255
    2a86:	ef ef       	ldi	r30, 0xFF	; 255
    2a88:	9e 07       	cpc	r25, r30
    2a8a:	ef ef       	ldi	r30, 0xFF	; 255
    2a8c:	ae 07       	cpc	r26, r30
    2a8e:	ef ef       	ldi	r30, 0xFF	; 255
    2a90:	be 07       	cpc	r27, r30
    2a92:	01 f1       	breq	.+64     	; 0x2ad4 <create_chain+0x200>
			fs->free_clust--;
    2a94:	01 97       	sbiw	r24, 0x01	; 1
    2a96:	a1 09       	sbc	r26, r1
    2a98:	b1 09       	sbc	r27, r1
    2a9a:	f1 01       	movw	r30, r2
    2a9c:	86 87       	std	Z+14, r24	; 0x0e
    2a9e:	97 87       	std	Z+15, r25	; 0x0f
    2aa0:	a0 8b       	std	Z+16, r26	; 0x10
    2aa2:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	85 83       	std	Z+5, r24	; 0x05
    2aa8:	97 01       	movw	r18, r14
    2aaa:	86 01       	movw	r16, r12
    2aac:	1a c0       	rjmp	.+52     	; 0x2ae2 <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2aae:	81 30       	cpi	r24, 0x01	; 1
    2ab0:	a1 f4       	brne	.+40     	; 0x2ada <create_chain+0x206>
    2ab2:	0f ef       	ldi	r16, 0xFF	; 255
    2ab4:	1f ef       	ldi	r17, 0xFF	; 255
    2ab6:	98 01       	movw	r18, r16
    2ab8:	14 c0       	rjmp	.+40     	; 0x2ae2 <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2aba:	01 e0       	ldi	r16, 0x01	; 1
    2abc:	10 e0       	ldi	r17, 0x00	; 0
    2abe:	20 e0       	ldi	r18, 0x00	; 0
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	0f c0       	rjmp	.+30     	; 0x2ae2 <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2ac4:	00 e0       	ldi	r16, 0x00	; 0
    2ac6:	10 e0       	ldi	r17, 0x00	; 0
    2ac8:	98 01       	movw	r18, r16
    2aca:	0b c0       	rjmp	.+22     	; 0x2ae2 <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2acc:	00 e0       	ldi	r16, 0x00	; 0
    2ace:	10 e0       	ldi	r17, 0x00	; 0
    2ad0:	98 01       	movw	r18, r16
    2ad2:	07 c0       	rjmp	.+14     	; 0x2ae2 <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    2ad4:	97 01       	movw	r18, r14
    2ad6:	86 01       	movw	r16, r12
    2ad8:	04 c0       	rjmp	.+8      	; 0x2ae2 <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2ada:	01 e0       	ldi	r16, 0x01	; 1
    2adc:	10 e0       	ldi	r17, 0x00	; 0
    2ade:	20 e0       	ldi	r18, 0x00	; 0
    2ae0:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    2ae2:	60 2f       	mov	r22, r16
    2ae4:	71 2f       	mov	r23, r17
    2ae6:	82 2f       	mov	r24, r18
    2ae8:	93 2f       	mov	r25, r19
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	df 91       	pop	r29
    2af4:	cf 91       	pop	r28
    2af6:	1f 91       	pop	r17
    2af8:	0f 91       	pop	r16
    2afa:	ff 90       	pop	r15
    2afc:	ef 90       	pop	r14
    2afe:	df 90       	pop	r13
    2b00:	cf 90       	pop	r12
    2b02:	bf 90       	pop	r11
    2b04:	af 90       	pop	r10
    2b06:	9f 90       	pop	r9
    2b08:	8f 90       	pop	r8
    2b0a:	7f 90       	pop	r7
    2b0c:	6f 90       	pop	r6
    2b0e:	5f 90       	pop	r5
    2b10:	4f 90       	pop	r4
    2b12:	3f 90       	pop	r3
    2b14:	2f 90       	pop	r2
    2b16:	08 95       	ret

00002b18 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2b18:	8f 92       	push	r8
    2b1a:	9f 92       	push	r9
    2b1c:	af 92       	push	r10
    2b1e:	bf 92       	push	r11
    2b20:	cf 92       	push	r12
    2b22:	df 92       	push	r13
    2b24:	ef 92       	push	r14
    2b26:	ff 92       	push	r15
    2b28:	0f 93       	push	r16
    2b2a:	1f 93       	push	r17
    2b2c:	cf 93       	push	r28
    2b2e:	df 93       	push	r29
    2b30:	8c 01       	movw	r16, r24
    2b32:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    2b34:	dc 01       	movw	r26, r24
    2b36:	14 96       	adiw	r26, 0x04	; 4
    2b38:	ed 90       	ld	r14, X+
    2b3a:	fc 90       	ld	r15, X
    2b3c:	15 97       	sbiw	r26, 0x05	; 5
    2b3e:	08 94       	sec
    2b40:	e1 1c       	adc	r14, r1
    2b42:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    2b44:	e1 14       	cp	r14, r1
    2b46:	f1 04       	cpc	r15, r1
    2b48:	09 f4       	brne	.+2      	; 0x2b4c <dir_next+0x34>
    2b4a:	0b c1       	rjmp	.+534    	; 0x2d62 <dir_next+0x24a>
    2b4c:	1e 96       	adiw	r26, 0x0e	; 14
    2b4e:	8d 91       	ld	r24, X+
    2b50:	9d 91       	ld	r25, X+
    2b52:	0d 90       	ld	r0, X+
    2b54:	bc 91       	ld	r27, X
    2b56:	a0 2d       	mov	r26, r0
    2b58:	00 97       	sbiw	r24, 0x00	; 0
    2b5a:	a1 05       	cpc	r26, r1
    2b5c:	b1 05       	cpc	r27, r1
    2b5e:	09 f4       	brne	.+2      	; 0x2b62 <dir_next+0x4a>
    2b60:	02 c1       	rjmp	.+516    	; 0x2d66 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    2b62:	0f 2e       	mov	r0, r31
    2b64:	ff e0       	ldi	r31, 0x0F	; 15
    2b66:	cf 2e       	mov	r12, r31
    2b68:	dd 24       	eor	r13, r13
    2b6a:	f0 2d       	mov	r31, r0
    2b6c:	ce 20       	and	r12, r14
    2b6e:	df 20       	and	r13, r15
    2b70:	c1 14       	cp	r12, r1
    2b72:	d1 04       	cpc	r13, r1
    2b74:	09 f0       	breq	.+2      	; 0x2b78 <dir_next+0x60>
    2b76:	da c0       	rjmp	.+436    	; 0x2d2c <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2b78:	01 96       	adiw	r24, 0x01	; 1
    2b7a:	a1 1d       	adc	r26, r1
    2b7c:	b1 1d       	adc	r27, r1
    2b7e:	f8 01       	movw	r30, r16
    2b80:	86 87       	std	Z+14, r24	; 0x0e
    2b82:	97 87       	std	Z+15, r25	; 0x0f
    2b84:	a0 8b       	std	Z+16, r26	; 0x10
    2b86:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2b88:	42 85       	ldd	r20, Z+10	; 0x0a
    2b8a:	53 85       	ldd	r21, Z+11	; 0x0b
    2b8c:	64 85       	ldd	r22, Z+12	; 0x0c
    2b8e:	75 85       	ldd	r23, Z+13	; 0x0d
    2b90:	41 15       	cp	r20, r1
    2b92:	51 05       	cpc	r21, r1
    2b94:	61 05       	cpc	r22, r1
    2b96:	71 05       	cpc	r23, r1
    2b98:	51 f4       	brne	.+20     	; 0x2bae <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2b9a:	01 90       	ld	r0, Z+
    2b9c:	f0 81       	ld	r31, Z
    2b9e:	e0 2d       	mov	r30, r0
    2ba0:	80 85       	ldd	r24, Z+8	; 0x08
    2ba2:	91 85       	ldd	r25, Z+9	; 0x09
    2ba4:	e8 16       	cp	r14, r24
    2ba6:	f9 06       	cpc	r15, r25
    2ba8:	08 f0       	brcs	.+2      	; 0x2bac <dir_next+0x94>
    2baa:	df c0       	rjmp	.+446    	; 0x2d6a <dir_next+0x252>
    2bac:	bf c0       	rjmp	.+382    	; 0x2d2c <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2bae:	01 90       	ld	r0, Z+
    2bb0:	f0 81       	ld	r31, Z
    2bb2:	e0 2d       	mov	r30, r0
    2bb4:	82 81       	ldd	r24, Z+2	; 0x02
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	01 97       	sbiw	r24, 0x01	; 1
    2bba:	97 01       	movw	r18, r14
    2bbc:	32 95       	swap	r19
    2bbe:	22 95       	swap	r18
    2bc0:	2f 70       	andi	r18, 0x0F	; 15
    2bc2:	23 27       	eor	r18, r19
    2bc4:	3f 70       	andi	r19, 0x0F	; 15
    2bc6:	23 27       	eor	r18, r19
    2bc8:	82 23       	and	r24, r18
    2bca:	93 23       	and	r25, r19
    2bcc:	00 97       	sbiw	r24, 0x00	; 0
    2bce:	09 f0       	breq	.+2      	; 0x2bd2 <dir_next+0xba>
    2bd0:	ad c0       	rjmp	.+346    	; 0x2d2c <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    2bd2:	cf 01       	movw	r24, r30
    2bd4:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    2bd8:	4b 01       	movw	r8, r22
    2bda:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2bdc:	62 30       	cpi	r22, 0x02	; 2
    2bde:	71 05       	cpc	r23, r1
    2be0:	81 05       	cpc	r24, r1
    2be2:	91 05       	cpc	r25, r1
    2be4:	08 f4       	brcc	.+2      	; 0x2be8 <dir_next+0xd0>
    2be6:	c3 c0       	rjmp	.+390    	; 0x2d6e <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2be8:	6f 3f       	cpi	r22, 0xFF	; 255
    2bea:	ef ef       	ldi	r30, 0xFF	; 255
    2bec:	7e 07       	cpc	r23, r30
    2bee:	ef ef       	ldi	r30, 0xFF	; 255
    2bf0:	8e 07       	cpc	r24, r30
    2bf2:	ef ef       	ldi	r30, 0xFF	; 255
    2bf4:	9e 07       	cpc	r25, r30
    2bf6:	09 f4       	brne	.+2      	; 0x2bfa <dir_next+0xe2>
    2bf8:	bc c0       	rjmp	.+376    	; 0x2d72 <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2bfa:	d8 01       	movw	r26, r16
    2bfc:	ed 91       	ld	r30, X+
    2bfe:	fc 91       	ld	r31, X
    2c00:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c02:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c04:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2c06:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2c08:	88 16       	cp	r8, r24
    2c0a:	99 06       	cpc	r9, r25
    2c0c:	aa 06       	cpc	r10, r26
    2c0e:	bb 06       	cpc	r11, r27
    2c10:	08 f4       	brcc	.+2      	; 0x2c14 <dir_next+0xfc>
    2c12:	7a c0       	rjmp	.+244    	; 0x2d08 <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2c14:	20 97       	sbiw	r28, 0x00	; 0
    2c16:	09 f4       	brne	.+2      	; 0x2c1a <dir_next+0x102>
    2c18:	ae c0       	rjmp	.+348    	; 0x2d76 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2c1a:	d8 01       	movw	r26, r16
    2c1c:	1a 96       	adiw	r26, 0x0a	; 10
    2c1e:	4d 91       	ld	r20, X+
    2c20:	5d 91       	ld	r21, X+
    2c22:	6d 91       	ld	r22, X+
    2c24:	7c 91       	ld	r23, X
    2c26:	1d 97       	sbiw	r26, 0x0d	; 13
    2c28:	cf 01       	movw	r24, r30
    2c2a:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    2c2e:	4b 01       	movw	r8, r22
    2c30:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2c32:	61 15       	cp	r22, r1
    2c34:	71 05       	cpc	r23, r1
    2c36:	81 05       	cpc	r24, r1
    2c38:	91 05       	cpc	r25, r1
    2c3a:	09 f4       	brne	.+2      	; 0x2c3e <dir_next+0x126>
    2c3c:	9e c0       	rjmp	.+316    	; 0x2d7a <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2c3e:	61 30       	cpi	r22, 0x01	; 1
    2c40:	71 05       	cpc	r23, r1
    2c42:	81 05       	cpc	r24, r1
    2c44:	91 05       	cpc	r25, r1
    2c46:	09 f4       	brne	.+2      	; 0x2c4a <dir_next+0x132>
    2c48:	9a c0       	rjmp	.+308    	; 0x2d7e <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2c4a:	6f 3f       	cpi	r22, 0xFF	; 255
    2c4c:	ef ef       	ldi	r30, 0xFF	; 255
    2c4e:	7e 07       	cpc	r23, r30
    2c50:	ef ef       	ldi	r30, 0xFF	; 255
    2c52:	8e 07       	cpc	r24, r30
    2c54:	ef ef       	ldi	r30, 0xFF	; 255
    2c56:	9e 07       	cpc	r25, r30
    2c58:	09 f4       	brne	.+2      	; 0x2c5c <dir_next+0x144>
    2c5a:	93 c0       	rjmp	.+294    	; 0x2d82 <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2c5c:	d8 01       	movw	r26, r16
    2c5e:	8d 91       	ld	r24, X+
    2c60:	9c 91       	ld	r25, X
    2c62:	40 e0       	ldi	r20, 0x00	; 0
    2c64:	50 e0       	ldi	r21, 0x00	; 0
    2c66:	ba 01       	movw	r22, r20
    2c68:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2c6c:	88 23       	and	r24, r24
    2c6e:	09 f0       	breq	.+2      	; 0x2c72 <dir_next+0x15a>
    2c70:	8a c0       	rjmp	.+276    	; 0x2d86 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    2c72:	f8 01       	movw	r30, r16
    2c74:	80 81       	ld	r24, Z
    2c76:	91 81       	ldd	r25, Z+1	; 0x01
    2c78:	c2 96       	adiw	r24, 0x32	; 50
    2c7a:	60 e0       	ldi	r22, 0x00	; 0
    2c7c:	70 e0       	ldi	r23, 0x00	; 0
    2c7e:	20 e0       	ldi	r18, 0x00	; 0
    2c80:	32 e0       	ldi	r19, 0x02	; 2
    2c82:	40 e0       	ldi	r20, 0x00	; 0
    2c84:	50 e0       	ldi	r21, 0x00	; 0
    2c86:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2c8a:	d8 01       	movw	r26, r16
    2c8c:	cd 91       	ld	r28, X+
    2c8e:	dc 91       	ld	r29, X
    2c90:	ce 01       	movw	r24, r28
    2c92:	b5 01       	movw	r22, r10
    2c94:	a4 01       	movw	r20, r8
    2c96:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    2c9a:	dc 01       	movw	r26, r24
    2c9c:	cb 01       	movw	r24, r22
    2c9e:	8e a7       	lds	r24, 0x7e
    2ca0:	9f a7       	lds	r25, 0x7f
    2ca2:	a8 ab       	sts	0x58, r26
    2ca4:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2ca6:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2ca8:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2caa:	1b c0       	rjmp	.+54     	; 0x2ce2 <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2cac:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2cae:	f8 01       	movw	r30, r16
    2cb0:	80 81       	ld	r24, Z
    2cb2:	91 81       	ldd	r25, Z+1	; 0x01
    2cb4:	40 e0       	ldi	r20, 0x00	; 0
    2cb6:	50 e0       	ldi	r21, 0x00	; 0
    2cb8:	ba 01       	movw	r22, r20
    2cba:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    2cbe:	88 23       	and	r24, r24
    2cc0:	09 f0       	breq	.+2      	; 0x2cc4 <dir_next+0x1ac>
    2cc2:	63 c0       	rjmp	.+198    	; 0x2d8a <dir_next+0x272>
						dj->fs->winsect++;
    2cc4:	d8 01       	movw	r26, r16
    2cc6:	ed 91       	ld	r30, X+
    2cc8:	fc 91       	ld	r31, X
    2cca:	86 a5       	lds	r24, 0x66
    2ccc:	97 a5       	lds	r25, 0x67
    2cce:	a0 a9       	sts	0x40, r26
    2cd0:	b1 a9       	sts	0x41, r27
    2cd2:	01 96       	adiw	r24, 0x01	; 1
    2cd4:	a1 1d       	adc	r26, r1
    2cd6:	b1 1d       	adc	r27, r1
    2cd8:	86 a7       	lds	r24, 0x76
    2cda:	97 a7       	lds	r25, 0x77
    2cdc:	a0 ab       	sts	0x50, r26
    2cde:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2ce0:	cf 5f       	subi	r28, 0xFF	; 255
    2ce2:	d8 01       	movw	r26, r16
    2ce4:	ed 91       	ld	r30, X+
    2ce6:	fc 91       	ld	r31, X
    2ce8:	11 97       	sbiw	r26, 0x01	; 1
    2cea:	82 81       	ldd	r24, Z+2	; 0x02
    2cec:	c8 17       	cp	r28, r24
    2cee:	f0 f2       	brcs	.-68     	; 0x2cac <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2cf0:	86 a5       	lds	r24, 0x66
    2cf2:	97 a5       	lds	r25, 0x67
    2cf4:	a0 a9       	sts	0x40, r26
    2cf6:	b1 a9       	sts	0x41, r27
    2cf8:	8c 1b       	sub	r24, r28
    2cfa:	91 09       	sbc	r25, r1
    2cfc:	a1 09       	sbc	r26, r1
    2cfe:	b1 09       	sbc	r27, r1
    2d00:	86 a7       	lds	r24, 0x76
    2d02:	97 a7       	lds	r25, 0x77
    2d04:	a0 ab       	sts	0x50, r26
    2d06:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2d08:	f8 01       	movw	r30, r16
    2d0a:	82 86       	std	Z+10, r8	; 0x0a
    2d0c:	93 86       	std	Z+11, r9	; 0x0b
    2d0e:	a4 86       	std	Z+12, r10	; 0x0c
    2d10:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2d12:	80 81       	ld	r24, Z
    2d14:	91 81       	ldd	r25, Z+1	; 0x01
    2d16:	b5 01       	movw	r22, r10
    2d18:	a4 01       	movw	r20, r8
    2d1a:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    2d1e:	dc 01       	movw	r26, r24
    2d20:	cb 01       	movw	r24, r22
    2d22:	f8 01       	movw	r30, r16
    2d24:	86 87       	std	Z+14, r24	; 0x0e
    2d26:	97 87       	std	Z+15, r25	; 0x0f
    2d28:	a0 8b       	std	Z+16, r26	; 0x10
    2d2a:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2d2c:	d8 01       	movw	r26, r16
    2d2e:	15 96       	adiw	r26, 0x05	; 5
    2d30:	fc 92       	st	X, r15
    2d32:	ee 92       	st	-X, r14
    2d34:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2d36:	8d 91       	ld	r24, X+
    2d38:	9c 91       	ld	r25, X
    2d3a:	11 97       	sbiw	r26, 0x01	; 1
    2d3c:	c2 96       	adiw	r24, 0x32	; 50
    2d3e:	cc 0c       	add	r12, r12
    2d40:	dd 1c       	adc	r13, r13
    2d42:	cc 0c       	add	r12, r12
    2d44:	dd 1c       	adc	r13, r13
    2d46:	cc 0c       	add	r12, r12
    2d48:	dd 1c       	adc	r13, r13
    2d4a:	cc 0c       	add	r12, r12
    2d4c:	dd 1c       	adc	r13, r13
    2d4e:	cc 0c       	add	r12, r12
    2d50:	dd 1c       	adc	r13, r13
    2d52:	8c 0d       	add	r24, r12
    2d54:	9d 1d       	adc	r25, r13
    2d56:	53 96       	adiw	r26, 0x13	; 19
    2d58:	9c 93       	st	X, r25
    2d5a:	8e 93       	st	-X, r24
    2d5c:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2d5e:	80 e0       	ldi	r24, 0x00	; 0
    2d60:	15 c0       	rjmp	.+42     	; 0x2d8c <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2d62:	84 e0       	ldi	r24, 0x04	; 4
    2d64:	13 c0       	rjmp	.+38     	; 0x2d8c <dir_next+0x274>
    2d66:	84 e0       	ldi	r24, 0x04	; 4
    2d68:	11 c0       	rjmp	.+34     	; 0x2d8c <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2d6a:	84 e0       	ldi	r24, 0x04	; 4
    2d6c:	0f c0       	rjmp	.+30     	; 0x2d8c <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2d6e:	82 e0       	ldi	r24, 0x02	; 2
    2d70:	0d c0       	rjmp	.+26     	; 0x2d8c <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	0b c0       	rjmp	.+22     	; 0x2d8c <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2d76:	84 e0       	ldi	r24, 0x04	; 4
    2d78:	09 c0       	rjmp	.+18     	; 0x2d8c <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2d7a:	87 e0       	ldi	r24, 0x07	; 7
    2d7c:	07 c0       	rjmp	.+14     	; 0x2d8c <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2d7e:	82 e0       	ldi	r24, 0x02	; 2
    2d80:	05 c0       	rjmp	.+10     	; 0x2d8c <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2d82:	81 e0       	ldi	r24, 0x01	; 1
    2d84:	03 c0       	rjmp	.+6      	; 0x2d8c <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2d86:	81 e0       	ldi	r24, 0x01	; 1
    2d88:	01 c0       	rjmp	.+2      	; 0x2d8c <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2d8a:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2d8c:	df 91       	pop	r29
    2d8e:	cf 91       	pop	r28
    2d90:	1f 91       	pop	r17
    2d92:	0f 91       	pop	r16
    2d94:	ff 90       	pop	r15
    2d96:	ef 90       	pop	r14
    2d98:	df 90       	pop	r13
    2d9a:	cf 90       	pop	r12
    2d9c:	bf 90       	pop	r11
    2d9e:	af 90       	pop	r10
    2da0:	9f 90       	pop	r9
    2da2:	8f 90       	pop	r8
    2da4:	08 95       	ret

00002da6 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2da6:	2f 92       	push	r2
    2da8:	3f 92       	push	r3
    2daa:	4f 92       	push	r4
    2dac:	5f 92       	push	r5
    2dae:	6f 92       	push	r6
    2db0:	7f 92       	push	r7
    2db2:	8f 92       	push	r8
    2db4:	9f 92       	push	r9
    2db6:	af 92       	push	r10
    2db8:	bf 92       	push	r11
    2dba:	cf 92       	push	r12
    2dbc:	df 92       	push	r13
    2dbe:	ef 92       	push	r14
    2dc0:	ff 92       	push	r15
    2dc2:	0f 93       	push	r16
    2dc4:	1f 93       	push	r17
    2dc6:	cf 93       	push	r28
    2dc8:	df 93       	push	r29
    2dca:	cd b7       	in	r28, 0x3d	; 61
    2dcc:	de b7       	in	r29, 0x3e	; 62
    2dce:	2b 97       	sbiw	r28, 0x0b	; 11
    2dd0:	0f b6       	in	r0, 0x3f	; 63
    2dd2:	f8 94       	cli
    2dd4:	de bf       	out	0x3e, r29	; 62
    2dd6:	0f be       	out	0x3f, r0	; 63
    2dd8:	cd bf       	out	0x3d, r28	; 61
    2dda:	8c 01       	movw	r16, r24
    2ddc:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2dde:	db 01       	movw	r26, r22
    2de0:	8c 91       	ld	r24, X
    2de2:	8f 32       	cpi	r24, 0x2F	; 47
    2de4:	11 f0       	breq	.+4      	; 0x2dea <follow_path+0x44>
    2de6:	8c 35       	cpi	r24, 0x5C	; 92
    2de8:	49 f4       	brne	.+18     	; 0x2dfc <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2dea:	08 94       	sec
    2dec:	41 1c       	adc	r4, r1
    2dee:	51 1c       	adc	r5, r1
    2df0:	f8 01       	movw	r30, r16
    2df2:	16 82       	std	Z+6, r1	; 0x06
    2df4:	17 82       	std	Z+7, r1	; 0x07
    2df6:	10 86       	std	Z+8, r1	; 0x08
    2df8:	11 86       	std	Z+9, r1	; 0x09
    2dfa:	0c c0       	rjmp	.+24     	; 0x2e14 <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2dfc:	d8 01       	movw	r26, r16
    2dfe:	ed 91       	ld	r30, X+
    2e00:	fc 91       	ld	r31, X
    2e02:	86 89       	ldd	r24, Z+22	; 0x16
    2e04:	97 89       	ldd	r25, Z+23	; 0x17
    2e06:	a0 8d       	ldd	r26, Z+24	; 0x18
    2e08:	b1 8d       	ldd	r27, Z+25	; 0x19
    2e0a:	f8 01       	movw	r30, r16
    2e0c:	86 83       	std	Z+6, r24	; 0x06
    2e0e:	97 83       	std	Z+7, r25	; 0x07
    2e10:	a0 87       	std	Z+8, r26	; 0x08
    2e12:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2e14:	d2 01       	movw	r26, r4
    2e16:	8c 91       	ld	r24, X
    2e18:	80 32       	cpi	r24, 0x20	; 32
    2e1a:	48 f4       	brcc	.+18     	; 0x2e2e <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2e1c:	c8 01       	movw	r24, r16
    2e1e:	60 e0       	ldi	r22, 0x00	; 0
    2e20:	70 e0       	ldi	r23, 0x00	; 0
    2e22:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
		dj->dir = 0;
    2e26:	f8 01       	movw	r30, r16
    2e28:	13 8a       	std	Z+19, r1	; 0x13
    2e2a:	12 8a       	std	Z+18, r1	; 0x12
    2e2c:	a5 c1       	rjmp	.+842    	; 0x3178 <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2e2e:	f8 e0       	ldi	r31, 0x08	; 8
    2e30:	fa 83       	std	Y+2, r31	; 0x02
    2e32:	1b 82       	std	Y+3, r1	; 0x03
    2e34:	1c 82       	std	Y+4, r1	; 0x04
    2e36:	1d 82       	std	Y+5, r1	; 0x05
    2e38:	2b e0       	ldi	r18, 0x0B	; 11
    2e3a:	2e 83       	std	Y+6, r18	; 0x06
    2e3c:	1f 82       	std	Y+7, r1	; 0x07
    2e3e:	18 86       	std	Y+8, r1	; 0x08
    2e40:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    2e42:	f2 01       	movw	r30, r4
    2e44:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2e46:	81 91       	ld	r24, Z+
    2e48:	8f 32       	cpi	r24, 0x2F	; 47
    2e4a:	e1 f3       	breq	.-8      	; 0x2e44 <follow_path+0x9e>
    2e4c:	8c 35       	cpi	r24, 0x5C	; 92
    2e4e:	d1 f3       	breq	.-12     	; 0x2e44 <follow_path+0x9e>
    2e50:	3b 87       	std	Y+11, r19	; 0x0b
    2e52:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    2e54:	d8 01       	movw	r26, r16
    2e56:	54 96       	adiw	r26, 0x14	; 20
    2e58:	2d 90       	ld	r2, X+
    2e5a:	3c 90       	ld	r3, X
    2e5c:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2e5e:	c1 01       	movw	r24, r2
    2e60:	60 e2       	ldi	r22, 0x20	; 32
    2e62:	70 e0       	ldi	r23, 0x00	; 0
    2e64:	2b e0       	ldi	r18, 0x0B	; 11
    2e66:	30 e0       	ldi	r19, 0x00	; 0
    2e68:	40 e0       	ldi	r20, 0x00	; 0
    2e6a:	50 e0       	ldi	r21, 0x00	; 0
    2e6c:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2e70:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e72:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e74:	80 81       	ld	r24, Z
    2e76:	8e 32       	cpi	r24, 0x2E	; 46
    2e78:	89 f5       	brne	.+98     	; 0x2edc <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2e7a:	ee e2       	ldi	r30, 0x2E	; 46
    2e7c:	d1 01       	movw	r26, r2
    2e7e:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2e80:	aa 85       	ldd	r26, Y+10	; 0x0a
    2e82:	bb 85       	ldd	r27, Y+11	; 0x0b
    2e84:	11 96       	adiw	r26, 0x01	; 1
    2e86:	2c 91       	ld	r18, X
    2e88:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2e8a:	2e 32       	cpi	r18, 0x2E	; 46
    2e8c:	61 f4       	brne	.+24     	; 0x2ea6 <follow_path+0x100>
			sfn[i++] = c;
    2e8e:	f1 01       	movw	r30, r2
    2e90:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2e92:	12 96       	adiw	r26, 0x02	; 2
    2e94:	2c 91       	ld	r18, X
    2e96:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2e98:	2e 32       	cpi	r18, 0x2E	; 46
    2e9a:	71 f0       	breq	.+28     	; 0x2eb8 <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2e9c:	83 e0       	ldi	r24, 0x03	; 3
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	a0 e0       	ldi	r26, 0x00	; 0
    2ea2:	b0 e0       	ldi	r27, 0x00	; 0
    2ea4:	04 c0       	rjmp	.+8      	; 0x2eae <follow_path+0x108>
    2ea6:	82 e0       	ldi	r24, 0x02	; 2
    2ea8:	90 e0       	ldi	r25, 0x00	; 0
    2eaa:	a0 e0       	ldi	r26, 0x00	; 0
    2eac:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2eae:	2f 32       	cpi	r18, 0x2F	; 47
    2eb0:	59 f0       	breq	.+22     	; 0x2ec8 <follow_path+0x122>
    2eb2:	2c 35       	cpi	r18, 0x5C	; 92
    2eb4:	49 f0       	breq	.+18     	; 0x2ec8 <follow_path+0x122>
    2eb6:	04 c0       	rjmp	.+8      	; 0x2ec0 <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2eb8:	83 e0       	ldi	r24, 0x03	; 3
    2eba:	90 e0       	ldi	r25, 0x00	; 0
    2ebc:	a0 e0       	ldi	r26, 0x00	; 0
    2ebe:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2ec0:	21 32       	cpi	r18, 0x21	; 33
    2ec2:	08 f0       	brcs	.+2      	; 0x2ec6 <follow_path+0x120>
    2ec4:	48 c1       	rjmp	.+656    	; 0x3156 <follow_path+0x3b0>
    2ec6:	71 c1       	rjmp	.+738    	; 0x31aa <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2ec8:	4a 84       	ldd	r4, Y+10	; 0x0a
    2eca:	5b 84       	ldd	r5, Y+11	; 0x0b
    2ecc:	48 0e       	add	r4, r24
    2ece:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2ed0:	80 e2       	ldi	r24, 0x20	; 32
    2ed2:	d1 01       	movw	r26, r2
    2ed4:	1b 96       	adiw	r26, 0x0b	; 11
    2ed6:	8c 93       	st	X, r24
    2ed8:	1b 97       	sbiw	r26, 0x0b	; 11
    2eda:	74 c1       	rjmp	.+744    	; 0x31c4 <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2edc:	cc 24       	eor	r12, r12
    2ede:	dd 24       	eor	r13, r13
    2ee0:	76 01       	movw	r14, r12
    2ee2:	40 e0       	ldi	r20, 0x00	; 0
    2ee4:	50 e0       	ldi	r21, 0x00	; 0
    2ee6:	ba 01       	movw	r22, r20
    2ee8:	88 24       	eor	r8, r8
    2eea:	99 24       	eor	r9, r9
    2eec:	54 01       	movw	r10, r8
    2eee:	68 94       	set
    2ef0:	83 f8       	bld	r8, 3
    2ef2:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2ef4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ef6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ef8:	e4 0f       	add	r30, r20
    2efa:	f5 1f       	adc	r31, r21
    2efc:	20 81       	ld	r18, Z
    2efe:	2a 01       	movw	r4, r20
    2f00:	3b 01       	movw	r6, r22
    2f02:	08 94       	sec
    2f04:	41 1c       	adc	r4, r1
    2f06:	51 1c       	adc	r5, r1
    2f08:	61 1c       	adc	r6, r1
    2f0a:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    2f0c:	21 32       	cpi	r18, 0x21	; 33
    2f0e:	08 f4       	brcc	.+2      	; 0x2f12 <follow_path+0x16c>
    2f10:	95 c0       	rjmp	.+298    	; 0x303c <follow_path+0x296>
    2f12:	2f 32       	cpi	r18, 0x2F	; 47
    2f14:	09 f4       	brne	.+2      	; 0x2f18 <follow_path+0x172>
    2f16:	4f c1       	rjmp	.+670    	; 0x31b6 <follow_path+0x410>
    2f18:	2c 35       	cpi	r18, 0x5C	; 92
    2f1a:	09 f4       	brne	.+2      	; 0x2f1e <follow_path+0x178>
    2f1c:	4c c1       	rjmp	.+664    	; 0x31b6 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    2f1e:	2e 32       	cpi	r18, 0x2E	; 46
    2f20:	29 f0       	breq	.+10     	; 0x2f2c <follow_path+0x186>
    2f22:	c8 14       	cp	r12, r8
    2f24:	d9 04       	cpc	r13, r9
    2f26:	ea 04       	cpc	r14, r10
    2f28:	fb 04       	cpc	r15, r11
    2f2a:	c8 f0       	brcs	.+50     	; 0x2f5e <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2f2c:	f8 e0       	ldi	r31, 0x08	; 8
    2f2e:	8f 16       	cp	r8, r31
    2f30:	91 04       	cpc	r9, r1
    2f32:	a1 04       	cpc	r10, r1
    2f34:	b1 04       	cpc	r11, r1
    2f36:	09 f0       	breq	.+2      	; 0x2f3a <follow_path+0x194>
    2f38:	10 c1       	rjmp	.+544    	; 0x315a <follow_path+0x3b4>
    2f3a:	2e 32       	cpi	r18, 0x2E	; 46
    2f3c:	09 f0       	breq	.+2      	; 0x2f40 <follow_path+0x19a>
    2f3e:	0f c1       	rjmp	.+542    	; 0x315e <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    2f40:	29 81       	ldd	r18, Y+1	; 0x01
    2f42:	22 0f       	add	r18, r18
    2f44:	22 0f       	add	r18, r18
    2f46:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2f48:	b3 01       	movw	r22, r6
    2f4a:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2f4c:	ca 80       	ldd	r12, Y+2	; 0x02
    2f4e:	db 80       	ldd	r13, Y+3	; 0x03
    2f50:	ec 80       	ldd	r14, Y+4	; 0x04
    2f52:	fd 80       	ldd	r15, Y+5	; 0x05
    2f54:	8e 80       	ldd	r8, Y+6	; 0x06
    2f56:	9f 80       	ldd	r9, Y+7	; 0x07
    2f58:	a8 84       	ldd	r10, Y+8	; 0x08
    2f5a:	b9 84       	ldd	r11, Y+9	; 0x09
    2f5c:	cb cf       	rjmp	.-106    	; 0x2ef4 <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2f5e:	22 23       	and	r18, r18
    2f60:	1c f4       	brge	.+6      	; 0x2f68 <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    2f62:	89 81       	ldd	r24, Y+1	; 0x01
    2f64:	83 60       	ori	r24, 0x03	; 3
    2f66:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2f68:	82 2f       	mov	r24, r18
    2f6a:	81 58       	subi	r24, 0x81	; 129
    2f6c:	8f 31       	cpi	r24, 0x1F	; 31
    2f6e:	18 f0       	brcs	.+6      	; 0x2f76 <follow_path+0x1d0>
    2f70:	8f 55       	subi	r24, 0x5F	; 95
    2f72:	8d 31       	cpi	r24, 0x1D	; 29
    2f74:	90 f5       	brcc	.+100    	; 0x2fda <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2f76:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f78:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f7a:	e4 0d       	add	r30, r4
    2f7c:	f5 1d       	adc	r31, r5
    2f7e:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    2f80:	83 2f       	mov	r24, r19
    2f82:	80 54       	subi	r24, 0x40	; 64
    2f84:	8f 33       	cpi	r24, 0x3F	; 63
    2f86:	20 f0       	brcs	.+8      	; 0x2f90 <follow_path+0x1ea>
    2f88:	80 54       	subi	r24, 0x40	; 64
    2f8a:	8d 37       	cpi	r24, 0x7D	; 125
    2f8c:	08 f0       	brcs	.+2      	; 0x2f90 <follow_path+0x1ea>
    2f8e:	e9 c0       	rjmp	.+466    	; 0x3162 <follow_path+0x3bc>
    2f90:	d5 01       	movw	r26, r10
    2f92:	c4 01       	movw	r24, r8
    2f94:	01 97       	sbiw	r24, 0x01	; 1
    2f96:	a1 09       	sbc	r26, r1
    2f98:	b1 09       	sbc	r27, r1
    2f9a:	c8 16       	cp	r12, r24
    2f9c:	d9 06       	cpc	r13, r25
    2f9e:	ea 06       	cpc	r14, r26
    2fa0:	fb 06       	cpc	r15, r27
    2fa2:	08 f0       	brcs	.+2      	; 0x2fa6 <follow_path+0x200>
    2fa4:	e0 c0       	rjmp	.+448    	; 0x3166 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2fa6:	4e 5f       	subi	r20, 0xFE	; 254
    2fa8:	5f 4f       	sbci	r21, 0xFF	; 255
    2faa:	6f 4f       	sbci	r22, 0xFF	; 255
    2fac:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    2fae:	f1 01       	movw	r30, r2
    2fb0:	ec 0d       	add	r30, r12
    2fb2:	fd 1d       	adc	r31, r13
    2fb4:	20 83       	st	Z, r18
    2fb6:	d7 01       	movw	r26, r14
    2fb8:	c6 01       	movw	r24, r12
    2fba:	01 96       	adiw	r24, 0x01	; 1
    2fbc:	a1 1d       	adc	r26, r1
    2fbe:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    2fc0:	82 0d       	add	r24, r2
    2fc2:	93 1d       	adc	r25, r3
    2fc4:	dc 01       	movw	r26, r24
    2fc6:	3c 93       	st	X, r19
    2fc8:	82 e0       	ldi	r24, 0x02	; 2
    2fca:	90 e0       	ldi	r25, 0x00	; 0
    2fcc:	a0 e0       	ldi	r26, 0x00	; 0
    2fce:	b0 e0       	ldi	r27, 0x00	; 0
    2fd0:	c8 0e       	add	r12, r24
    2fd2:	d9 1e       	adc	r13, r25
    2fd4:	ea 1e       	adc	r14, r26
    2fd6:	fb 1e       	adc	r15, r27
    2fd8:	8d cf       	rjmp	.-230    	; 0x2ef4 <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    2fda:	42 2f       	mov	r20, r18
    2fdc:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2fde:	42 32       	cpi	r20, 0x22	; 34
    2fe0:	51 05       	cpc	r21, r1
    2fe2:	09 f4       	brne	.+2      	; 0x2fe6 <follow_path+0x240>
    2fe4:	c2 c0       	rjmp	.+388    	; 0x316a <follow_path+0x3c4>
    2fe6:	ec e8       	ldi	r30, 0x8C	; 140
    2fe8:	f1 e0       	ldi	r31, 0x01	; 1
    2fea:	6a 85       	ldd	r22, Y+10	; 0x0a
    2fec:	7b 85       	ldd	r23, Y+11	; 0x0b
    2fee:	81 91       	ld	r24, Z+
    2ff0:	88 23       	and	r24, r24
    2ff2:	31 f0       	breq	.+12     	; 0x3000 <follow_path+0x25a>
    2ff4:	90 e0       	ldi	r25, 0x00	; 0
    2ff6:	48 17       	cp	r20, r24
    2ff8:	59 07       	cpc	r21, r25
    2ffa:	c9 f7       	brne	.-14     	; 0x2fee <follow_path+0x248>
    2ffc:	86 e0       	ldi	r24, 0x06	; 6
    2ffe:	bc c0       	rjmp	.+376    	; 0x3178 <follow_path+0x3d2>
    3000:	7b 87       	std	Y+11, r23	; 0x0b
    3002:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    3004:	82 2f       	mov	r24, r18
    3006:	81 54       	subi	r24, 0x41	; 65
    3008:	8a 31       	cpi	r24, 0x1A	; 26
    300a:	20 f4       	brcc	.+8      	; 0x3014 <follow_path+0x26e>
				b |= 2;
    300c:	99 81       	ldd	r25, Y+1	; 0x01
    300e:	92 60       	ori	r25, 0x02	; 2
    3010:	99 83       	std	Y+1, r25	; 0x01
    3012:	08 c0       	rjmp	.+16     	; 0x3024 <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    3014:	82 2f       	mov	r24, r18
    3016:	81 56       	subi	r24, 0x61	; 97
    3018:	8a 31       	cpi	r24, 0x1A	; 26
    301a:	20 f4       	brcc	.+8      	; 0x3024 <follow_path+0x27e>
					b |= 1; c -= 0x20;
    301c:	a9 81       	ldd	r26, Y+1	; 0x01
    301e:	a1 60       	ori	r26, 0x01	; 1
    3020:	a9 83       	std	Y+1, r26	; 0x01
    3022:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    3024:	f1 01       	movw	r30, r2
    3026:	ec 0d       	add	r30, r12
    3028:	fd 1d       	adc	r31, r13
    302a:	20 83       	st	Z, r18
    302c:	08 94       	sec
    302e:	c1 1c       	adc	r12, r1
    3030:	d1 1c       	adc	r13, r1
    3032:	e1 1c       	adc	r14, r1
    3034:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    3036:	b3 01       	movw	r22, r6
    3038:	a2 01       	movw	r20, r4
    303a:	5c cf       	rjmp	.-328    	; 0x2ef4 <follow_path+0x14e>
    303c:	ea 85       	ldd	r30, Y+10	; 0x0a
    303e:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    3040:	4e 0e       	add	r4, r30
    3042:	5f 1e       	adc	r5, r31
    3044:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3046:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    3048:	c1 14       	cp	r12, r1
    304a:	d1 04       	cpc	r13, r1
    304c:	e1 04       	cpc	r14, r1
    304e:	f1 04       	cpc	r15, r1
    3050:	09 f4       	brne	.+2      	; 0x3054 <follow_path+0x2ae>
    3052:	8d c0       	rjmp	.+282    	; 0x316e <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    3054:	d1 01       	movw	r26, r2
    3056:	9c 91       	ld	r25, X
    3058:	95 3e       	cpi	r25, 0xE5	; 229
    305a:	11 f4       	brne	.+4      	; 0x3060 <follow_path+0x2ba>
    305c:	e5 e0       	ldi	r30, 0x05	; 5
    305e:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    3060:	f8 e0       	ldi	r31, 0x08	; 8
    3062:	8f 16       	cp	r8, r31
    3064:	91 04       	cpc	r9, r1
    3066:	a1 04       	cpc	r10, r1
    3068:	b1 04       	cpc	r11, r1
    306a:	19 f4       	brne	.+6      	; 0x3072 <follow_path+0x2cc>
    306c:	88 0f       	add	r24, r24
    306e:	88 0f       	add	r24, r24
    3070:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    3072:	29 81       	ldd	r18, Y+1	; 0x01
    3074:	82 2f       	mov	r24, r18
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	9c 01       	movw	r18, r24
    307a:	23 70       	andi	r18, 0x03	; 3
    307c:	30 70       	andi	r19, 0x00	; 0
    307e:	21 30       	cpi	r18, 0x01	; 1
    3080:	31 05       	cpc	r19, r1
    3082:	09 f4       	brne	.+2      	; 0x3086 <follow_path+0x2e0>
    3084:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3086:	8c 70       	andi	r24, 0x0C	; 12
    3088:	90 70       	andi	r25, 0x00	; 0
    308a:	84 30       	cpi	r24, 0x04	; 4
    308c:	91 05       	cpc	r25, r1
    308e:	09 f4       	brne	.+2      	; 0x3092 <follow_path+0x2ec>
    3090:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    3092:	d1 01       	movw	r26, r2
    3094:	1b 96       	adiw	r26, 0x0b	; 11
    3096:	4c 93       	st	X, r20
    3098:	1b 97       	sbiw	r26, 0x0b	; 11
    309a:	94 c0       	rjmp	.+296    	; 0x31c4 <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    309c:	f8 01       	movw	r30, r16
    309e:	46 85       	ldd	r20, Z+14	; 0x0e
    30a0:	57 85       	ldd	r21, Z+15	; 0x0f
    30a2:	60 89       	ldd	r22, Z+16	; 0x10
    30a4:	71 89       	ldd	r23, Z+17	; 0x11
    30a6:	80 81       	ld	r24, Z
    30a8:	91 81       	ldd	r25, Z+1	; 0x01
    30aa:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
		if (res != FR_OK) break;
    30ae:	88 23       	and	r24, r24
    30b0:	31 f5       	brne	.+76     	; 0x30fe <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    30b2:	d8 01       	movw	r26, r16
    30b4:	52 96       	adiw	r26, 0x12	; 18
    30b6:	6d 91       	ld	r22, X+
    30b8:	7c 91       	ld	r23, X
    30ba:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    30bc:	fb 01       	movw	r30, r22
    30be:	90 81       	ld	r25, Z
    30c0:	99 23       	and	r25, r25
    30c2:	09 f4       	brne	.+2      	; 0x30c6 <follow_path+0x320>
    30c4:	90 c0       	rjmp	.+288    	; 0x31e6 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    30c6:	93 85       	ldd	r25, Z+11	; 0x0b
    30c8:	93 fd       	sbrc	r25, 3
    30ca:	12 c0       	rjmp	.+36     	; 0x30f0 <follow_path+0x34a>
    30cc:	54 96       	adiw	r26, 0x14	; 20
    30ce:	4d 91       	ld	r20, X+
    30d0:	5c 91       	ld	r21, X
    30d2:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    30d4:	9b 01       	movw	r18, r22
    30d6:	25 5f       	subi	r18, 0xF5	; 245
    30d8:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    30da:	da 01       	movw	r26, r20
    30dc:	6b 01       	movw	r12, r22
    30de:	04 c0       	rjmp	.+8      	; 0x30e8 <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    30e0:	e2 17       	cp	r30, r18
    30e2:	f3 07       	cpc	r31, r19
    30e4:	09 f4       	brne	.+2      	; 0x30e8 <follow_path+0x342>
    30e6:	77 c0       	rjmp	.+238    	; 0x31d6 <follow_path+0x430>
    30e8:	61 91       	ld	r22, Z+
    30ea:	9d 91       	ld	r25, X+
    30ec:	69 17       	cp	r22, r25
    30ee:	c1 f3       	breq	.-16     	; 0x30e0 <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    30f0:	c8 01       	movw	r24, r16
    30f2:	60 e0       	ldi	r22, 0x00	; 0
    30f4:	70 e0       	ldi	r23, 0x00	; 0
    30f6:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <dir_next>
	} while (res == FR_OK);
    30fa:	88 23       	and	r24, r24
    30fc:	79 f2       	breq	.-98     	; 0x309c <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    30fe:	d8 01       	movw	r26, r16
    3100:	54 96       	adiw	r26, 0x14	; 20
    3102:	ed 91       	ld	r30, X+
    3104:	fc 91       	ld	r31, X
    3106:	55 97       	sbiw	r26, 0x15	; 21
    3108:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    310a:	84 30       	cpi	r24, 0x04	; 4
    310c:	a9 f5       	brne	.+106    	; 0x3178 <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    310e:	95 ff       	sbrs	r25, 5
    3110:	0b c0       	rjmp	.+22     	; 0x3128 <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    3112:	f8 01       	movw	r30, r16
    3114:	16 82       	std	Z+6, r1	; 0x06
    3116:	17 82       	std	Z+7, r1	; 0x07
    3118:	10 86       	std	Z+8, r1	; 0x08
    311a:	11 86       	std	Z+9, r1	; 0x09
    311c:	13 8a       	std	Z+19, r1	; 0x13
    311e:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    3120:	92 ff       	sbrs	r25, 2
    3122:	8f ce       	rjmp	.-738    	; 0x2e42 <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    3124:	80 e0       	ldi	r24, 0x00	; 0
    3126:	28 c0       	rjmp	.+80     	; 0x3178 <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3128:	92 ff       	sbrs	r25, 2
    312a:	23 c0       	rjmp	.+70     	; 0x3172 <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    312c:	84 e0       	ldi	r24, 0x04	; 4
    312e:	24 c0       	rjmp	.+72     	; 0x3178 <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    3130:	db 01       	movw	r26, r22
    3132:	1b 96       	adiw	r26, 0x0b	; 11
    3134:	8c 91       	ld	r24, X
    3136:	1b 97       	sbiw	r26, 0x0b	; 11
    3138:	84 ff       	sbrs	r24, 4
    313a:	1d c0       	rjmp	.+58     	; 0x3176 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    313c:	f8 01       	movw	r30, r16
    313e:	80 81       	ld	r24, Z
    3140:	91 81       	ldd	r25, Z+1	; 0x01
    3142:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    3146:	dc 01       	movw	r26, r24
    3148:	cb 01       	movw	r24, r22
    314a:	f8 01       	movw	r30, r16
    314c:	86 83       	std	Z+6, r24	; 0x06
    314e:	97 83       	std	Z+7, r25	; 0x07
    3150:	a0 87       	std	Z+8, r26	; 0x08
    3152:	b1 87       	std	Z+9, r27	; 0x09
    3154:	76 ce       	rjmp	.-788    	; 0x2e42 <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    3156:	86 e0       	ldi	r24, 0x06	; 6
    3158:	0f c0       	rjmp	.+30     	; 0x3178 <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    315a:	86 e0       	ldi	r24, 0x06	; 6
    315c:	0d c0       	rjmp	.+26     	; 0x3178 <follow_path+0x3d2>
    315e:	86 e0       	ldi	r24, 0x06	; 6
    3160:	0b c0       	rjmp	.+22     	; 0x3178 <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3162:	86 e0       	ldi	r24, 0x06	; 6
    3164:	09 c0       	rjmp	.+18     	; 0x3178 <follow_path+0x3d2>
    3166:	86 e0       	ldi	r24, 0x06	; 6
    3168:	07 c0       	rjmp	.+14     	; 0x3178 <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    316a:	86 e0       	ldi	r24, 0x06	; 6
    316c:	05 c0       	rjmp	.+10     	; 0x3178 <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    316e:	86 e0       	ldi	r24, 0x06	; 6
    3170:	03 c0       	rjmp	.+6      	; 0x3178 <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3172:	85 e0       	ldi	r24, 0x05	; 5
    3174:	01 c0       	rjmp	.+2      	; 0x3178 <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    3176:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    3178:	2b 96       	adiw	r28, 0x0b	; 11
    317a:	0f b6       	in	r0, 0x3f	; 63
    317c:	f8 94       	cli
    317e:	de bf       	out	0x3e, r29	; 62
    3180:	0f be       	out	0x3f, r0	; 63
    3182:	cd bf       	out	0x3d, r28	; 61
    3184:	df 91       	pop	r29
    3186:	cf 91       	pop	r28
    3188:	1f 91       	pop	r17
    318a:	0f 91       	pop	r16
    318c:	ff 90       	pop	r15
    318e:	ef 90       	pop	r14
    3190:	df 90       	pop	r13
    3192:	cf 90       	pop	r12
    3194:	bf 90       	pop	r11
    3196:	af 90       	pop	r10
    3198:	9f 90       	pop	r9
    319a:	8f 90       	pop	r8
    319c:	7f 90       	pop	r7
    319e:	6f 90       	pop	r6
    31a0:	5f 90       	pop	r5
    31a2:	4f 90       	pop	r4
    31a4:	3f 90       	pop	r3
    31a6:	2f 90       	pop	r2
    31a8:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    31aa:	4a 84       	ldd	r4, Y+10	; 0x0a
    31ac:	5b 84       	ldd	r5, Y+11	; 0x0b
    31ae:	48 0e       	add	r4, r24
    31b0:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    31b2:	84 e2       	ldi	r24, 0x24	; 36
    31b4:	8e ce       	rjmp	.-740    	; 0x2ed2 <follow_path+0x12c>
    31b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    31b8:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    31ba:	48 0e       	add	r4, r24
    31bc:	59 1e       	adc	r5, r25
    31be:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    31c0:	40 e0       	ldi	r20, 0x00	; 0
    31c2:	42 cf       	rjmp	.-380    	; 0x3048 <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    31c4:	c8 01       	movw	r24, r16
    31c6:	60 e0       	ldi	r22, 0x00	; 0
    31c8:	70 e0       	ldi	r23, 0x00	; 0
    31ca:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
	if (res != FR_OK) return res;
    31ce:	88 23       	and	r24, r24
    31d0:	09 f4       	brne	.+2      	; 0x31d4 <follow_path+0x42e>
    31d2:	64 cf       	rjmp	.-312    	; 0x309c <follow_path+0x2f6>
    31d4:	94 cf       	rjmp	.-216    	; 0x30fe <follow_path+0x358>
    31d6:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    31d8:	da 01       	movw	r26, r20
    31da:	1b 96       	adiw	r26, 0x0b	; 11
    31dc:	9c 91       	ld	r25, X
    31de:	1b 97       	sbiw	r26, 0x0b	; 11
    31e0:	92 ff       	sbrs	r25, 2
    31e2:	a6 cf       	rjmp	.-180    	; 0x3130 <follow_path+0x38a>
    31e4:	c9 cf       	rjmp	.-110    	; 0x3178 <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    31e6:	d8 01       	movw	r26, r16
    31e8:	54 96       	adiw	r26, 0x14	; 20
    31ea:	ed 91       	ld	r30, X+
    31ec:	fc 91       	ld	r31, X
    31ee:	55 97       	sbiw	r26, 0x15	; 21
    31f0:	93 85       	ldd	r25, Z+11	; 0x0b
    31f2:	8d cf       	rjmp	.-230    	; 0x310e <follow_path+0x368>

000031f4 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    31f4:	ef 92       	push	r14
    31f6:	ff 92       	push	r15
    31f8:	0f 93       	push	r16
    31fa:	1f 93       	push	r17
    31fc:	cf 93       	push	r28
    31fe:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    3200:	60 e0       	ldi	r22, 0x00	; 0
    3202:	70 e0       	ldi	r23, 0x00	; 0
    3204:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
    3208:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    320a:	88 23       	and	r24, r24
    320c:	09 f0       	breq	.+2      	; 0x3210 <dir_register+0x1c>
    320e:	3f c0       	rjmp	.+126    	; 0x328e <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    3210:	d8 01       	movw	r26, r16
    3212:	1e 96       	adiw	r26, 0x0e	; 14
    3214:	4d 91       	ld	r20, X+
    3216:	5d 91       	ld	r21, X+
    3218:	6d 91       	ld	r22, X+
    321a:	7c 91       	ld	r23, X
    321c:	51 97       	sbiw	r26, 0x11	; 17
    321e:	8d 91       	ld	r24, X+
    3220:	9c 91       	ld	r25, X
    3222:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    3226:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    3228:	88 23       	and	r24, r24
    322a:	89 f5       	brne	.+98     	; 0x328e <dir_register+0x9a>
			c = *dj->dir;
    322c:	d8 01       	movw	r26, r16
    322e:	52 96       	adiw	r26, 0x12	; 18
    3230:	ed 91       	ld	r30, X+
    3232:	fc 91       	ld	r31, X
    3234:	53 97       	sbiw	r26, 0x13	; 19
    3236:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    3238:	85 3e       	cpi	r24, 0xE5	; 229
    323a:	81 f1       	breq	.+96     	; 0x329c <dir_register+0xa8>
    323c:	88 23       	and	r24, r24
    323e:	71 f1       	breq	.+92     	; 0x329c <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    3240:	c8 01       	movw	r24, r16
    3242:	61 e0       	ldi	r22, 0x01	; 1
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <dir_next>
    324a:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    324c:	88 23       	and	r24, r24
    324e:	01 f3       	breq	.-64     	; 0x3210 <dir_register+0x1c>
    3250:	1e c0       	rjmp	.+60     	; 0x328e <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    3252:	f8 01       	movw	r30, r16
    3254:	e2 88       	ldd	r14, Z+18	; 0x12
    3256:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    3258:	c7 01       	movw	r24, r14
    325a:	60 e0       	ldi	r22, 0x00	; 0
    325c:	70 e0       	ldi	r23, 0x00	; 0
    325e:	20 e2       	ldi	r18, 0x20	; 32
    3260:	30 e0       	ldi	r19, 0x00	; 0
    3262:	40 e0       	ldi	r20, 0x00	; 0
    3264:	50 e0       	ldi	r21, 0x00	; 0
    3266:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    326a:	d8 01       	movw	r26, r16
    326c:	54 96       	adiw	r26, 0x14	; 20
    326e:	6d 91       	ld	r22, X+
    3270:	7c 91       	ld	r23, X
    3272:	55 97       	sbiw	r26, 0x15	; 21
    3274:	c7 01       	movw	r24, r14
    3276:	2b e0       	ldi	r18, 0x0B	; 11
    3278:	30 e0       	ldi	r19, 0x00	; 0
    327a:	40 e0       	ldi	r20, 0x00	; 0
    327c:	50 e0       	ldi	r21, 0x00	; 0
    327e:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    3282:	d8 01       	movw	r26, r16
    3284:	ed 91       	ld	r30, X+
    3286:	fc 91       	ld	r31, X
    3288:	11 97       	sbiw	r26, 0x01	; 1
    328a:	81 e0       	ldi	r24, 0x01	; 1
    328c:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    328e:	8c 2f       	mov	r24, r28
    3290:	cf 91       	pop	r28
    3292:	1f 91       	pop	r17
    3294:	0f 91       	pop	r16
    3296:	ff 90       	pop	r15
    3298:	ef 90       	pop	r14
    329a:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    329c:	f8 01       	movw	r30, r16
    329e:	46 85       	ldd	r20, Z+14	; 0x0e
    32a0:	57 85       	ldd	r21, Z+15	; 0x0f
    32a2:	60 89       	ldd	r22, Z+16	; 0x10
    32a4:	71 89       	ldd	r23, Z+17	; 0x11
    32a6:	80 81       	ld	r24, Z
    32a8:	91 81       	ldd	r25, Z+1	; 0x01
    32aa:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    32ae:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    32b0:	88 23       	and	r24, r24
    32b2:	69 f7       	brne	.-38     	; 0x328e <dir_register+0x9a>
    32b4:	ce cf       	rjmp	.-100    	; 0x3252 <dir_register+0x5e>

000032b6 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    32b6:	cf 93       	push	r28
    32b8:	df 93       	push	r29
    32ba:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    32bc:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    32be:	17 c0       	rjmp	.+46     	; 0x32ee <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    32c0:	88 81       	ld	r24, Y
    32c2:	99 81       	ldd	r25, Y+1	; 0x01
    32c4:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
		if (res != FR_OK) break;
    32c8:	88 23       	and	r24, r24
    32ca:	e1 f4       	brne	.+56     	; 0x3304 <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    32cc:	ea 89       	ldd	r30, Y+18	; 0x12
    32ce:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    32d0:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    32d2:	99 23       	and	r25, r25
    32d4:	f1 f0       	breq	.+60     	; 0x3312 <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    32d6:	95 3e       	cpi	r25, 0xE5	; 229
    32d8:	19 f0       	breq	.+6      	; 0x32e0 <dir_read+0x2a>
    32da:	93 85       	ldd	r25, Z+11	; 0x0b
    32dc:	93 ff       	sbrs	r25, 3
    32de:	16 c0       	rjmp	.+44     	; 0x330c <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    32e0:	ce 01       	movw	r24, r28
    32e2:	60 e0       	ldi	r22, 0x00	; 0
    32e4:	70 e0       	ldi	r23, 0x00	; 0
    32e6:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <dir_next>
		if (res != FR_OK) break;
    32ea:	88 23       	and	r24, r24
    32ec:	59 f4       	brne	.+22     	; 0x3304 <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    32ee:	4e 85       	ldd	r20, Y+14	; 0x0e
    32f0:	5f 85       	ldd	r21, Y+15	; 0x0f
    32f2:	68 89       	ldd	r22, Y+16	; 0x10
    32f4:	79 89       	ldd	r23, Y+17	; 0x11
    32f6:	41 15       	cp	r20, r1
    32f8:	51 05       	cpc	r21, r1
    32fa:	61 05       	cpc	r22, r1
    32fc:	71 05       	cpc	r23, r1
    32fe:	01 f7       	brne	.-64     	; 0x32c0 <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    3300:	88 23       	and	r24, r24
    3302:	21 f0       	breq	.+8      	; 0x330c <dir_read+0x56>
    3304:	1e 86       	std	Y+14, r1	; 0x0e
    3306:	1f 86       	std	Y+15, r1	; 0x0f
    3308:	18 8a       	std	Y+16, r1	; 0x10
    330a:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    330c:	df 91       	pop	r29
    330e:	cf 91       	pop	r28
    3310:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3312:	84 e0       	ldi	r24, 0x04	; 4
    3314:	f7 cf       	rjmp	.-18     	; 0x3304 <dir_read+0x4e>

00003316 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    3316:	7f 92       	push	r7
    3318:	8f 92       	push	r8
    331a:	9f 92       	push	r9
    331c:	af 92       	push	r10
    331e:	bf 92       	push	r11
    3320:	cf 92       	push	r12
    3322:	df 92       	push	r13
    3324:	ef 92       	push	r14
    3326:	ff 92       	push	r15
    3328:	0f 93       	push	r16
    332a:	1f 93       	push	r17
    332c:	cf 93       	push	r28
    332e:	df 93       	push	r29
    3330:	ec 01       	movw	r28, r24
    3332:	4a 01       	movw	r8, r20
    3334:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    3336:	42 30       	cpi	r20, 0x02	; 2
    3338:	51 05       	cpc	r21, r1
    333a:	61 05       	cpc	r22, r1
    333c:	71 05       	cpc	r23, r1
    333e:	08 f4       	brcc	.+2      	; 0x3342 <remove_chain+0x2c>
    3340:	55 c0       	rjmp	.+170    	; 0x33ec <remove_chain+0xd6>
    3342:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3344:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3346:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3348:	bd 8d       	ldd	r27, Y+29	; 0x1d
    334a:	48 17       	cp	r20, r24
    334c:	59 07       	cpc	r21, r25
    334e:	6a 07       	cpc	r22, r26
    3350:	7b 07       	cpc	r23, r27
    3352:	08 f0       	brcs	.+2      	; 0x3356 <remove_chain+0x40>
    3354:	4d c0       	rjmp	.+154    	; 0x33f0 <remove_chain+0xda>
    3356:	03 c0       	rjmp	.+6      	; 0x335e <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3358:	46 01       	movw	r8, r12
    335a:	57 01       	movw	r10, r14
    335c:	02 c0       	rjmp	.+4      	; 0x3362 <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    335e:	77 24       	eor	r7, r7
    3360:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    3362:	ce 01       	movw	r24, r28
    3364:	b5 01       	movw	r22, r10
    3366:	a4 01       	movw	r20, r8
    3368:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    336c:	6b 01       	movw	r12, r22
    336e:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    3370:	61 15       	cp	r22, r1
    3372:	71 05       	cpc	r23, r1
    3374:	81 05       	cpc	r24, r1
    3376:	91 05       	cpc	r25, r1
    3378:	e9 f1       	breq	.+122    	; 0x33f4 <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    337a:	91 e0       	ldi	r25, 0x01	; 1
    337c:	c9 16       	cp	r12, r25
    337e:	d1 04       	cpc	r13, r1
    3380:	e1 04       	cpc	r14, r1
    3382:	f1 04       	cpc	r15, r1
    3384:	c9 f1       	breq	.+114    	; 0x33f8 <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3386:	8f ef       	ldi	r24, 0xFF	; 255
    3388:	c8 16       	cp	r12, r24
    338a:	8f ef       	ldi	r24, 0xFF	; 255
    338c:	d8 06       	cpc	r13, r24
    338e:	8f ef       	ldi	r24, 0xFF	; 255
    3390:	e8 06       	cpc	r14, r24
    3392:	8f ef       	ldi	r24, 0xFF	; 255
    3394:	f8 06       	cpc	r15, r24
    3396:	91 f1       	breq	.+100    	; 0x33fc <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    3398:	ce 01       	movw	r24, r28
    339a:	b5 01       	movw	r22, r10
    339c:	a4 01       	movw	r20, r8
    339e:	00 e0       	ldi	r16, 0x00	; 0
    33a0:	10 e0       	ldi	r17, 0x00	; 0
    33a2:	98 01       	movw	r18, r16
    33a4:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <put_fat>
			if (res != FR_OK) break;
    33a8:	88 23       	and	r24, r24
    33aa:	49 f5       	brne	.+82     	; 0x33fe <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    33ac:	4e 85       	ldd	r20, Y+14	; 0x0e
    33ae:	5f 85       	ldd	r21, Y+15	; 0x0f
    33b0:	68 89       	ldd	r22, Y+16	; 0x10
    33b2:	79 89       	ldd	r23, Y+17	; 0x11
    33b4:	4f 3f       	cpi	r20, 0xFF	; 255
    33b6:	9f ef       	ldi	r25, 0xFF	; 255
    33b8:	59 07       	cpc	r21, r25
    33ba:	9f ef       	ldi	r25, 0xFF	; 255
    33bc:	69 07       	cpc	r22, r25
    33be:	9f ef       	ldi	r25, 0xFF	; 255
    33c0:	79 07       	cpc	r23, r25
    33c2:	49 f0       	breq	.+18     	; 0x33d6 <remove_chain+0xc0>
				fs->free_clust++;
    33c4:	4f 5f       	subi	r20, 0xFF	; 255
    33c6:	5f 4f       	sbci	r21, 0xFF	; 255
    33c8:	6f 4f       	sbci	r22, 0xFF	; 255
    33ca:	7f 4f       	sbci	r23, 0xFF	; 255
    33cc:	4e 87       	std	Y+14, r20	; 0x0e
    33ce:	5f 87       	std	Y+15, r21	; 0x0f
    33d0:	68 8b       	std	Y+16, r22	; 0x10
    33d2:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    33d4:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    33d6:	4a 8d       	ldd	r20, Y+26	; 0x1a
    33d8:	5b 8d       	ldd	r21, Y+27	; 0x1b
    33da:	6c 8d       	ldd	r22, Y+28	; 0x1c
    33dc:	7d 8d       	ldd	r23, Y+29	; 0x1d
    33de:	c4 16       	cp	r12, r20
    33e0:	d5 06       	cpc	r13, r21
    33e2:	e6 06       	cpc	r14, r22
    33e4:	f7 06       	cpc	r15, r23
    33e6:	08 f4       	brcc	.+2      	; 0x33ea <remove_chain+0xd4>
    33e8:	b7 cf       	rjmp	.-146    	; 0x3358 <remove_chain+0x42>
    33ea:	09 c0       	rjmp	.+18     	; 0x33fe <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    33ec:	82 e0       	ldi	r24, 0x02	; 2
    33ee:	07 c0       	rjmp	.+14     	; 0x33fe <remove_chain+0xe8>
    33f0:	82 e0       	ldi	r24, 0x02	; 2
    33f2:	05 c0       	rjmp	.+10     	; 0x33fe <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    33f4:	80 e0       	ldi	r24, 0x00	; 0
    33f6:	03 c0       	rjmp	.+6      	; 0x33fe <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    33f8:	82 e0       	ldi	r24, 0x02	; 2
    33fa:	01 c0       	rjmp	.+2      	; 0x33fe <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    33fc:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    33fe:	df 91       	pop	r29
    3400:	cf 91       	pop	r28
    3402:	1f 91       	pop	r17
    3404:	0f 91       	pop	r16
    3406:	ff 90       	pop	r15
    3408:	ef 90       	pop	r14
    340a:	df 90       	pop	r13
    340c:	cf 90       	pop	r12
    340e:	bf 90       	pop	r11
    3410:	af 90       	pop	r10
    3412:	9f 90       	pop	r9
    3414:	8f 90       	pop	r8
    3416:	7f 90       	pop	r7
    3418:	08 95       	ret

0000341a <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    341a:	88 23       	and	r24, r24
    341c:	91 f4       	brne	.+36     	; 0x3442 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    341e:	e0 91 7f 02 	lds	r30, 0x027F
    3422:	f0 91 80 02 	lds	r31, 0x0280

	if (rfs) {
    3426:	30 97       	sbiw	r30, 0x00	; 0
    3428:	09 f0       	breq	.+2      	; 0x342c <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    342a:	10 82       	st	Z, r1
	}

	if (fs) {
    342c:	61 15       	cp	r22, r1
    342e:	71 05       	cpc	r23, r1
    3430:	11 f0       	breq	.+4      	; 0x3436 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    3432:	fb 01       	movw	r30, r22
    3434:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3436:	70 93 80 02 	sts	0x0280, r23
    343a:	60 93 7f 02 	sts	0x027F, r22

	return FR_OK;
    343e:	80 e0       	ldi	r24, 0x00	; 0
    3440:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3442:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3444:	08 95       	ret

00003446 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3446:	4f 92       	push	r4
    3448:	5f 92       	push	r5
    344a:	6f 92       	push	r6
    344c:	7f 92       	push	r7
    344e:	8f 92       	push	r8
    3450:	9f 92       	push	r9
    3452:	af 92       	push	r10
    3454:	bf 92       	push	r11
    3456:	cf 92       	push	r12
    3458:	df 92       	push	r13
    345a:	ef 92       	push	r14
    345c:	ff 92       	push	r15
    345e:	0f 93       	push	r16
    3460:	1f 93       	push	r17
    3462:	cf 93       	push	r28
    3464:	df 93       	push	r29
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
    346a:	a4 97       	sbiw	r28, 0x24	; 36
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	7c 01       	movw	r14, r24
    3478:	7c a3       	lds	r23, 0x5c
    347a:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    347c:	00 97       	sbiw	r24, 0x00	; 0
    347e:	09 f4       	brne	.+2      	; 0x3482 <f_open+0x3c>
    3480:	ea c0       	rjmp	.+468    	; 0x3656 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    3482:	fc 01       	movw	r30, r24
    3484:	11 82       	std	Z+1, r1	; 0x01
    3486:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    3488:	04 2f       	mov	r16, r20
    348a:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    348c:	4e 71       	andi	r20, 0x1E	; 30
    348e:	ce 01       	movw	r24, r28
    3490:	83 96       	adiw	r24, 0x23	; 35
    3492:	be 01       	movw	r22, r28
    3494:	6f 5f       	subi	r22, 0xFF	; 255
    3496:	7f 4f       	sbci	r23, 0xFF	; 255
    3498:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
    349c:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    349e:	88 23       	and	r24, r24
    34a0:	09 f0       	breq	.+2      	; 0x34a4 <f_open+0x5e>
    34a2:	da c0       	rjmp	.+436    	; 0x3658 <f_open+0x212>
		INIT_BUF(dj);
    34a4:	ce 01       	movw	r24, r28
    34a6:	47 96       	adiw	r24, 0x17	; 23
    34a8:	9e 8b       	std	Y+22, r25	; 0x16
    34aa:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    34ac:	6b a1       	lds	r22, 0x4b
    34ae:	7c a1       	lds	r23, 0x4c
    34b0:	ce 01       	movw	r24, r28
    34b2:	01 96       	adiw	r24, 0x01	; 1
    34b4:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		dir = dj.dir;
    34b8:	cb 88       	ldd	r12, Y+19	; 0x13
    34ba:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    34bc:	88 23       	and	r24, r24
    34be:	21 f4       	brne	.+8      	; 0x34c8 <f_open+0x82>
			if (!dir)	/* Current dir itself */
    34c0:	c1 14       	cp	r12, r1
    34c2:	d1 04       	cpc	r13, r1
    34c4:	09 f4       	brne	.+2      	; 0x34c8 <f_open+0x82>
				res = FR_INVALID_NAME;
    34c6:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    34c8:	40 2f       	mov	r20, r16
    34ca:	50 e0       	ldi	r21, 0x00	; 0
    34cc:	9a 01       	movw	r18, r20
    34ce:	2c 71       	andi	r18, 0x1C	; 28
    34d0:	30 70       	andi	r19, 0x00	; 0
    34d2:	21 15       	cp	r18, r1
    34d4:	31 05       	cpc	r19, r1
    34d6:	09 f4       	brne	.+2      	; 0x34da <f_open+0x94>
    34d8:	5b c0       	rjmp	.+182    	; 0x3590 <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    34da:	88 23       	and	r24, r24
    34dc:	71 f0       	breq	.+28     	; 0x34fa <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    34de:	84 30       	cpi	r24, 0x04	; 4
    34e0:	09 f0       	breq	.+2      	; 0x34e4 <f_open+0x9e>
    34e2:	b7 c0       	rjmp	.+366    	; 0x3652 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    34e4:	ce 01       	movw	r24, r28
    34e6:	01 96       	adiw	r24, 0x01	; 1
    34e8:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    34ec:	cb 88       	ldd	r12, Y+19	; 0x13
    34ee:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    34f0:	88 23       	and	r24, r24
    34f2:	09 f0       	breq	.+2      	; 0x34f6 <f_open+0xb0>
    34f4:	ae c0       	rjmp	.+348    	; 0x3652 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    34f6:	08 60       	ori	r16, 0x08	; 8
    34f8:	07 c0       	rjmp	.+14     	; 0x3508 <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    34fa:	f6 01       	movw	r30, r12
    34fc:	83 85       	ldd	r24, Z+11	; 0x0b
    34fe:	81 71       	andi	r24, 0x11	; 17
    3500:	09 f0       	breq	.+2      	; 0x3504 <f_open+0xbe>
    3502:	c2 c0       	rjmp	.+388    	; 0x3688 <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    3504:	02 fd       	sbrc	r16, 2
    3506:	c2 c0       	rjmp	.+388    	; 0x368c <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3508:	03 ff       	sbrs	r16, 3
    350a:	c6 c0       	rjmp	.+396    	; 0x3698 <f_open+0x252>
				dw = get_fattime();					/* Created time */
    350c:	0e 94 07 11 	call	0x220e	; 0x220e <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    3510:	f6 01       	movw	r30, r12
    3512:	66 87       	std	Z+14, r22	; 0x0e
    3514:	77 87       	std	Z+15, r23	; 0x0f
    3516:	80 8b       	std	Z+16, r24	; 0x10
    3518:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    351a:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    351c:	14 8e       	std	Z+28, r1	; 0x1c
    351e:	15 8e       	std	Z+29, r1	; 0x1d
    3520:	16 8e       	std	Z+30, r1	; 0x1e
    3522:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    3524:	89 81       	ldd	r24, Y+1	; 0x01
    3526:	9a 81       	ldd	r25, Y+2	; 0x02
    3528:	b6 01       	movw	r22, r12
    352a:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    352e:	4b 01       	movw	r8, r22
    3530:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    3532:	c6 01       	movw	r24, r12
    3534:	40 e0       	ldi	r20, 0x00	; 0
    3536:	50 e0       	ldi	r21, 0x00	; 0
    3538:	ba 01       	movw	r22, r20
    353a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
				dj.fs->wflag = 1;
    353e:	e9 81       	ldd	r30, Y+1	; 0x01
    3540:	fa 81       	ldd	r31, Y+2	; 0x02
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    3546:	81 14       	cp	r8, r1
    3548:	91 04       	cpc	r9, r1
    354a:	a1 04       	cpc	r10, r1
    354c:	b1 04       	cpc	r11, r1
    354e:	09 f4       	brne	.+2      	; 0x3552 <f_open+0x10c>
    3550:	a3 c0       	rjmp	.+326    	; 0x3698 <f_open+0x252>
					dw = dj.fs->winsect;
    3552:	46 a4       	lds	r20, 0xa6
    3554:	57 a4       	lds	r21, 0xa7
    3556:	60 a8       	sts	0x00, r22
    3558:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    355a:	cf 01       	movw	r24, r30
    355c:	b5 01       	movw	r22, r10
    355e:	a4 01       	movw	r20, r8
    3560:	0e 94 8b 19 	call	0x3316	; 0x3316 <remove_chain>
					if (res == FR_OK) {
    3564:	88 23       	and	r24, r24
    3566:	09 f0       	breq	.+2      	; 0x356a <f_open+0x124>
    3568:	74 c0       	rjmp	.+232    	; 0x3652 <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    356a:	e9 81       	ldd	r30, Y+1	; 0x01
    356c:	fa 81       	ldd	r31, Y+2	; 0x02
    356e:	d5 01       	movw	r26, r10
    3570:	c4 01       	movw	r24, r8
    3572:	01 97       	sbiw	r24, 0x01	; 1
    3574:	a1 09       	sbc	r26, r1
    3576:	b1 09       	sbc	r27, r1
    3578:	82 87       	std	Z+10, r24	; 0x0a
    357a:	93 87       	std	Z+11, r25	; 0x0b
    357c:	a4 87       	std	Z+12, r26	; 0x0c
    357e:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    3580:	cf 01       	movw	r24, r30
    3582:	b3 01       	movw	r22, r6
    3584:	a2 01       	movw	r20, r4
    3586:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    358a:	88 23       	and	r24, r24
    358c:	69 f0       	breq	.+26     	; 0x35a8 <f_open+0x162>
    358e:	61 c0       	rjmp	.+194    	; 0x3652 <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    3590:	88 23       	and	r24, r24
    3592:	09 f0       	breq	.+2      	; 0x3596 <f_open+0x150>
    3594:	5e c0       	rjmp	.+188    	; 0x3652 <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    3596:	f6 01       	movw	r30, r12
    3598:	83 85       	ldd	r24, Z+11	; 0x0b
    359a:	84 fd       	sbrc	r24, 4
    359c:	79 c0       	rjmp	.+242    	; 0x3690 <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    359e:	01 ff       	sbrs	r16, 1
    35a0:	7b c0       	rjmp	.+246    	; 0x3698 <f_open+0x252>
    35a2:	80 fd       	sbrc	r24, 0
    35a4:	77 c0       	rjmp	.+238    	; 0x3694 <f_open+0x24e>
    35a6:	78 c0       	rjmp	.+240    	; 0x3698 <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    35a8:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    35aa:	a9 80       	ldd	r10, Y+1	; 0x01
    35ac:	ba 80       	ldd	r11, Y+2	; 0x02
    35ae:	f5 01       	movw	r30, r10
    35b0:	86 a5       	lds	r24, 0x66
    35b2:	97 a5       	lds	r25, 0x67
    35b4:	a0 a9       	sts	0x40, r26
    35b6:	b1 a9       	sts	0x41, r27
    35b8:	f7 01       	movw	r30, r14
    35ba:	82 8f       	std	Z+26, r24	; 0x1a
    35bc:	93 8f       	std	Z+27, r25	; 0x1b
    35be:	a4 8f       	std	Z+28, r26	; 0x1c
    35c0:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    35c2:	d7 8e       	std	Z+31, r13	; 0x1f
    35c4:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    35c6:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    35c8:	c5 01       	movw	r24, r10
    35ca:	b6 01       	movw	r22, r12
    35cc:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    35d0:	dc 01       	movw	r26, r24
    35d2:	cb 01       	movw	r24, r22
    35d4:	f7 01       	movw	r30, r14
    35d6:	86 87       	std	Z+14, r24	; 0x0e
    35d8:	97 87       	std	Z+15, r25	; 0x0f
    35da:	a0 8b       	std	Z+16, r26	; 0x10
    35dc:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    35de:	f6 01       	movw	r30, r12
    35e0:	87 8d       	ldd	r24, Z+31	; 0x1f
    35e2:	90 e0       	ldi	r25, 0x00	; 0
    35e4:	a0 e0       	ldi	r26, 0x00	; 0
    35e6:	b0 e0       	ldi	r27, 0x00	; 0
    35e8:	78 2f       	mov	r23, r24
    35ea:	66 27       	eor	r22, r22
    35ec:	55 27       	eor	r21, r21
    35ee:	44 27       	eor	r20, r20
    35f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	a0 e0       	ldi	r26, 0x00	; 0
    35f6:	b0 e0       	ldi	r27, 0x00	; 0
    35f8:	dc 01       	movw	r26, r24
    35fa:	99 27       	eor	r25, r25
    35fc:	88 27       	eor	r24, r24
    35fe:	48 2b       	or	r20, r24
    3600:	59 2b       	or	r21, r25
    3602:	6a 2b       	or	r22, r26
    3604:	7b 2b       	or	r23, r27
    3606:	84 8d       	ldd	r24, Z+28	; 0x1c
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	a0 e0       	ldi	r26, 0x00	; 0
    360c:	b0 e0       	ldi	r27, 0x00	; 0
    360e:	48 2b       	or	r20, r24
    3610:	59 2b       	or	r21, r25
    3612:	6a 2b       	or	r22, r26
    3614:	7b 2b       	or	r23, r27
    3616:	95 8d       	ldd	r25, Z+29	; 0x1d
    3618:	80 e0       	ldi	r24, 0x00	; 0
    361a:	a0 e0       	ldi	r26, 0x00	; 0
    361c:	b0 e0       	ldi	r27, 0x00	; 0
    361e:	84 2b       	or	r24, r20
    3620:	95 2b       	or	r25, r21
    3622:	a6 2b       	or	r26, r22
    3624:	b7 2b       	or	r27, r23
    3626:	f7 01       	movw	r30, r14
    3628:	82 87       	std	Z+10, r24	; 0x0a
    362a:	93 87       	std	Z+11, r25	; 0x0b
    362c:	a4 87       	std	Z+12, r26	; 0x0c
    362e:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    3630:	16 82       	std	Z+6, r1	; 0x06
    3632:	17 82       	std	Z+7, r1	; 0x07
    3634:	10 86       	std	Z+8, r1	; 0x08
    3636:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    3638:	16 8a       	std	Z+22, r1	; 0x16
    363a:	17 8a       	std	Z+23, r1	; 0x17
    363c:	10 8e       	std	Z+24, r1	; 0x18
    363e:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    3640:	b1 82       	std	Z+1, r11	; 0x01
    3642:	a0 82       	st	Z, r10
    3644:	f5 01       	movw	r30, r10
    3646:	86 81       	ldd	r24, Z+6	; 0x06
    3648:	97 81       	ldd	r25, Z+7	; 0x07
    364a:	f7 01       	movw	r30, r14
    364c:	93 83       	std	Z+3, r25	; 0x03
    364e:	82 83       	std	Z+2, r24	; 0x02
    3650:	03 c0       	rjmp	.+6      	; 0x3658 <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3652:	18 2f       	mov	r17, r24
    3654:	01 c0       	rjmp	.+2      	; 0x3658 <f_open+0x212>
    3656:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    3658:	81 2f       	mov	r24, r17
    365a:	a4 96       	adiw	r28, 0x24	; 36
    365c:	0f b6       	in	r0, 0x3f	; 63
    365e:	f8 94       	cli
    3660:	de bf       	out	0x3e, r29	; 62
    3662:	0f be       	out	0x3f, r0	; 63
    3664:	cd bf       	out	0x3d, r28	; 61
    3666:	df 91       	pop	r29
    3668:	cf 91       	pop	r28
    366a:	1f 91       	pop	r17
    366c:	0f 91       	pop	r16
    366e:	ff 90       	pop	r15
    3670:	ef 90       	pop	r14
    3672:	df 90       	pop	r13
    3674:	cf 90       	pop	r12
    3676:	bf 90       	pop	r11
    3678:	af 90       	pop	r10
    367a:	9f 90       	pop	r9
    367c:	8f 90       	pop	r8
    367e:	7f 90       	pop	r7
    3680:	6f 90       	pop	r6
    3682:	5f 90       	pop	r5
    3684:	4f 90       	pop	r4
    3686:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    3688:	87 e0       	ldi	r24, 0x07	; 7
    368a:	e3 cf       	rjmp	.-58     	; 0x3652 <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    368c:	88 e0       	ldi	r24, 0x08	; 8
    368e:	e1 cf       	rjmp	.-62     	; 0x3652 <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    3690:	84 e0       	ldi	r24, 0x04	; 4
    3692:	df cf       	rjmp	.-66     	; 0x3652 <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    3694:	87 e0       	ldi	r24, 0x07	; 7
    3696:	dd cf       	rjmp	.-70     	; 0x3652 <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    3698:	03 ff       	sbrs	r16, 3
    369a:	87 cf       	rjmp	.-242    	; 0x35aa <f_open+0x164>
    369c:	85 cf       	rjmp	.-246    	; 0x35a8 <f_open+0x162>

0000369e <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    369e:	2f 92       	push	r2
    36a0:	3f 92       	push	r3
    36a2:	4f 92       	push	r4
    36a4:	5f 92       	push	r5
    36a6:	6f 92       	push	r6
    36a8:	7f 92       	push	r7
    36aa:	8f 92       	push	r8
    36ac:	9f 92       	push	r9
    36ae:	af 92       	push	r10
    36b0:	bf 92       	push	r11
    36b2:	cf 92       	push	r12
    36b4:	df 92       	push	r13
    36b6:	ef 92       	push	r14
    36b8:	ff 92       	push	r15
    36ba:	0f 93       	push	r16
    36bc:	1f 93       	push	r17
    36be:	cf 93       	push	r28
    36c0:	df 93       	push	r29
    36c2:	cd b7       	in	r28, 0x3d	; 61
    36c4:	de b7       	in	r29, 0x3e	; 62
    36c6:	29 97       	sbiw	r28, 0x09	; 9
    36c8:	0f b6       	in	r0, 0x3f	; 63
    36ca:	f8 94       	cli
    36cc:	de bf       	out	0x3e, r29	; 62
    36ce:	0f be       	out	0x3f, r0	; 63
    36d0:	cd bf       	out	0x3d, r28	; 61
    36d2:	9c 83       	std	Y+4, r25	; 0x04
    36d4:	8b 83       	std	Y+3, r24	; 0x03
    36d6:	a6 2e       	mov	r10, r22
    36d8:	97 2e       	mov	r9, r23
    36da:	c2 2e       	mov	r12, r18
    36dc:	f3 2e       	mov	r15, r19
    36de:	e4 2e       	mov	r14, r20
    36e0:	d5 2e       	mov	r13, r21
    36e2:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    36e4:	d8 01       	movw	r26, r16
    36e6:	1d 92       	st	X+, r1
    36e8:	1d 92       	st	X+, r1
    36ea:	1d 92       	st	X+, r1
    36ec:	1c 92       	st	X, r1
    36ee:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    36f0:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
    36f4:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    36f6:	88 23       	and	r24, r24
    36f8:	09 f0       	breq	.+2      	; 0x36fc <f_read+0x5e>
    36fa:	e1 c1       	rjmp	.+962    	; 0x3abe <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    36fc:	eb 81       	ldd	r30, Y+3	; 0x03
    36fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3700:	84 81       	ldd	r24, Z+4	; 0x04
    3702:	88 23       	and	r24, r24
    3704:	0c f4       	brge	.+2      	; 0x3708 <f_read+0x6a>
    3706:	d3 c1       	rjmp	.+934    	; 0x3aae <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3708:	80 ff       	sbrs	r24, 0
    370a:	d5 c1       	rjmp	.+938    	; 0x3ab6 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    370c:	42 85       	ldd	r20, Z+10	; 0x0a
    370e:	53 85       	ldd	r21, Z+11	; 0x0b
    3710:	64 85       	ldd	r22, Z+12	; 0x0c
    3712:	75 85       	ldd	r23, Z+13	; 0x0d
    3714:	86 81       	ldd	r24, Z+6	; 0x06
    3716:	97 81       	ldd	r25, Z+7	; 0x07
    3718:	a0 85       	ldd	r26, Z+8	; 0x08
    371a:	b1 85       	ldd	r27, Z+9	; 0x09
    371c:	48 1b       	sub	r20, r24
    371e:	59 0b       	sbc	r21, r25
    3720:	6a 0b       	sbc	r22, r26
    3722:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3724:	4c 2c       	mov	r4, r12
    3726:	5f 2c       	mov	r5, r15
    3728:	6e 2c       	mov	r6, r14
    372a:	7d 2c       	mov	r7, r13
    372c:	44 15       	cp	r20, r4
    372e:	55 05       	cpc	r21, r5
    3730:	66 05       	cpc	r22, r6
    3732:	77 05       	cpc	r23, r7
    3734:	10 f4       	brcc	.+4      	; 0x373a <f_read+0x9c>
    3736:	2a 01       	movw	r4, r20
    3738:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    373a:	41 14       	cp	r4, r1
    373c:	51 04       	cpc	r5, r1
    373e:	61 04       	cpc	r6, r1
    3740:	71 04       	cpc	r7, r1
    3742:	09 f4       	brne	.+2      	; 0x3746 <f_read+0xa8>
    3744:	bc c1       	rjmp	.+888    	; 0x3abe <f_read+0x420>
    3746:	a9 82       	std	Y+1, r10	; 0x01
    3748:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    374a:	0b 81       	ldd	r16, Y+3	; 0x03
    374c:	1c 81       	ldd	r17, Y+4	; 0x04
    374e:	00 5e       	subi	r16, 0xE0	; 224
    3750:	1f 4f       	sbci	r17, 0xFF	; 255
    3752:	1e 83       	std	Y+6, r17	; 0x06
    3754:	0d 83       	std	Y+5, r16	; 0x05
    3756:	bf 82       	std	Y+7, r11	; 0x07
    3758:	2b 81       	ldd	r18, Y+3	; 0x03
    375a:	3c 81       	ldd	r19, Y+4	; 0x04
    375c:	39 87       	std	Y+9, r19	; 0x09
    375e:	28 87       	std	Y+8, r18	; 0x08
    3760:	3c 82       	std	Y+4, r3	; 0x04
    3762:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    3764:	a8 85       	ldd	r26, Y+8	; 0x08
    3766:	b9 85       	ldd	r27, Y+9	; 0x09
    3768:	16 96       	adiw	r26, 0x06	; 6
    376a:	4d 91       	ld	r20, X+
    376c:	5d 91       	ld	r21, X+
    376e:	6d 91       	ld	r22, X+
    3770:	7c 91       	ld	r23, X
    3772:	19 97       	sbiw	r26, 0x09	; 9
    3774:	db 01       	movw	r26, r22
    3776:	ca 01       	movw	r24, r20
    3778:	91 70       	andi	r25, 0x01	; 1
    377a:	a0 70       	andi	r26, 0x00	; 0
    377c:	b0 70       	andi	r27, 0x00	; 0
    377e:	00 97       	sbiw	r24, 0x00	; 0
    3780:	a1 05       	cpc	r26, r1
    3782:	b1 05       	cpc	r27, r1
    3784:	09 f0       	breq	.+2      	; 0x3788 <f_read+0xea>
    3786:	3f c1       	rjmp	.+638    	; 0x3a06 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3788:	a8 85       	ldd	r26, Y+8	; 0x08
    378a:	b9 85       	ldd	r27, Y+9	; 0x09
    378c:	ed 91       	ld	r30, X+
    378e:	fc 91       	ld	r31, X
    3790:	db 01       	movw	r26, r22
    3792:	ca 01       	movw	r24, r20
    3794:	07 2e       	mov	r0, r23
    3796:	79 e0       	ldi	r23, 0x09	; 9
    3798:	b6 95       	lsr	r27
    379a:	a7 95       	ror	r26
    379c:	97 95       	ror	r25
    379e:	87 95       	ror	r24
    37a0:	7a 95       	dec	r23
    37a2:	d1 f7       	brne	.-12     	; 0x3798 <f_read+0xfa>
    37a4:	70 2d       	mov	r23, r0
    37a6:	02 81       	ldd	r16, Z+2	; 0x02
    37a8:	01 50       	subi	r16, 0x01	; 1
    37aa:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    37ac:	09 f0       	breq	.+2      	; 0x37b0 <f_read+0x112>
    37ae:	44 c0       	rjmp	.+136    	; 0x3838 <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    37b0:	41 15       	cp	r20, r1
    37b2:	51 05       	cpc	r21, r1
    37b4:	61 05       	cpc	r22, r1
    37b6:	71 05       	cpc	r23, r1
    37b8:	39 f4       	brne	.+14     	; 0x37c8 <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    37ba:	e8 85       	ldd	r30, Y+8	; 0x08
    37bc:	f9 85       	ldd	r31, Y+9	; 0x09
    37be:	86 85       	ldd	r24, Z+14	; 0x0e
    37c0:	97 85       	ldd	r25, Z+15	; 0x0f
    37c2:	a0 89       	ldd	r26, Z+16	; 0x10
    37c4:	b1 89       	ldd	r27, Z+17	; 0x11
    37c6:	0d c0       	rjmp	.+26     	; 0x37e2 <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    37c8:	a8 85       	ldd	r26, Y+8	; 0x08
    37ca:	b9 85       	ldd	r27, Y+9	; 0x09
    37cc:	52 96       	adiw	r26, 0x12	; 18
    37ce:	4d 91       	ld	r20, X+
    37d0:	5d 91       	ld	r21, X+
    37d2:	6d 91       	ld	r22, X+
    37d4:	7c 91       	ld	r23, X
    37d6:	55 97       	sbiw	r26, 0x15	; 21
    37d8:	cf 01       	movw	r24, r30
    37da:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    37de:	dc 01       	movw	r26, r24
    37e0:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    37e2:	82 30       	cpi	r24, 0x02	; 2
    37e4:	91 05       	cpc	r25, r1
    37e6:	a1 05       	cpc	r26, r1
    37e8:	b1 05       	cpc	r27, r1
    37ea:	48 f4       	brcc	.+18     	; 0x37fe <f_read+0x160>
    37ec:	e8 85       	ldd	r30, Y+8	; 0x08
    37ee:	f9 85       	ldd	r31, Y+9	; 0x09
    37f0:	84 81       	ldd	r24, Z+4	; 0x04
    37f2:	80 68       	ori	r24, 0x80	; 128
    37f4:	84 83       	std	Z+4, r24	; 0x04
    37f6:	bb 24       	eor	r11, r11
    37f8:	68 94       	set
    37fa:	b1 f8       	bld	r11, 1
    37fc:	60 c1       	rjmp	.+704    	; 0x3abe <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    37fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3800:	ff ef       	ldi	r31, 0xFF	; 255
    3802:	9f 07       	cpc	r25, r31
    3804:	ff ef       	ldi	r31, 0xFF	; 255
    3806:	af 07       	cpc	r26, r31
    3808:	ff ef       	ldi	r31, 0xFF	; 255
    380a:	bf 07       	cpc	r27, r31
    380c:	79 f4       	brne	.+30     	; 0x382c <f_read+0x18e>
    380e:	08 85       	ldd	r16, Y+8	; 0x08
    3810:	19 85       	ldd	r17, Y+9	; 0x09
    3812:	1c 83       	std	Y+4, r17	; 0x04
    3814:	0b 83       	std	Y+3, r16	; 0x03
    3816:	d8 01       	movw	r26, r16
    3818:	14 96       	adiw	r26, 0x04	; 4
    381a:	8c 91       	ld	r24, X
    381c:	14 97       	sbiw	r26, 0x04	; 4
    381e:	80 68       	ori	r24, 0x80	; 128
    3820:	14 96       	adiw	r26, 0x04	; 4
    3822:	8c 93       	st	X, r24
    3824:	14 97       	sbiw	r26, 0x04	; 4
    3826:	bb 24       	eor	r11, r11
    3828:	b3 94       	inc	r11
    382a:	49 c1       	rjmp	.+658    	; 0x3abe <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    382c:	e8 85       	ldd	r30, Y+8	; 0x08
    382e:	f9 85       	ldd	r31, Y+9	; 0x09
    3830:	82 8b       	std	Z+18, r24	; 0x12
    3832:	93 8b       	std	Z+19, r25	; 0x13
    3834:	a4 8b       	std	Z+20, r26	; 0x14
    3836:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3838:	a8 85       	ldd	r26, Y+8	; 0x08
    383a:	b9 85       	ldd	r27, Y+9	; 0x09
    383c:	2d 90       	ld	r2, X+
    383e:	3c 90       	ld	r3, X
    3840:	11 97       	sbiw	r26, 0x01	; 1
    3842:	52 96       	adiw	r26, 0x12	; 18
    3844:	4d 91       	ld	r20, X+
    3846:	5d 91       	ld	r21, X+
    3848:	6d 91       	ld	r22, X+
    384a:	7c 91       	ld	r23, X
    384c:	55 97       	sbiw	r26, 0x15	; 21
    384e:	c1 01       	movw	r24, r2
    3850:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    3854:	dc 01       	movw	r26, r24
    3856:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3858:	00 97       	sbiw	r24, 0x00	; 0
    385a:	a1 05       	cpc	r26, r1
    385c:	b1 05       	cpc	r27, r1
    385e:	49 f4       	brne	.+18     	; 0x3872 <f_read+0x1d4>
    3860:	e8 85       	ldd	r30, Y+8	; 0x08
    3862:	f9 85       	ldd	r31, Y+9	; 0x09
    3864:	84 81       	ldd	r24, Z+4	; 0x04
    3866:	80 68       	ori	r24, 0x80	; 128
    3868:	84 83       	std	Z+4, r24	; 0x04
    386a:	bb 24       	eor	r11, r11
    386c:	68 94       	set
    386e:	b1 f8       	bld	r11, 1
    3870:	26 c1       	rjmp	.+588    	; 0x3abe <f_read+0x420>
			sect += csect;
    3872:	40 2f       	mov	r20, r16
    3874:	50 e0       	ldi	r21, 0x00	; 0
    3876:	60 e0       	ldi	r22, 0x00	; 0
    3878:	70 e0       	ldi	r23, 0x00	; 0
    387a:	4c 01       	movw	r8, r24
    387c:	5d 01       	movw	r10, r26
    387e:	84 0e       	add	r8, r20
    3880:	95 1e       	adc	r9, r21
    3882:	a6 1e       	adc	r10, r22
    3884:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3886:	73 01       	movw	r14, r6
    3888:	62 01       	movw	r12, r4
    388a:	0b 2e       	mov	r0, r27
    388c:	b9 e0       	ldi	r27, 0x09	; 9
    388e:	f6 94       	lsr	r15
    3890:	e7 94       	ror	r14
    3892:	d7 94       	ror	r13
    3894:	c7 94       	ror	r12
    3896:	ba 95       	dec	r27
    3898:	d1 f7       	brne	.-12     	; 0x388e <f_read+0x1f0>
    389a:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    389c:	c1 14       	cp	r12, r1
    389e:	d1 04       	cpc	r13, r1
    38a0:	e1 04       	cpc	r14, r1
    38a2:	f1 04       	cpc	r15, r1
    38a4:	09 f4       	brne	.+2      	; 0x38a8 <f_read+0x20a>
    38a6:	60 c0       	rjmp	.+192    	; 0x3968 <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    38a8:	d1 01       	movw	r26, r2
    38aa:	12 96       	adiw	r26, 0x02	; 2
    38ac:	2c 91       	ld	r18, X
    38ae:	d7 01       	movw	r26, r14
    38b0:	c6 01       	movw	r24, r12
    38b2:	84 0f       	add	r24, r20
    38b4:	95 1f       	adc	r25, r21
    38b6:	a6 1f       	adc	r26, r22
    38b8:	b7 1f       	adc	r27, r23
    38ba:	42 2f       	mov	r20, r18
    38bc:	50 e0       	ldi	r21, 0x00	; 0
    38be:	60 e0       	ldi	r22, 0x00	; 0
    38c0:	70 e0       	ldi	r23, 0x00	; 0
    38c2:	48 17       	cp	r20, r24
    38c4:	59 07       	cpc	r21, r25
    38c6:	6a 07       	cpc	r22, r26
    38c8:	7b 07       	cpc	r23, r27
    38ca:	48 f4       	brcc	.+18     	; 0x38de <f_read+0x240>
					cc = fp->fs->csize - csect;
    38cc:	82 2f       	mov	r24, r18
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	80 1b       	sub	r24, r16
    38d2:	91 09       	sbc	r25, r1
    38d4:	6c 01       	movw	r12, r24
    38d6:	ee 24       	eor	r14, r14
    38d8:	d7 fc       	sbrc	r13, 7
    38da:	e0 94       	com	r14
    38dc:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    38de:	f1 01       	movw	r30, r2
    38e0:	81 81       	ldd	r24, Z+1	; 0x01
    38e2:	69 81       	ldd	r22, Y+1	; 0x01
    38e4:	7a 81       	ldd	r23, Y+2	; 0x02
    38e6:	a5 01       	movw	r20, r10
    38e8:	94 01       	movw	r18, r8
    38ea:	0c 2d       	mov	r16, r12
    38ec:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    38f0:	88 23       	and	r24, r24
    38f2:	79 f0       	breq	.+30     	; 0x3912 <f_read+0x274>
    38f4:	08 85       	ldd	r16, Y+8	; 0x08
    38f6:	19 85       	ldd	r17, Y+9	; 0x09
    38f8:	1c 83       	std	Y+4, r17	; 0x04
    38fa:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    38fc:	d8 01       	movw	r26, r16
    38fe:	14 96       	adiw	r26, 0x04	; 4
    3900:	8c 91       	ld	r24, X
    3902:	14 97       	sbiw	r26, 0x04	; 4
    3904:	80 68       	ori	r24, 0x80	; 128
    3906:	14 96       	adiw	r26, 0x04	; 4
    3908:	8c 93       	st	X, r24
    390a:	14 97       	sbiw	r26, 0x04	; 4
    390c:	bb 24       	eor	r11, r11
    390e:	b3 94       	inc	r11
    3910:	d6 c0       	rjmp	.+428    	; 0x3abe <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    3912:	e8 85       	ldd	r30, Y+8	; 0x08
    3914:	f9 85       	ldd	r31, Y+9	; 0x09
    3916:	84 81       	ldd	r24, Z+4	; 0x04
    3918:	86 ff       	sbrs	r24, 6
    391a:	1c c0       	rjmp	.+56     	; 0x3954 <f_read+0x2b6>
    391c:	86 89       	ldd	r24, Z+22	; 0x16
    391e:	97 89       	ldd	r25, Z+23	; 0x17
    3920:	a0 8d       	ldd	r26, Z+24	; 0x18
    3922:	b1 8d       	ldd	r27, Z+25	; 0x19
    3924:	88 19       	sub	r24, r8
    3926:	99 09       	sbc	r25, r9
    3928:	aa 09       	sbc	r26, r10
    392a:	bb 09       	sbc	r27, r11
    392c:	8c 15       	cp	r24, r12
    392e:	9d 05       	cpc	r25, r13
    3930:	ae 05       	cpc	r26, r14
    3932:	bf 05       	cpc	r27, r15
    3934:	78 f4       	brcc	.+30     	; 0x3954 <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    3936:	98 2f       	mov	r25, r24
    3938:	88 27       	eor	r24, r24
    393a:	99 0f       	add	r25, r25
    393c:	09 81       	ldd	r16, Y+1	; 0x01
    393e:	1a 81       	ldd	r17, Y+2	; 0x02
    3940:	80 0f       	add	r24, r16
    3942:	91 1f       	adc	r25, r17
    3944:	6d 81       	ldd	r22, Y+5	; 0x05
    3946:	7e 81       	ldd	r23, Y+6	; 0x06
    3948:	20 e0       	ldi	r18, 0x00	; 0
    394a:	32 e0       	ldi	r19, 0x02	; 2
    394c:	40 e0       	ldi	r20, 0x00	; 0
    394e:	50 e0       	ldi	r21, 0x00	; 0
    3950:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    3954:	0b 2e       	mov	r0, r27
    3956:	b9 e0       	ldi	r27, 0x09	; 9
    3958:	cc 0c       	add	r12, r12
    395a:	dd 1c       	adc	r13, r13
    395c:	ee 1c       	adc	r14, r14
    395e:	ff 1c       	adc	r15, r15
    3960:	ba 95       	dec	r27
    3962:	d1 f7       	brne	.-12     	; 0x3958 <f_read+0x2ba>
    3964:	b0 2d       	mov	r27, r0
				continue;
    3966:	79 c0       	rjmp	.+242    	; 0x3a5a <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    3968:	a8 85       	ldd	r26, Y+8	; 0x08
    396a:	b9 85       	ldd	r27, Y+9	; 0x09
    396c:	56 96       	adiw	r26, 0x16	; 22
    396e:	0d 91       	ld	r16, X+
    3970:	1d 91       	ld	r17, X+
    3972:	2d 91       	ld	r18, X+
    3974:	3c 91       	ld	r19, X
    3976:	59 97       	sbiw	r26, 0x19	; 25
    3978:	08 15       	cp	r16, r8
    397a:	19 05       	cpc	r17, r9
    397c:	2a 05       	cpc	r18, r10
    397e:	3b 05       	cpc	r19, r11
    3980:	d1 f1       	breq	.+116    	; 0x39f6 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3982:	14 96       	adiw	r26, 0x04	; 4
    3984:	8c 91       	ld	r24, X
    3986:	14 97       	sbiw	r26, 0x04	; 4
    3988:	86 ff       	sbrs	r24, 6
    398a:	1f c0       	rjmp	.+62     	; 0x39ca <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    398c:	f1 01       	movw	r30, r2
    398e:	81 81       	ldd	r24, Z+1	; 0x01
    3990:	6d 81       	ldd	r22, Y+5	; 0x05
    3992:	7e 81       	ldd	r23, Y+6	; 0x06
    3994:	a9 01       	movw	r20, r18
    3996:	98 01       	movw	r18, r16
    3998:	01 e0       	ldi	r16, 0x01	; 1
    399a:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    399e:	88 23       	and	r24, r24
    39a0:	79 f0       	breq	.+30     	; 0x39c0 <f_read+0x322>
    39a2:	08 85       	ldd	r16, Y+8	; 0x08
    39a4:	19 85       	ldd	r17, Y+9	; 0x09
    39a6:	1c 83       	std	Y+4, r17	; 0x04
    39a8:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    39aa:	d8 01       	movw	r26, r16
    39ac:	14 96       	adiw	r26, 0x04	; 4
    39ae:	8c 91       	ld	r24, X
    39b0:	14 97       	sbiw	r26, 0x04	; 4
    39b2:	80 68       	ori	r24, 0x80	; 128
    39b4:	14 96       	adiw	r26, 0x04	; 4
    39b6:	8c 93       	st	X, r24
    39b8:	14 97       	sbiw	r26, 0x04	; 4
    39ba:	bb 24       	eor	r11, r11
    39bc:	b3 94       	inc	r11
    39be:	7f c0       	rjmp	.+254    	; 0x3abe <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    39c0:	e8 85       	ldd	r30, Y+8	; 0x08
    39c2:	f9 85       	ldd	r31, Y+9	; 0x09
    39c4:	84 81       	ldd	r24, Z+4	; 0x04
    39c6:	8f 7b       	andi	r24, 0xBF	; 191
    39c8:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    39ca:	a8 85       	ldd	r26, Y+8	; 0x08
    39cc:	b9 85       	ldd	r27, Y+9	; 0x09
    39ce:	ed 91       	ld	r30, X+
    39d0:	fc 91       	ld	r31, X
    39d2:	81 81       	ldd	r24, Z+1	; 0x01
    39d4:	6d 81       	ldd	r22, Y+5	; 0x05
    39d6:	7e 81       	ldd	r23, Y+6	; 0x06
    39d8:	a5 01       	movw	r20, r10
    39da:	94 01       	movw	r18, r8
    39dc:	01 e0       	ldi	r16, 0x01	; 1
    39de:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    39e2:	88 23       	and	r24, r24
    39e4:	41 f0       	breq	.+16     	; 0x39f6 <f_read+0x358>
    39e6:	e8 85       	ldd	r30, Y+8	; 0x08
    39e8:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    39ea:	84 81       	ldd	r24, Z+4	; 0x04
    39ec:	80 68       	ori	r24, 0x80	; 128
    39ee:	84 83       	std	Z+4, r24	; 0x04
    39f0:	bb 24       	eor	r11, r11
    39f2:	b3 94       	inc	r11
    39f4:	64 c0       	rjmp	.+200    	; 0x3abe <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    39f6:	a8 85       	ldd	r26, Y+8	; 0x08
    39f8:	b9 85       	ldd	r27, Y+9	; 0x09
    39fa:	56 96       	adiw	r26, 0x16	; 22
    39fc:	8d 92       	st	X+, r8
    39fe:	9d 92       	st	X+, r9
    3a00:	ad 92       	st	X+, r10
    3a02:	bc 92       	st	X, r11
    3a04:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3a06:	e8 85       	ldd	r30, Y+8	; 0x08
    3a08:	f9 85       	ldd	r31, Y+9	; 0x09
    3a0a:	46 81       	ldd	r20, Z+6	; 0x06
    3a0c:	57 81       	ldd	r21, Z+7	; 0x07
    3a0e:	60 85       	ldd	r22, Z+8	; 0x08
    3a10:	71 85       	ldd	r23, Z+9	; 0x09
    3a12:	db 01       	movw	r26, r22
    3a14:	ca 01       	movw	r24, r20
    3a16:	91 70       	andi	r25, 0x01	; 1
    3a18:	a0 70       	andi	r26, 0x00	; 0
    3a1a:	b0 70       	andi	r27, 0x00	; 0
    3a1c:	00 e0       	ldi	r16, 0x00	; 0
    3a1e:	12 e0       	ldi	r17, 0x02	; 2
    3a20:	20 e0       	ldi	r18, 0x00	; 0
    3a22:	30 e0       	ldi	r19, 0x00	; 0
    3a24:	08 1b       	sub	r16, r24
    3a26:	19 0b       	sbc	r17, r25
    3a28:	2a 0b       	sbc	r18, r26
    3a2a:	3b 0b       	sbc	r19, r27
    3a2c:	73 01       	movw	r14, r6
    3a2e:	62 01       	movw	r12, r4
    3a30:	04 15       	cp	r16, r4
    3a32:	15 05       	cpc	r17, r5
    3a34:	26 05       	cpc	r18, r6
    3a36:	37 05       	cpc	r19, r7
    3a38:	10 f4       	brcc	.+4      	; 0x3a3e <f_read+0x3a0>
    3a3a:	68 01       	movw	r12, r16
    3a3c:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3a3e:	ba 01       	movw	r22, r20
    3a40:	71 70       	andi	r23, 0x01	; 1
    3a42:	60 5e       	subi	r22, 0xE0	; 224
    3a44:	7f 4f       	sbci	r23, 0xFF	; 255
    3a46:	28 85       	ldd	r18, Y+8	; 0x08
    3a48:	39 85       	ldd	r19, Y+9	; 0x09
    3a4a:	62 0f       	add	r22, r18
    3a4c:	73 1f       	adc	r23, r19
    3a4e:	89 81       	ldd	r24, Y+1	; 0x01
    3a50:	9a 81       	ldd	r25, Y+2	; 0x02
    3a52:	a7 01       	movw	r20, r14
    3a54:	96 01       	movw	r18, r12
    3a56:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3a5a:	89 81       	ldd	r24, Y+1	; 0x01
    3a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a5e:	8c 0d       	add	r24, r12
    3a60:	9d 1d       	adc	r25, r13
    3a62:	9a 83       	std	Y+2, r25	; 0x02
    3a64:	89 83       	std	Y+1, r24	; 0x01
    3a66:	e8 85       	ldd	r30, Y+8	; 0x08
    3a68:	f9 85       	ldd	r31, Y+9	; 0x09
    3a6a:	86 81       	ldd	r24, Z+6	; 0x06
    3a6c:	97 81       	ldd	r25, Z+7	; 0x07
    3a6e:	a0 85       	ldd	r26, Z+8	; 0x08
    3a70:	b1 85       	ldd	r27, Z+9	; 0x09
    3a72:	8c 0d       	add	r24, r12
    3a74:	9d 1d       	adc	r25, r13
    3a76:	ae 1d       	adc	r26, r14
    3a78:	bf 1d       	adc	r27, r15
    3a7a:	86 83       	std	Z+6, r24	; 0x06
    3a7c:	97 83       	std	Z+7, r25	; 0x07
    3a7e:	a0 87       	std	Z+8, r26	; 0x08
    3a80:	b1 87       	std	Z+9, r27	; 0x09
    3a82:	eb 81       	ldd	r30, Y+3	; 0x03
    3a84:	fc 81       	ldd	r31, Y+4	; 0x04
    3a86:	80 81       	ld	r24, Z
    3a88:	91 81       	ldd	r25, Z+1	; 0x01
    3a8a:	a2 81       	ldd	r26, Z+2	; 0x02
    3a8c:	b3 81       	ldd	r27, Z+3	; 0x03
    3a8e:	8c 0d       	add	r24, r12
    3a90:	9d 1d       	adc	r25, r13
    3a92:	ae 1d       	adc	r26, r14
    3a94:	bf 1d       	adc	r27, r15
    3a96:	80 83       	st	Z, r24
    3a98:	91 83       	std	Z+1, r25	; 0x01
    3a9a:	a2 83       	std	Z+2, r26	; 0x02
    3a9c:	b3 83       	std	Z+3, r27	; 0x03
    3a9e:	4c 18       	sub	r4, r12
    3aa0:	5d 08       	sbc	r5, r13
    3aa2:	6e 08       	sbc	r6, r14
    3aa4:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3aa6:	09 f0       	breq	.+2      	; 0x3aaa <f_read+0x40c>
    3aa8:	5d ce       	rjmp	.-838    	; 0x3764 <f_read+0xc6>
    3aaa:	bf 80       	ldd	r11, Y+7	; 0x07
    3aac:	08 c0       	rjmp	.+16     	; 0x3abe <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3aae:	bb 24       	eor	r11, r11
    3ab0:	68 94       	set
    3ab2:	b1 f8       	bld	r11, 1
    3ab4:	04 c0       	rjmp	.+8      	; 0x3abe <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3ab6:	0f 2e       	mov	r0, r31
    3ab8:	f7 e0       	ldi	r31, 0x07	; 7
    3aba:	bf 2e       	mov	r11, r31
    3abc:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3abe:	8b 2d       	mov	r24, r11
    3ac0:	29 96       	adiw	r28, 0x09	; 9
    3ac2:	0f b6       	in	r0, 0x3f	; 63
    3ac4:	f8 94       	cli
    3ac6:	de bf       	out	0x3e, r29	; 62
    3ac8:	0f be       	out	0x3f, r0	; 63
    3aca:	cd bf       	out	0x3d, r28	; 61
    3acc:	df 91       	pop	r29
    3ace:	cf 91       	pop	r28
    3ad0:	1f 91       	pop	r17
    3ad2:	0f 91       	pop	r16
    3ad4:	ff 90       	pop	r15
    3ad6:	ef 90       	pop	r14
    3ad8:	df 90       	pop	r13
    3ada:	cf 90       	pop	r12
    3adc:	bf 90       	pop	r11
    3ade:	af 90       	pop	r10
    3ae0:	9f 90       	pop	r9
    3ae2:	8f 90       	pop	r8
    3ae4:	7f 90       	pop	r7
    3ae6:	6f 90       	pop	r6
    3ae8:	5f 90       	pop	r5
    3aea:	4f 90       	pop	r4
    3aec:	3f 90       	pop	r3
    3aee:	2f 90       	pop	r2
    3af0:	08 95       	ret

00003af2 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3af2:	2f 92       	push	r2
    3af4:	3f 92       	push	r3
    3af6:	4f 92       	push	r4
    3af8:	5f 92       	push	r5
    3afa:	6f 92       	push	r6
    3afc:	7f 92       	push	r7
    3afe:	8f 92       	push	r8
    3b00:	9f 92       	push	r9
    3b02:	af 92       	push	r10
    3b04:	bf 92       	push	r11
    3b06:	cf 92       	push	r12
    3b08:	df 92       	push	r13
    3b0a:	ef 92       	push	r14
    3b0c:	ff 92       	push	r15
    3b0e:	0f 93       	push	r16
    3b10:	1f 93       	push	r17
    3b12:	cf 93       	push	r28
    3b14:	df 93       	push	r29
    3b16:	cd b7       	in	r28, 0x3d	; 61
    3b18:	de b7       	in	r29, 0x3e	; 62
    3b1a:	29 97       	sbiw	r28, 0x09	; 9
    3b1c:	0f b6       	in	r0, 0x3f	; 63
    3b1e:	f8 94       	cli
    3b20:	de bf       	out	0x3e, r29	; 62
    3b22:	0f be       	out	0x3f, r0	; 63
    3b24:	cd bf       	out	0x3d, r28	; 61
    3b26:	2c 01       	movw	r4, r24
    3b28:	c6 2e       	mov	r12, r22
    3b2a:	f7 2e       	mov	r15, r23
    3b2c:	49 01       	movw	r8, r18
    3b2e:	5a 01       	movw	r10, r20
    3b30:	1a 83       	std	Y+2, r17	; 0x02
    3b32:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3b34:	d8 01       	movw	r26, r16
    3b36:	1d 92       	st	X+, r1
    3b38:	1d 92       	st	X+, r1
    3b3a:	1d 92       	st	X+, r1
    3b3c:	1c 92       	st	X, r1
    3b3e:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    3b40:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
    3b44:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3b46:	88 23       	and	r24, r24
    3b48:	09 f0       	breq	.+2      	; 0x3b4c <f_write+0x5a>
    3b4a:	17 c2       	rjmp	.+1070   	; 0x3f7a <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3b4c:	f2 01       	movw	r30, r4
    3b4e:	84 81       	ldd	r24, Z+4	; 0x04
    3b50:	88 23       	and	r24, r24
    3b52:	0c f4       	brge	.+2      	; 0x3b56 <f_write+0x64>
    3b54:	0f c2       	rjmp	.+1054   	; 0x3f74 <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3b56:	81 ff       	sbrs	r24, 1
    3b58:	0f c2       	rjmp	.+1054   	; 0x3f78 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3b5a:	82 85       	ldd	r24, Z+10	; 0x0a
    3b5c:	93 85       	ldd	r25, Z+11	; 0x0b
    3b5e:	a4 85       	ldd	r26, Z+12	; 0x0c
    3b60:	b5 85       	ldd	r27, Z+13	; 0x0d
    3b62:	b5 01       	movw	r22, r10
    3b64:	a4 01       	movw	r20, r8
    3b66:	48 0f       	add	r20, r24
    3b68:	59 1f       	adc	r21, r25
    3b6a:	6a 1f       	adc	r22, r26
    3b6c:	7b 1f       	adc	r23, r27
    3b6e:	48 17       	cp	r20, r24
    3b70:	59 07       	cpc	r21, r25
    3b72:	6a 07       	cpc	r22, r26
    3b74:	7b 07       	cpc	r23, r27
    3b76:	08 f4       	brcc	.+2      	; 0x3b7a <f_write+0x88>
    3b78:	e2 c1       	rjmp	.+964    	; 0x3f3e <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3b7a:	81 14       	cp	r8, r1
    3b7c:	91 04       	cpc	r9, r1
    3b7e:	a1 04       	cpc	r10, r1
    3b80:	b1 04       	cpc	r11, r1
    3b82:	09 f4       	brne	.+2      	; 0x3b86 <f_write+0x94>
    3b84:	dc c1       	rjmp	.+952    	; 0x3f3e <f_write+0x44c>
    3b86:	cb 82       	std	Y+3, r12	; 0x03
    3b88:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3b8a:	92 01       	movw	r18, r4
    3b8c:	20 5e       	subi	r18, 0xE0	; 224
    3b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    3b90:	3e 83       	std	Y+6, r19	; 0x06
    3b92:	2d 83       	std	Y+5, r18	; 0x05
    3b94:	1f 83       	std	Y+7, r17	; 0x07
    3b96:	59 86       	std	Y+9, r5	; 0x09
    3b98:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3b9a:	a8 85       	ldd	r26, Y+8	; 0x08
    3b9c:	b9 85       	ldd	r27, Y+9	; 0x09
    3b9e:	16 96       	adiw	r26, 0x06	; 6
    3ba0:	4d 91       	ld	r20, X+
    3ba2:	5d 91       	ld	r21, X+
    3ba4:	6d 91       	ld	r22, X+
    3ba6:	7c 91       	ld	r23, X
    3ba8:	19 97       	sbiw	r26, 0x09	; 9
    3baa:	db 01       	movw	r26, r22
    3bac:	ca 01       	movw	r24, r20
    3bae:	91 70       	andi	r25, 0x01	; 1
    3bb0:	a0 70       	andi	r26, 0x00	; 0
    3bb2:	b0 70       	andi	r27, 0x00	; 0
    3bb4:	00 97       	sbiw	r24, 0x00	; 0
    3bb6:	a1 05       	cpc	r26, r1
    3bb8:	b1 05       	cpc	r27, r1
    3bba:	09 f0       	breq	.+2      	; 0x3bbe <f_write+0xcc>
    3bbc:	60 c1       	rjmp	.+704    	; 0x3e7e <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3bbe:	e8 85       	ldd	r30, Y+8	; 0x08
    3bc0:	f9 85       	ldd	r31, Y+9	; 0x09
    3bc2:	20 81       	ld	r18, Z
    3bc4:	31 81       	ldd	r19, Z+1	; 0x01
    3bc6:	db 01       	movw	r26, r22
    3bc8:	ca 01       	movw	r24, r20
    3bca:	07 2e       	mov	r0, r23
    3bcc:	79 e0       	ldi	r23, 0x09	; 9
    3bce:	b6 95       	lsr	r27
    3bd0:	a7 95       	ror	r26
    3bd2:	97 95       	ror	r25
    3bd4:	87 95       	ror	r24
    3bd6:	7a 95       	dec	r23
    3bd8:	d1 f7       	brne	.-12     	; 0x3bce <f_write+0xdc>
    3bda:	70 2d       	mov	r23, r0
    3bdc:	f9 01       	movw	r30, r18
    3bde:	12 81       	ldd	r17, Z+2	; 0x02
    3be0:	11 50       	subi	r17, 0x01	; 1
    3be2:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    3be4:	09 f0       	breq	.+2      	; 0x3be8 <f_write+0xf6>
    3be6:	57 c0       	rjmp	.+174    	; 0x3c96 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3be8:	41 15       	cp	r20, r1
    3bea:	51 05       	cpc	r21, r1
    3bec:	61 05       	cpc	r22, r1
    3bee:	71 05       	cpc	r23, r1
    3bf0:	c9 f4       	brne	.+50     	; 0x3c24 <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    3bf2:	e8 85       	ldd	r30, Y+8	; 0x08
    3bf4:	f9 85       	ldd	r31, Y+9	; 0x09
    3bf6:	86 85       	ldd	r24, Z+14	; 0x0e
    3bf8:	97 85       	ldd	r25, Z+15	; 0x0f
    3bfa:	a0 89       	ldd	r26, Z+16	; 0x10
    3bfc:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3bfe:	00 97       	sbiw	r24, 0x00	; 0
    3c00:	a1 05       	cpc	r26, r1
    3c02:	b1 05       	cpc	r27, r1
    3c04:	09 f5       	brne	.+66     	; 0x3c48 <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3c06:	c9 01       	movw	r24, r18
    3c08:	40 e0       	ldi	r20, 0x00	; 0
    3c0a:	50 e0       	ldi	r21, 0x00	; 0
    3c0c:	ba 01       	movw	r22, r20
    3c0e:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    3c12:	dc 01       	movw	r26, r24
    3c14:	cb 01       	movw	r24, r22
    3c16:	e8 85       	ldd	r30, Y+8	; 0x08
    3c18:	f9 85       	ldd	r31, Y+9	; 0x09
    3c1a:	86 87       	std	Z+14, r24	; 0x0e
    3c1c:	97 87       	std	Z+15, r25	; 0x0f
    3c1e:	a0 8b       	std	Z+16, r26	; 0x10
    3c20:	b1 8b       	std	Z+17, r27	; 0x11
    3c22:	0d c0       	rjmp	.+26     	; 0x3c3e <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3c24:	a8 85       	ldd	r26, Y+8	; 0x08
    3c26:	b9 85       	ldd	r27, Y+9	; 0x09
    3c28:	52 96       	adiw	r26, 0x12	; 18
    3c2a:	4d 91       	ld	r20, X+
    3c2c:	5d 91       	ld	r21, X+
    3c2e:	6d 91       	ld	r22, X+
    3c30:	7c 91       	ld	r23, X
    3c32:	55 97       	sbiw	r26, 0x15	; 21
    3c34:	c9 01       	movw	r24, r18
    3c36:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    3c3a:	dc 01       	movw	r26, r24
    3c3c:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3c3e:	00 97       	sbiw	r24, 0x00	; 0
    3c40:	a1 05       	cpc	r26, r1
    3c42:	b1 05       	cpc	r27, r1
    3c44:	09 f4       	brne	.+2      	; 0x3c48 <f_write+0x156>
    3c46:	78 c1       	rjmp	.+752    	; 0x3f38 <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3c48:	81 30       	cpi	r24, 0x01	; 1
    3c4a:	91 05       	cpc	r25, r1
    3c4c:	a1 05       	cpc	r26, r1
    3c4e:	b1 05       	cpc	r27, r1
    3c50:	41 f4       	brne	.+16     	; 0x3c62 <f_write+0x170>
    3c52:	48 84       	ldd	r4, Y+8	; 0x08
    3c54:	59 84       	ldd	r5, Y+9	; 0x09
    3c56:	f2 01       	movw	r30, r4
    3c58:	84 81       	ldd	r24, Z+4	; 0x04
    3c5a:	80 68       	ori	r24, 0x80	; 128
    3c5c:	84 83       	std	Z+4, r24	; 0x04
    3c5e:	12 e0       	ldi	r17, 0x02	; 2
    3c60:	8c c1       	rjmp	.+792    	; 0x3f7a <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3c62:	8f 3f       	cpi	r24, 0xFF	; 255
    3c64:	ff ef       	ldi	r31, 0xFF	; 255
    3c66:	9f 07       	cpc	r25, r31
    3c68:	ff ef       	ldi	r31, 0xFF	; 255
    3c6a:	af 07       	cpc	r26, r31
    3c6c:	ff ef       	ldi	r31, 0xFF	; 255
    3c6e:	bf 07       	cpc	r27, r31
    3c70:	61 f4       	brne	.+24     	; 0x3c8a <f_write+0x198>
    3c72:	48 84       	ldd	r4, Y+8	; 0x08
    3c74:	59 84       	ldd	r5, Y+9	; 0x09
    3c76:	d2 01       	movw	r26, r4
    3c78:	14 96       	adiw	r26, 0x04	; 4
    3c7a:	8c 91       	ld	r24, X
    3c7c:	14 97       	sbiw	r26, 0x04	; 4
    3c7e:	80 68       	ori	r24, 0x80	; 128
    3c80:	14 96       	adiw	r26, 0x04	; 4
    3c82:	8c 93       	st	X, r24
    3c84:	14 97       	sbiw	r26, 0x04	; 4
    3c86:	11 e0       	ldi	r17, 0x01	; 1
    3c88:	78 c1       	rjmp	.+752    	; 0x3f7a <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3c8a:	e8 85       	ldd	r30, Y+8	; 0x08
    3c8c:	f9 85       	ldd	r31, Y+9	; 0x09
    3c8e:	82 8b       	std	Z+18, r24	; 0x12
    3c90:	93 8b       	std	Z+19, r25	; 0x13
    3c92:	a4 8b       	std	Z+20, r26	; 0x14
    3c94:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3c96:	a8 85       	ldd	r26, Y+8	; 0x08
    3c98:	b9 85       	ldd	r27, Y+9	; 0x09
    3c9a:	14 96       	adiw	r26, 0x04	; 4
    3c9c:	8c 91       	ld	r24, X
    3c9e:	14 97       	sbiw	r26, 0x04	; 4
    3ca0:	86 ff       	sbrs	r24, 6
    3ca2:	21 c0       	rjmp	.+66     	; 0x3ce6 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3ca4:	ed 91       	ld	r30, X+
    3ca6:	fc 91       	ld	r31, X
    3ca8:	11 97       	sbiw	r26, 0x01	; 1
    3caa:	56 96       	adiw	r26, 0x16	; 22
    3cac:	2d 91       	ld	r18, X+
    3cae:	3d 91       	ld	r19, X+
    3cb0:	4d 91       	ld	r20, X+
    3cb2:	5c 91       	ld	r21, X
    3cb4:	59 97       	sbiw	r26, 0x19	; 25
    3cb6:	81 81       	ldd	r24, Z+1	; 0x01
    3cb8:	6d 81       	ldd	r22, Y+5	; 0x05
    3cba:	7e 81       	ldd	r23, Y+6	; 0x06
    3cbc:	01 e0       	ldi	r16, 0x01	; 1
    3cbe:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    3cc2:	88 23       	and	r24, r24
    3cc4:	41 f0       	breq	.+16     	; 0x3cd6 <f_write+0x1e4>
    3cc6:	48 84       	ldd	r4, Y+8	; 0x08
    3cc8:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3cca:	f2 01       	movw	r30, r4
    3ccc:	84 81       	ldd	r24, Z+4	; 0x04
    3cce:	80 68       	ori	r24, 0x80	; 128
    3cd0:	84 83       	std	Z+4, r24	; 0x04
    3cd2:	11 e0       	ldi	r17, 0x01	; 1
    3cd4:	52 c1       	rjmp	.+676    	; 0x3f7a <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3cd6:	a8 85       	ldd	r26, Y+8	; 0x08
    3cd8:	b9 85       	ldd	r27, Y+9	; 0x09
    3cda:	14 96       	adiw	r26, 0x04	; 4
    3cdc:	8c 91       	ld	r24, X
    3cde:	14 97       	sbiw	r26, 0x04	; 4
    3ce0:	8f 7b       	andi	r24, 0xBF	; 191
    3ce2:	14 96       	adiw	r26, 0x04	; 4
    3ce4:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3ce6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ce8:	f9 85       	ldd	r31, Y+9	; 0x09
    3cea:	20 80       	ld	r2, Z
    3cec:	31 80       	ldd	r3, Z+1	; 0x01
    3cee:	42 89       	ldd	r20, Z+18	; 0x12
    3cf0:	53 89       	ldd	r21, Z+19	; 0x13
    3cf2:	64 89       	ldd	r22, Z+20	; 0x14
    3cf4:	75 89       	ldd	r23, Z+21	; 0x15
    3cf6:	c1 01       	movw	r24, r2
    3cf8:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    3cfc:	dc 01       	movw	r26, r24
    3cfe:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3d00:	00 97       	sbiw	r24, 0x00	; 0
    3d02:	a1 05       	cpc	r26, r1
    3d04:	b1 05       	cpc	r27, r1
    3d06:	61 f4       	brne	.+24     	; 0x3d20 <f_write+0x22e>
    3d08:	48 84       	ldd	r4, Y+8	; 0x08
    3d0a:	59 84       	ldd	r5, Y+9	; 0x09
    3d0c:	d2 01       	movw	r26, r4
    3d0e:	14 96       	adiw	r26, 0x04	; 4
    3d10:	8c 91       	ld	r24, X
    3d12:	14 97       	sbiw	r26, 0x04	; 4
    3d14:	80 68       	ori	r24, 0x80	; 128
    3d16:	14 96       	adiw	r26, 0x04	; 4
    3d18:	8c 93       	st	X, r24
    3d1a:	14 97       	sbiw	r26, 0x04	; 4
    3d1c:	12 e0       	ldi	r17, 0x02	; 2
    3d1e:	2d c1       	rjmp	.+602    	; 0x3f7a <f_write+0x488>
			sect += csect;
    3d20:	41 2f       	mov	r20, r17
    3d22:	50 e0       	ldi	r21, 0x00	; 0
    3d24:	60 e0       	ldi	r22, 0x00	; 0
    3d26:	70 e0       	ldi	r23, 0x00	; 0
    3d28:	2c 01       	movw	r4, r24
    3d2a:	3d 01       	movw	r6, r26
    3d2c:	44 0e       	add	r4, r20
    3d2e:	55 1e       	adc	r5, r21
    3d30:	66 1e       	adc	r6, r22
    3d32:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3d34:	75 01       	movw	r14, r10
    3d36:	64 01       	movw	r12, r8
    3d38:	0b 2e       	mov	r0, r27
    3d3a:	b9 e0       	ldi	r27, 0x09	; 9
    3d3c:	f6 94       	lsr	r15
    3d3e:	e7 94       	ror	r14
    3d40:	d7 94       	ror	r13
    3d42:	c7 94       	ror	r12
    3d44:	ba 95       	dec	r27
    3d46:	d1 f7       	brne	.-12     	; 0x3d3c <f_write+0x24a>
    3d48:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3d4a:	c1 14       	cp	r12, r1
    3d4c:	d1 04       	cpc	r13, r1
    3d4e:	e1 04       	cpc	r14, r1
    3d50:	f1 04       	cpc	r15, r1
    3d52:	09 f4       	brne	.+2      	; 0x3d56 <f_write+0x264>
    3d54:	60 c0       	rjmp	.+192    	; 0x3e16 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3d56:	f1 01       	movw	r30, r2
    3d58:	22 81       	ldd	r18, Z+2	; 0x02
    3d5a:	d7 01       	movw	r26, r14
    3d5c:	c6 01       	movw	r24, r12
    3d5e:	84 0f       	add	r24, r20
    3d60:	95 1f       	adc	r25, r21
    3d62:	a6 1f       	adc	r26, r22
    3d64:	b7 1f       	adc	r27, r23
    3d66:	42 2f       	mov	r20, r18
    3d68:	50 e0       	ldi	r21, 0x00	; 0
    3d6a:	60 e0       	ldi	r22, 0x00	; 0
    3d6c:	70 e0       	ldi	r23, 0x00	; 0
    3d6e:	48 17       	cp	r20, r24
    3d70:	59 07       	cpc	r21, r25
    3d72:	6a 07       	cpc	r22, r26
    3d74:	7b 07       	cpc	r23, r27
    3d76:	48 f4       	brcc	.+18     	; 0x3d8a <f_write+0x298>
					cc = fp->fs->csize - csect;
    3d78:	82 2f       	mov	r24, r18
    3d7a:	90 e0       	ldi	r25, 0x00	; 0
    3d7c:	81 1b       	sub	r24, r17
    3d7e:	91 09       	sbc	r25, r1
    3d80:	6c 01       	movw	r12, r24
    3d82:	ee 24       	eor	r14, r14
    3d84:	d7 fc       	sbrc	r13, 7
    3d86:	e0 94       	com	r14
    3d88:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3d8a:	d1 01       	movw	r26, r2
    3d8c:	11 96       	adiw	r26, 0x01	; 1
    3d8e:	8c 91       	ld	r24, X
    3d90:	6b 81       	ldd	r22, Y+3	; 0x03
    3d92:	7c 81       	ldd	r23, Y+4	; 0x04
    3d94:	a3 01       	movw	r20, r6
    3d96:	92 01       	movw	r18, r4
    3d98:	0c 2d       	mov	r16, r12
    3d9a:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    3d9e:	88 23       	and	r24, r24
    3da0:	41 f0       	breq	.+16     	; 0x3db2 <f_write+0x2c0>
    3da2:	48 84       	ldd	r4, Y+8	; 0x08
    3da4:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3da6:	f2 01       	movw	r30, r4
    3da8:	84 81       	ldd	r24, Z+4	; 0x04
    3daa:	80 68       	ori	r24, 0x80	; 128
    3dac:	84 83       	std	Z+4, r24	; 0x04
    3dae:	11 e0       	ldi	r17, 0x01	; 1
    3db0:	e4 c0       	rjmp	.+456    	; 0x3f7a <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3db2:	e8 85       	ldd	r30, Y+8	; 0x08
    3db4:	f9 85       	ldd	r31, Y+9	; 0x09
    3db6:	86 89       	ldd	r24, Z+22	; 0x16
    3db8:	97 89       	ldd	r25, Z+23	; 0x17
    3dba:	a0 8d       	ldd	r26, Z+24	; 0x18
    3dbc:	b1 8d       	ldd	r27, Z+25	; 0x19
    3dbe:	84 19       	sub	r24, r4
    3dc0:	95 09       	sbc	r25, r5
    3dc2:	a6 09       	sbc	r26, r6
    3dc4:	b7 09       	sbc	r27, r7
    3dc6:	8c 15       	cp	r24, r12
    3dc8:	9d 05       	cpc	r25, r13
    3dca:	ae 05       	cpc	r26, r14
    3dcc:	bf 05       	cpc	r27, r15
    3dce:	c8 f4       	brcc	.+50     	; 0x3e02 <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3dd0:	bc 01       	movw	r22, r24
    3dd2:	76 2f       	mov	r23, r22
    3dd4:	66 27       	eor	r22, r22
    3dd6:	77 0f       	add	r23, r23
    3dd8:	0b 81       	ldd	r16, Y+3	; 0x03
    3dda:	1c 81       	ldd	r17, Y+4	; 0x04
    3ddc:	60 0f       	add	r22, r16
    3dde:	71 1f       	adc	r23, r17
    3de0:	8d 81       	ldd	r24, Y+5	; 0x05
    3de2:	9e 81       	ldd	r25, Y+6	; 0x06
    3de4:	20 e0       	ldi	r18, 0x00	; 0
    3de6:	32 e0       	ldi	r19, 0x02	; 2
    3de8:	40 e0       	ldi	r20, 0x00	; 0
    3dea:	50 e0       	ldi	r21, 0x00	; 0
    3dec:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3df0:	a8 85       	ldd	r26, Y+8	; 0x08
    3df2:	b9 85       	ldd	r27, Y+9	; 0x09
    3df4:	14 96       	adiw	r26, 0x04	; 4
    3df6:	8c 91       	ld	r24, X
    3df8:	14 97       	sbiw	r26, 0x04	; 4
    3dfa:	8f 7b       	andi	r24, 0xBF	; 191
    3dfc:	14 96       	adiw	r26, 0x04	; 4
    3dfe:	8c 93       	st	X, r24
    3e00:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3e02:	0b 2e       	mov	r0, r27
    3e04:	b9 e0       	ldi	r27, 0x09	; 9
    3e06:	cc 0c       	add	r12, r12
    3e08:	dd 1c       	adc	r13, r13
    3e0a:	ee 1c       	adc	r14, r14
    3e0c:	ff 1c       	adc	r15, r15
    3e0e:	ba 95       	dec	r27
    3e10:	d1 f7       	brne	.-12     	; 0x3e06 <f_write+0x314>
    3e12:	b0 2d       	mov	r27, r0
				continue;
    3e14:	65 c0       	rjmp	.+202    	; 0x3ee0 <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3e16:	e8 85       	ldd	r30, Y+8	; 0x08
    3e18:	f9 85       	ldd	r31, Y+9	; 0x09
    3e1a:	86 89       	ldd	r24, Z+22	; 0x16
    3e1c:	97 89       	ldd	r25, Z+23	; 0x17
    3e1e:	a0 8d       	ldd	r26, Z+24	; 0x18
    3e20:	b1 8d       	ldd	r27, Z+25	; 0x19
    3e22:	84 15       	cp	r24, r4
    3e24:	95 05       	cpc	r25, r5
    3e26:	a6 05       	cpc	r26, r6
    3e28:	b7 05       	cpc	r27, r7
    3e2a:	09 f1       	breq	.+66     	; 0x3e6e <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3e2c:	86 81       	ldd	r24, Z+6	; 0x06
    3e2e:	97 81       	ldd	r25, Z+7	; 0x07
    3e30:	a0 85       	ldd	r26, Z+8	; 0x08
    3e32:	b1 85       	ldd	r27, Z+9	; 0x09
    3e34:	42 85       	ldd	r20, Z+10	; 0x0a
    3e36:	53 85       	ldd	r21, Z+11	; 0x0b
    3e38:	64 85       	ldd	r22, Z+12	; 0x0c
    3e3a:	75 85       	ldd	r23, Z+13	; 0x0d
    3e3c:	84 17       	cp	r24, r20
    3e3e:	95 07       	cpc	r25, r21
    3e40:	a6 07       	cpc	r26, r22
    3e42:	b7 07       	cpc	r27, r23
    3e44:	a0 f4       	brcc	.+40     	; 0x3e6e <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3e46:	d1 01       	movw	r26, r2
    3e48:	11 96       	adiw	r26, 0x01	; 1
    3e4a:	8c 91       	ld	r24, X
    3e4c:	6d 81       	ldd	r22, Y+5	; 0x05
    3e4e:	7e 81       	ldd	r23, Y+6	; 0x06
    3e50:	a3 01       	movw	r20, r6
    3e52:	92 01       	movw	r18, r4
    3e54:	01 e0       	ldi	r16, 0x01	; 1
    3e56:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3e5a:	88 23       	and	r24, r24
    3e5c:	41 f0       	breq	.+16     	; 0x3e6e <f_write+0x37c>
    3e5e:	48 84       	ldd	r4, Y+8	; 0x08
    3e60:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    3e62:	f2 01       	movw	r30, r4
    3e64:	84 81       	ldd	r24, Z+4	; 0x04
    3e66:	80 68       	ori	r24, 0x80	; 128
    3e68:	84 83       	std	Z+4, r24	; 0x04
    3e6a:	11 e0       	ldi	r17, 0x01	; 1
    3e6c:	86 c0       	rjmp	.+268    	; 0x3f7a <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3e6e:	a8 85       	ldd	r26, Y+8	; 0x08
    3e70:	b9 85       	ldd	r27, Y+9	; 0x09
    3e72:	56 96       	adiw	r26, 0x16	; 22
    3e74:	4d 92       	st	X+, r4
    3e76:	5d 92       	st	X+, r5
    3e78:	6d 92       	st	X+, r6
    3e7a:	7c 92       	st	X, r7
    3e7c:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3e7e:	e8 85       	ldd	r30, Y+8	; 0x08
    3e80:	f9 85       	ldd	r31, Y+9	; 0x09
    3e82:	46 81       	ldd	r20, Z+6	; 0x06
    3e84:	57 81       	ldd	r21, Z+7	; 0x07
    3e86:	60 85       	ldd	r22, Z+8	; 0x08
    3e88:	71 85       	ldd	r23, Z+9	; 0x09
    3e8a:	db 01       	movw	r26, r22
    3e8c:	ca 01       	movw	r24, r20
    3e8e:	91 70       	andi	r25, 0x01	; 1
    3e90:	a0 70       	andi	r26, 0x00	; 0
    3e92:	b0 70       	andi	r27, 0x00	; 0
    3e94:	00 e0       	ldi	r16, 0x00	; 0
    3e96:	12 e0       	ldi	r17, 0x02	; 2
    3e98:	20 e0       	ldi	r18, 0x00	; 0
    3e9a:	30 e0       	ldi	r19, 0x00	; 0
    3e9c:	08 1b       	sub	r16, r24
    3e9e:	19 0b       	sbc	r17, r25
    3ea0:	2a 0b       	sbc	r18, r26
    3ea2:	3b 0b       	sbc	r19, r27
    3ea4:	75 01       	movw	r14, r10
    3ea6:	64 01       	movw	r12, r8
    3ea8:	08 15       	cp	r16, r8
    3eaa:	19 05       	cpc	r17, r9
    3eac:	2a 05       	cpc	r18, r10
    3eae:	3b 05       	cpc	r19, r11
    3eb0:	10 f4       	brcc	.+4      	; 0x3eb6 <f_write+0x3c4>
    3eb2:	68 01       	movw	r12, r16
    3eb4:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3eb6:	ca 01       	movw	r24, r20
    3eb8:	91 70       	andi	r25, 0x01	; 1
    3eba:	80 96       	adiw	r24, 0x20	; 32
    3ebc:	28 85       	ldd	r18, Y+8	; 0x08
    3ebe:	39 85       	ldd	r19, Y+9	; 0x09
    3ec0:	82 0f       	add	r24, r18
    3ec2:	93 1f       	adc	r25, r19
    3ec4:	6b 81       	ldd	r22, Y+3	; 0x03
    3ec6:	7c 81       	ldd	r23, Y+4	; 0x04
    3ec8:	a7 01       	movw	r20, r14
    3eca:	96 01       	movw	r18, r12
    3ecc:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
		fp->flag |= FA__DIRTY;
    3ed0:	a8 85       	ldd	r26, Y+8	; 0x08
    3ed2:	b9 85       	ldd	r27, Y+9	; 0x09
    3ed4:	14 96       	adiw	r26, 0x04	; 4
    3ed6:	8c 91       	ld	r24, X
    3ed8:	14 97       	sbiw	r26, 0x04	; 4
    3eda:	80 64       	ori	r24, 0x40	; 64
    3edc:	14 96       	adiw	r26, 0x04	; 4
    3ede:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee4:	ec 0d       	add	r30, r12
    3ee6:	fd 1d       	adc	r31, r13
    3ee8:	fc 83       	std	Y+4, r31	; 0x04
    3eea:	eb 83       	std	Y+3, r30	; 0x03
    3eec:	e8 85       	ldd	r30, Y+8	; 0x08
    3eee:	f9 85       	ldd	r31, Y+9	; 0x09
    3ef0:	86 81       	ldd	r24, Z+6	; 0x06
    3ef2:	97 81       	ldd	r25, Z+7	; 0x07
    3ef4:	a0 85       	ldd	r26, Z+8	; 0x08
    3ef6:	b1 85       	ldd	r27, Z+9	; 0x09
    3ef8:	8c 0d       	add	r24, r12
    3efa:	9d 1d       	adc	r25, r13
    3efc:	ae 1d       	adc	r26, r14
    3efe:	bf 1d       	adc	r27, r15
    3f00:	86 83       	std	Z+6, r24	; 0x06
    3f02:	97 83       	std	Z+7, r25	; 0x07
    3f04:	a0 87       	std	Z+8, r26	; 0x08
    3f06:	b1 87       	std	Z+9, r27	; 0x09
    3f08:	e9 81       	ldd	r30, Y+1	; 0x01
    3f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f0c:	80 81       	ld	r24, Z
    3f0e:	91 81       	ldd	r25, Z+1	; 0x01
    3f10:	a2 81       	ldd	r26, Z+2	; 0x02
    3f12:	b3 81       	ldd	r27, Z+3	; 0x03
    3f14:	8c 0d       	add	r24, r12
    3f16:	9d 1d       	adc	r25, r13
    3f18:	ae 1d       	adc	r26, r14
    3f1a:	bf 1d       	adc	r27, r15
    3f1c:	80 83       	st	Z, r24
    3f1e:	91 83       	std	Z+1, r25	; 0x01
    3f20:	a2 83       	std	Z+2, r26	; 0x02
    3f22:	b3 83       	std	Z+3, r27	; 0x03
    3f24:	8c 18       	sub	r8, r12
    3f26:	9d 08       	sbc	r9, r13
    3f28:	ae 08       	sbc	r10, r14
    3f2a:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    3f2c:	09 f0       	breq	.+2      	; 0x3f30 <f_write+0x43e>
    3f2e:	35 ce       	rjmp	.-918    	; 0x3b9a <f_write+0xa8>
    3f30:	1f 81       	ldd	r17, Y+7	; 0x07
    3f32:	48 84       	ldd	r4, Y+8	; 0x08
    3f34:	59 84       	ldd	r5, Y+9	; 0x09
    3f36:	03 c0       	rjmp	.+6      	; 0x3f3e <f_write+0x44c>
    3f38:	1f 81       	ldd	r17, Y+7	; 0x07
    3f3a:	48 84       	ldd	r4, Y+8	; 0x08
    3f3c:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3f3e:	f2 01       	movw	r30, r4
    3f40:	86 81       	ldd	r24, Z+6	; 0x06
    3f42:	97 81       	ldd	r25, Z+7	; 0x07
    3f44:	a0 85       	ldd	r26, Z+8	; 0x08
    3f46:	b1 85       	ldd	r27, Z+9	; 0x09
    3f48:	42 85       	ldd	r20, Z+10	; 0x0a
    3f4a:	53 85       	ldd	r21, Z+11	; 0x0b
    3f4c:	64 85       	ldd	r22, Z+12	; 0x0c
    3f4e:	75 85       	ldd	r23, Z+13	; 0x0d
    3f50:	48 17       	cp	r20, r24
    3f52:	59 07       	cpc	r21, r25
    3f54:	6a 07       	cpc	r22, r26
    3f56:	7b 07       	cpc	r23, r27
    3f58:	20 f4       	brcc	.+8      	; 0x3f62 <f_write+0x470>
    3f5a:	82 87       	std	Z+10, r24	; 0x0a
    3f5c:	93 87       	std	Z+11, r25	; 0x0b
    3f5e:	a4 87       	std	Z+12, r26	; 0x0c
    3f60:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3f62:	d2 01       	movw	r26, r4
    3f64:	14 96       	adiw	r26, 0x04	; 4
    3f66:	8c 91       	ld	r24, X
    3f68:	14 97       	sbiw	r26, 0x04	; 4
    3f6a:	80 62       	ori	r24, 0x20	; 32
    3f6c:	14 96       	adiw	r26, 0x04	; 4
    3f6e:	8c 93       	st	X, r24
    3f70:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    3f72:	03 c0       	rjmp	.+6      	; 0x3f7a <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3f74:	12 e0       	ldi	r17, 0x02	; 2
    3f76:	01 c0       	rjmp	.+2      	; 0x3f7a <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3f78:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3f7a:	81 2f       	mov	r24, r17
    3f7c:	29 96       	adiw	r28, 0x09	; 9
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	f8 94       	cli
    3f82:	de bf       	out	0x3e, r29	; 62
    3f84:	0f be       	out	0x3f, r0	; 63
    3f86:	cd bf       	out	0x3d, r28	; 61
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	1f 91       	pop	r17
    3f8e:	0f 91       	pop	r16
    3f90:	ff 90       	pop	r15
    3f92:	ef 90       	pop	r14
    3f94:	df 90       	pop	r13
    3f96:	cf 90       	pop	r12
    3f98:	bf 90       	pop	r11
    3f9a:	af 90       	pop	r10
    3f9c:	9f 90       	pop	r9
    3f9e:	8f 90       	pop	r8
    3fa0:	7f 90       	pop	r7
    3fa2:	6f 90       	pop	r6
    3fa4:	5f 90       	pop	r5
    3fa6:	4f 90       	pop	r4
    3fa8:	3f 90       	pop	r3
    3faa:	2f 90       	pop	r2
    3fac:	08 95       	ret

00003fae <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    3fae:	0f 93       	push	r16
    3fb0:	1f 93       	push	r17
    3fb2:	cf 93       	push	r28
    3fb4:	df 93       	push	r29
    3fb6:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3fb8:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
	if (res == FR_OK) {
    3fbc:	88 23       	and	r24, r24
    3fbe:	09 f0       	breq	.+2      	; 0x3fc2 <f_sync+0x14>
    3fc0:	4c c0       	rjmp	.+152    	; 0x405a <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3fc4:	95 ff       	sbrs	r25, 5
    3fc6:	49 c0       	rjmp	.+146    	; 0x405a <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    3fc8:	96 ff       	sbrs	r25, 6
    3fca:	12 c0       	rjmp	.+36     	; 0x3ff0 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3fcc:	e8 81       	ld	r30, Y
    3fce:	f9 81       	ldd	r31, Y+1	; 0x01
    3fd0:	be 01       	movw	r22, r28
    3fd2:	60 5e       	subi	r22, 0xE0	; 224
    3fd4:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd6:	2e 89       	ldd	r18, Y+22	; 0x16
    3fd8:	3f 89       	ldd	r19, Y+23	; 0x17
    3fda:	48 8d       	ldd	r20, Y+24	; 0x18
    3fdc:	59 8d       	ldd	r21, Y+25	; 0x19
    3fde:	81 81       	ldd	r24, Z+1	; 0x01
    3fe0:	01 e0       	ldi	r16, 0x01	; 1
    3fe2:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    3fe6:	88 23       	and	r24, r24
    3fe8:	b9 f5       	brne	.+110    	; 0x4058 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    3fea:	8c 81       	ldd	r24, Y+4	; 0x04
    3fec:	8f 7b       	andi	r24, 0xBF	; 191
    3fee:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    3ff0:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3ff2:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3ff4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    3ff6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3ff8:	88 81       	ld	r24, Y
    3ffa:	99 81       	ldd	r25, Y+1	; 0x01
    3ffc:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
			if (res == FR_OK) {
    4000:	88 23       	and	r24, r24
    4002:	59 f5       	brne	.+86     	; 0x405a <f_sync+0xac>
				dir = fp->dir_ptr;
    4004:	0e 8d       	ldd	r16, Y+30	; 0x1e
    4006:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    4008:	f8 01       	movw	r30, r16
    400a:	83 85       	ldd	r24, Z+11	; 0x0b
    400c:	80 62       	ori	r24, 0x20	; 32
    400e:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    4010:	8a 85       	ldd	r24, Y+10	; 0x0a
    4012:	84 8f       	std	Z+28, r24	; 0x1c
    4014:	8b 85       	ldd	r24, Y+11	; 0x0b
    4016:	85 8f       	std	Z+29, r24	; 0x1d
    4018:	8c 85       	ldd	r24, Y+12	; 0x0c
    401a:	86 8f       	std	Z+30, r24	; 0x1e
    401c:	8d 85       	ldd	r24, Y+13	; 0x0d
    401e:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    4020:	4e 85       	ldd	r20, Y+14	; 0x0e
    4022:	5f 85       	ldd	r21, Y+15	; 0x0f
    4024:	68 89       	ldd	r22, Y+16	; 0x10
    4026:	79 89       	ldd	r23, Y+17	; 0x11
    4028:	c8 01       	movw	r24, r16
    402a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
				tim = get_fattime();						/* Update updated time */
    402e:	0e 94 07 11 	call	0x220e	; 0x220e <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    4032:	f8 01       	movw	r30, r16
    4034:	66 8b       	std	Z+22, r22	; 0x16
    4036:	77 8b       	std	Z+23, r23	; 0x17
    4038:	80 8f       	std	Z+24, r24	; 0x18
    403a:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    403c:	12 8a       	std	Z+18, r1	; 0x12
    403e:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    4040:	8c 81       	ldd	r24, Y+4	; 0x04
    4042:	8f 7d       	andi	r24, 0xDF	; 223
    4044:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    4046:	e8 81       	ld	r30, Y
    4048:	f9 81       	ldd	r31, Y+1	; 0x01
    404a:	81 e0       	ldi	r24, 0x01	; 1
    404c:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    404e:	88 81       	ld	r24, Y
    4050:	99 81       	ldd	r25, Y+1	; 0x01
    4052:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
    4056:	01 c0       	rjmp	.+2      	; 0x405a <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    4058:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    405a:	df 91       	pop	r29
    405c:	cf 91       	pop	r28
    405e:	1f 91       	pop	r17
    4060:	0f 91       	pop	r16
    4062:	08 95       	ret

00004064 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    4064:	cf 93       	push	r28
    4066:	df 93       	push	r29
    4068:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    406a:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    406e:	88 23       	and	r24, r24
    4070:	11 f4       	brne	.+4      	; 0x4076 <f_close+0x12>
    4072:	19 82       	std	Y+1, r1	; 0x01
    4074:	18 82       	st	Y, r1
	return res;
#endif
}
    4076:	df 91       	pop	r29
    4078:	cf 91       	pop	r28
    407a:	08 95       	ret

0000407c <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    407c:	88 23       	and	r24, r24
    407e:	19 f4       	brne	.+6      	; 0x4086 <f_chdrive+0xa>

	CurrVol = drv;
    4080:	10 92 81 02 	sts	0x0281, r1

	return FR_OK;
    4084:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    4086:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    4088:	08 95       	ret

0000408a <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    408a:	ef 92       	push	r14
    408c:	ff 92       	push	r15
    408e:	1f 93       	push	r17
    4090:	cf 93       	push	r28
    4092:	df 93       	push	r29
    4094:	cd b7       	in	r28, 0x3d	; 61
    4096:	de b7       	in	r29, 0x3e	; 62
    4098:	a4 97       	sbiw	r28, 0x24	; 36
    409a:	0f b6       	in	r0, 0x3f	; 63
    409c:	f8 94       	cli
    409e:	de bf       	out	0x3e, r29	; 62
    40a0:	0f be       	out	0x3f, r0	; 63
    40a2:	cd bf       	out	0x3d, r28	; 61
    40a4:	9c a3       	lds	r25, 0x5c
    40a6:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    40a8:	ce 01       	movw	r24, r28
    40aa:	83 96       	adiw	r24, 0x23	; 35
    40ac:	be 01       	movw	r22, r28
    40ae:	6f 5f       	subi	r22, 0xFF	; 255
    40b0:	7f 4f       	sbci	r23, 0xFF	; 255
    40b2:	40 e0       	ldi	r20, 0x00	; 0
    40b4:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
    40b8:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    40ba:	88 23       	and	r24, r24
    40bc:	81 f5       	brne	.+96     	; 0x411e <f_chdir+0x94>
		INIT_BUF(dj);
    40be:	ce 01       	movw	r24, r28
    40c0:	47 96       	adiw	r24, 0x17	; 23
    40c2:	9e 8b       	std	Y+22, r25	; 0x16
    40c4:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    40c6:	6b a1       	lds	r22, 0x4b
    40c8:	7c a1       	lds	r23, 0x4c
    40ca:	ce 01       	movw	r24, r28
    40cc:	01 96       	adiw	r24, 0x01	; 1
    40ce:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
    40d2:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    40d4:	88 23       	and	r24, r24
    40d6:	01 f5       	brne	.+64     	; 0x4118 <f_chdir+0x8e>
			if (!dj.dir) {
    40d8:	eb 89       	ldd	r30, Y+19	; 0x13
    40da:	fc 89       	ldd	r31, Y+20	; 0x14
    40dc:	30 97       	sbiw	r30, 0x00	; 0
    40de:	59 f4       	brne	.+22     	; 0x40f6 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    40e0:	e9 81       	ldd	r30, Y+1	; 0x01
    40e2:	fa 81       	ldd	r31, Y+2	; 0x02
    40e4:	8f 81       	ldd	r24, Y+7	; 0x07
    40e6:	98 85       	ldd	r25, Y+8	; 0x08
    40e8:	a9 85       	ldd	r26, Y+9	; 0x09
    40ea:	ba 85       	ldd	r27, Y+10	; 0x0a
    40ec:	86 8b       	std	Z+22, r24	; 0x16
    40ee:	97 8b       	std	Z+23, r25	; 0x17
    40f0:	a0 8f       	std	Z+24, r26	; 0x18
    40f2:	b1 8f       	std	Z+25, r27	; 0x19
    40f4:	14 c0       	rjmp	.+40     	; 0x411e <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    40f6:	83 85       	ldd	r24, Z+11	; 0x0b
    40f8:	84 ff       	sbrs	r24, 4
    40fa:	1e c0       	rjmp	.+60     	; 0x4138 <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    40fc:	e9 80       	ldd	r14, Y+1	; 0x01
    40fe:	fa 80       	ldd	r15, Y+2	; 0x02
    4100:	c7 01       	movw	r24, r14
    4102:	bf 01       	movw	r22, r30
    4104:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    4108:	dc 01       	movw	r26, r24
    410a:	cb 01       	movw	r24, r22
    410c:	f7 01       	movw	r30, r14
    410e:	86 8b       	std	Z+22, r24	; 0x16
    4110:	97 8b       	std	Z+23, r25	; 0x17
    4112:	a0 8f       	std	Z+24, r26	; 0x18
    4114:	b1 8f       	std	Z+25, r27	; 0x19
    4116:	03 c0       	rjmp	.+6      	; 0x411e <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    4118:	84 30       	cpi	r24, 0x04	; 4
    411a:	09 f4       	brne	.+2      	; 0x411e <f_chdir+0x94>
    411c:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    411e:	81 2f       	mov	r24, r17
    4120:	a4 96       	adiw	r28, 0x24	; 36
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	de bf       	out	0x3e, r29	; 62
    4128:	0f be       	out	0x3f, r0	; 63
    412a:	cd bf       	out	0x3d, r28	; 61
    412c:	df 91       	pop	r29
    412e:	cf 91       	pop	r28
    4130:	1f 91       	pop	r17
    4132:	ff 90       	pop	r15
    4134:	ef 90       	pop	r14
    4136:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    4138:	15 e0       	ldi	r17, 0x05	; 5
    413a:	f1 cf       	rjmp	.-30     	; 0x411e <f_chdir+0x94>

0000413c <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    413c:	2f 92       	push	r2
    413e:	3f 92       	push	r3
    4140:	4f 92       	push	r4
    4142:	5f 92       	push	r5
    4144:	6f 92       	push	r6
    4146:	7f 92       	push	r7
    4148:	8f 92       	push	r8
    414a:	9f 92       	push	r9
    414c:	af 92       	push	r10
    414e:	bf 92       	push	r11
    4150:	cf 92       	push	r12
    4152:	df 92       	push	r13
    4154:	ef 92       	push	r14
    4156:	ff 92       	push	r15
    4158:	0f 93       	push	r16
    415a:	1f 93       	push	r17
    415c:	cf 93       	push	r28
    415e:	df 93       	push	r29
    4160:	00 d0       	rcall	.+0      	; 0x4162 <f_lseek+0x26>
    4162:	00 d0       	rcall	.+0      	; 0x4164 <f_lseek+0x28>
    4164:	00 d0       	rcall	.+0      	; 0x4166 <f_lseek+0x2a>
    4166:	cd b7       	in	r28, 0x3d	; 61
    4168:	de b7       	in	r29, 0x3e	; 62
    416a:	9e 83       	std	Y+6, r25	; 0x06
    416c:	8d 83       	std	Y+5, r24	; 0x05
    416e:	6a 01       	movw	r12, r20
    4170:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    4172:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
    4176:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    4178:	88 23       	and	r24, r24
    417a:	09 f0       	breq	.+2      	; 0x417e <f_lseek+0x42>
    417c:	e6 c1       	rjmp	.+972    	; 0x454a <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    417e:	ad 81       	ldd	r26, Y+5	; 0x05
    4180:	be 81       	ldd	r27, Y+6	; 0x06
    4182:	14 96       	adiw	r26, 0x04	; 4
    4184:	2c 91       	ld	r18, X
    4186:	14 97       	sbiw	r26, 0x04	; 4
    4188:	22 23       	and	r18, r18
    418a:	0c f4       	brge	.+2      	; 0x418e <f_lseek+0x52>
    418c:	dd c1       	rjmp	.+954    	; 0x4548 <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    418e:	1a 96       	adiw	r26, 0x0a	; 10
    4190:	8d 91       	ld	r24, X+
    4192:	9d 91       	ld	r25, X+
    4194:	0d 90       	ld	r0, X+
    4196:	bc 91       	ld	r27, X
    4198:	a0 2d       	mov	r26, r0
    419a:	8c 15       	cp	r24, r12
    419c:	9d 05       	cpc	r25, r13
    419e:	ae 05       	cpc	r26, r14
    41a0:	bf 05       	cpc	r27, r15
    41a2:	20 f4       	brcc	.+8      	; 0x41ac <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    41a4:	21 fd       	sbrc	r18, 1
    41a6:	02 c0       	rjmp	.+4      	; 0x41ac <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    41a8:	6c 01       	movw	r12, r24
    41aa:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    41ac:	ed 81       	ldd	r30, Y+5	; 0x05
    41ae:	fe 81       	ldd	r31, Y+6	; 0x06
    41b0:	46 81       	ldd	r20, Z+6	; 0x06
    41b2:	57 81       	ldd	r21, Z+7	; 0x07
    41b4:	60 85       	ldd	r22, Z+8	; 0x08
    41b6:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    41b8:	16 82       	std	Z+6, r1	; 0x06
    41ba:	17 82       	std	Z+7, r1	; 0x07
    41bc:	10 86       	std	Z+8, r1	; 0x08
    41be:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    41c0:	c1 14       	cp	r12, r1
    41c2:	d1 04       	cpc	r13, r1
    41c4:	e1 04       	cpc	r14, r1
    41c6:	f1 04       	cpc	r15, r1
    41c8:	09 f4       	brne	.+2      	; 0x41cc <f_lseek+0x90>
    41ca:	bf c1       	rjmp	.+894    	; 0x454a <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    41cc:	20 80       	ld	r2, Z
    41ce:	31 80       	ldd	r3, Z+1	; 0x01
    41d0:	f1 01       	movw	r30, r2
    41d2:	82 81       	ldd	r24, Z+2	; 0x02
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	a0 e0       	ldi	r26, 0x00	; 0
    41d8:	b0 e0       	ldi	r27, 0x00	; 0
    41da:	4c 01       	movw	r8, r24
    41dc:	5d 01       	movw	r10, r26
    41de:	07 2e       	mov	r0, r23
    41e0:	79 e0       	ldi	r23, 0x09	; 9
    41e2:	88 0c       	add	r8, r8
    41e4:	99 1c       	adc	r9, r9
    41e6:	aa 1c       	adc	r10, r10
    41e8:	bb 1c       	adc	r11, r11
    41ea:	7a 95       	dec	r23
    41ec:	d1 f7       	brne	.-12     	; 0x41e2 <f_lseek+0xa6>
    41ee:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    41f0:	41 15       	cp	r20, r1
    41f2:	51 05       	cpc	r21, r1
    41f4:	61 05       	cpc	r22, r1
    41f6:	71 05       	cpc	r23, r1
    41f8:	f1 f1       	breq	.+124    	; 0x4276 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    41fa:	2a 01       	movw	r4, r20
    41fc:	3b 01       	movw	r6, r22
    41fe:	08 94       	sec
    4200:	41 08       	sbc	r4, r1
    4202:	51 08       	sbc	r5, r1
    4204:	61 08       	sbc	r6, r1
    4206:	71 08       	sbc	r7, r1
    4208:	c7 01       	movw	r24, r14
    420a:	b6 01       	movw	r22, r12
    420c:	61 50       	subi	r22, 0x01	; 1
    420e:	70 40       	sbci	r23, 0x00	; 0
    4210:	80 40       	sbci	r24, 0x00	; 0
    4212:	90 40       	sbci	r25, 0x00	; 0
    4214:	a5 01       	movw	r20, r10
    4216:	94 01       	movw	r18, r8
    4218:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>
    421c:	29 83       	std	Y+1, r18	; 0x01
    421e:	3a 83       	std	Y+2, r19	; 0x02
    4220:	4b 83       	std	Y+3, r20	; 0x03
    4222:	5c 83       	std	Y+4, r21	; 0x04
    4224:	c3 01       	movw	r24, r6
    4226:	b2 01       	movw	r22, r4
    4228:	a5 01       	movw	r20, r10
    422a:	94 01       	movw	r18, r8
    422c:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    4230:	89 81       	ldd	r24, Y+1	; 0x01
    4232:	9a 81       	ldd	r25, Y+2	; 0x02
    4234:	ab 81       	ldd	r26, Y+3	; 0x03
    4236:	bc 81       	ldd	r27, Y+4	; 0x04
    4238:	82 17       	cp	r24, r18
    423a:	93 07       	cpc	r25, r19
    423c:	a4 07       	cpc	r26, r20
    423e:	b5 07       	cpc	r27, r21
    4240:	d0 f0       	brcs	.+52     	; 0x4276 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    4242:	88 27       	eor	r24, r24
    4244:	99 27       	eor	r25, r25
    4246:	dc 01       	movw	r26, r24
    4248:	88 19       	sub	r24, r8
    424a:	99 09       	sbc	r25, r9
    424c:	aa 09       	sbc	r26, r10
    424e:	bb 09       	sbc	r27, r11
    4250:	84 21       	and	r24, r4
    4252:	95 21       	and	r25, r5
    4254:	a6 21       	and	r26, r6
    4256:	b7 21       	and	r27, r7
    4258:	ed 81       	ldd	r30, Y+5	; 0x05
    425a:	fe 81       	ldd	r31, Y+6	; 0x06
    425c:	86 83       	std	Z+6, r24	; 0x06
    425e:	97 83       	std	Z+7, r25	; 0x07
    4260:	a0 87       	std	Z+8, r26	; 0x08
    4262:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    4264:	c8 1a       	sub	r12, r24
    4266:	d9 0a       	sbc	r13, r25
    4268:	ea 0a       	sbc	r14, r26
    426a:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    426c:	42 89       	ldd	r20, Z+18	; 0x12
    426e:	53 89       	ldd	r21, Z+19	; 0x13
    4270:	64 89       	ldd	r22, Z+20	; 0x14
    4272:	75 89       	ldd	r23, Z+21	; 0x15
    4274:	42 c0       	rjmp	.+132    	; 0x42fa <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4276:	ad 81       	ldd	r26, Y+5	; 0x05
    4278:	be 81       	ldd	r27, Y+6	; 0x06
    427a:	1e 96       	adiw	r26, 0x0e	; 14
    427c:	4d 91       	ld	r20, X+
    427e:	5d 91       	ld	r21, X+
    4280:	6d 91       	ld	r22, X+
    4282:	7c 91       	ld	r23, X
    4284:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4286:	41 15       	cp	r20, r1
    4288:	51 05       	cpc	r21, r1
    428a:	61 05       	cpc	r22, r1
    428c:	71 05       	cpc	r23, r1
    428e:	69 f5       	brne	.+90     	; 0x42ea <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    4290:	c1 01       	movw	r24, r2
    4292:	40 e0       	ldi	r20, 0x00	; 0
    4294:	50 e0       	ldi	r21, 0x00	; 0
    4296:	ba 01       	movw	r22, r20
    4298:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    429c:	ab 01       	movw	r20, r22
    429e:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    42a0:	41 30       	cpi	r20, 0x01	; 1
    42a2:	51 05       	cpc	r21, r1
    42a4:	61 05       	cpc	r22, r1
    42a6:	71 05       	cpc	r23, r1
    42a8:	39 f4       	brne	.+14     	; 0x42b8 <f_lseek+0x17c>
    42aa:	ed 81       	ldd	r30, Y+5	; 0x05
    42ac:	fe 81       	ldd	r31, Y+6	; 0x06
    42ae:	84 81       	ldd	r24, Z+4	; 0x04
    42b0:	80 68       	ori	r24, 0x80	; 128
    42b2:	84 83       	std	Z+4, r24	; 0x04
    42b4:	12 e0       	ldi	r17, 0x02	; 2
    42b6:	49 c1       	rjmp	.+658    	; 0x454a <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    42b8:	4f 3f       	cpi	r20, 0xFF	; 255
    42ba:	ff ef       	ldi	r31, 0xFF	; 255
    42bc:	5f 07       	cpc	r21, r31
    42be:	ff ef       	ldi	r31, 0xFF	; 255
    42c0:	6f 07       	cpc	r22, r31
    42c2:	ff ef       	ldi	r31, 0xFF	; 255
    42c4:	7f 07       	cpc	r23, r31
    42c6:	59 f4       	brne	.+22     	; 0x42de <f_lseek+0x1a2>
    42c8:	ad 81       	ldd	r26, Y+5	; 0x05
    42ca:	be 81       	ldd	r27, Y+6	; 0x06
    42cc:	14 96       	adiw	r26, 0x04	; 4
    42ce:	8c 91       	ld	r24, X
    42d0:	14 97       	sbiw	r26, 0x04	; 4
    42d2:	80 68       	ori	r24, 0x80	; 128
    42d4:	14 96       	adiw	r26, 0x04	; 4
    42d6:	8c 93       	st	X, r24
    42d8:	14 97       	sbiw	r26, 0x04	; 4
    42da:	11 e0       	ldi	r17, 0x01	; 1
    42dc:	36 c1       	rjmp	.+620    	; 0x454a <f_lseek+0x40e>
					fp->sclust = clst;
    42de:	ed 81       	ldd	r30, Y+5	; 0x05
    42e0:	fe 81       	ldd	r31, Y+6	; 0x06
    42e2:	46 87       	std	Z+14, r20	; 0x0e
    42e4:	57 87       	std	Z+15, r21	; 0x0f
    42e6:	60 8b       	std	Z+16, r22	; 0x10
    42e8:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    42ea:	ad 81       	ldd	r26, Y+5	; 0x05
    42ec:	be 81       	ldd	r27, Y+6	; 0x06
    42ee:	52 96       	adiw	r26, 0x12	; 18
    42f0:	4d 93       	st	X+, r20
    42f2:	5d 93       	st	X+, r21
    42f4:	6d 93       	st	X+, r22
    42f6:	7c 93       	st	X, r23
    42f8:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    42fa:	41 15       	cp	r20, r1
    42fc:	51 05       	cpc	r21, r1
    42fe:	61 05       	cpc	r22, r1
    4300:	71 05       	cpc	r23, r1
    4302:	09 f4       	brne	.+2      	; 0x4306 <f_lseek+0x1ca>
    4304:	aa c0       	rjmp	.+340    	; 0x445a <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    4306:	8c 14       	cp	r8, r12
    4308:	9d 04       	cpc	r9, r13
    430a:	ae 04       	cpc	r10, r14
    430c:	bf 04       	cpc	r11, r15
    430e:	08 f0       	brcs	.+2      	; 0x4312 <f_lseek+0x1d6>
    4310:	68 c0       	rjmp	.+208    	; 0x43e2 <f_lseek+0x2a6>
    4312:	4d 80       	ldd	r4, Y+5	; 0x05
    4314:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    4316:	f2 01       	movw	r30, r4
    4318:	84 81       	ldd	r24, Z+4	; 0x04
    431a:	81 ff       	sbrs	r24, 1
    431c:	0c c0       	rjmp	.+24     	; 0x4336 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    431e:	80 81       	ld	r24, Z
    4320:	91 81       	ldd	r25, Z+1	; 0x01
    4322:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    4326:	ab 01       	movw	r20, r22
    4328:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    432a:	41 15       	cp	r20, r1
    432c:	51 05       	cpc	r21, r1
    432e:	61 05       	cpc	r22, r1
    4330:	71 05       	cpc	r23, r1
    4332:	39 f4       	brne	.+14     	; 0x4342 <f_lseek+0x206>
    4334:	52 c0       	rjmp	.+164    	; 0x43da <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    4336:	80 81       	ld	r24, Z
    4338:	91 81       	ldd	r25, Z+1	; 0x01
    433a:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    433e:	ab 01       	movw	r20, r22
    4340:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4342:	4f 3f       	cpi	r20, 0xFF	; 255
    4344:	bf ef       	ldi	r27, 0xFF	; 255
    4346:	5b 07       	cpc	r21, r27
    4348:	bf ef       	ldi	r27, 0xFF	; 255
    434a:	6b 07       	cpc	r22, r27
    434c:	bf ef       	ldi	r27, 0xFF	; 255
    434e:	7b 07       	cpc	r23, r27
    4350:	41 f4       	brne	.+16     	; 0x4362 <f_lseek+0x226>
    4352:	5e 82       	std	Y+6, r5	; 0x06
    4354:	4d 82       	std	Y+5, r4	; 0x05
    4356:	f2 01       	movw	r30, r4
    4358:	84 81       	ldd	r24, Z+4	; 0x04
    435a:	80 68       	ori	r24, 0x80	; 128
    435c:	84 83       	std	Z+4, r24	; 0x04
    435e:	11 e0       	ldi	r17, 0x01	; 1
    4360:	f4 c0       	rjmp	.+488    	; 0x454a <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4362:	42 30       	cpi	r20, 0x02	; 2
    4364:	51 05       	cpc	r21, r1
    4366:	61 05       	cpc	r22, r1
    4368:	71 05       	cpc	r23, r1
    436a:	60 f0       	brcs	.+24     	; 0x4384 <f_lseek+0x248>
    436c:	d2 01       	movw	r26, r4
    436e:	ed 91       	ld	r30, X+
    4370:	fc 91       	ld	r31, X
    4372:	82 8d       	ldd	r24, Z+26	; 0x1a
    4374:	93 8d       	ldd	r25, Z+27	; 0x1b
    4376:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4378:	b5 8d       	ldd	r27, Z+29	; 0x1d
    437a:	48 17       	cp	r20, r24
    437c:	59 07       	cpc	r21, r25
    437e:	6a 07       	cpc	r22, r26
    4380:	7b 07       	cpc	r23, r27
    4382:	40 f0       	brcs	.+16     	; 0x4394 <f_lseek+0x258>
    4384:	5e 82       	std	Y+6, r5	; 0x06
    4386:	4d 82       	std	Y+5, r4	; 0x05
    4388:	f2 01       	movw	r30, r4
    438a:	84 81       	ldd	r24, Z+4	; 0x04
    438c:	80 68       	ori	r24, 0x80	; 128
    438e:	84 83       	std	Z+4, r24	; 0x04
    4390:	12 e0       	ldi	r17, 0x02	; 2
    4392:	db c0       	rjmp	.+438    	; 0x454a <f_lseek+0x40e>
					fp->clust = clst;
    4394:	d2 01       	movw	r26, r4
    4396:	52 96       	adiw	r26, 0x12	; 18
    4398:	4d 93       	st	X+, r20
    439a:	5d 93       	st	X+, r21
    439c:	6d 93       	st	X+, r22
    439e:	7c 93       	st	X, r23
    43a0:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    43a2:	16 96       	adiw	r26, 0x06	; 6
    43a4:	8d 91       	ld	r24, X+
    43a6:	9d 91       	ld	r25, X+
    43a8:	0d 90       	ld	r0, X+
    43aa:	bc 91       	ld	r27, X
    43ac:	a0 2d       	mov	r26, r0
    43ae:	88 0d       	add	r24, r8
    43b0:	99 1d       	adc	r25, r9
    43b2:	aa 1d       	adc	r26, r10
    43b4:	bb 1d       	adc	r27, r11
    43b6:	f2 01       	movw	r30, r4
    43b8:	86 83       	std	Z+6, r24	; 0x06
    43ba:	97 83       	std	Z+7, r25	; 0x07
    43bc:	a0 87       	std	Z+8, r26	; 0x08
    43be:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    43c0:	c8 18       	sub	r12, r8
    43c2:	d9 08       	sbc	r13, r9
    43c4:	ea 08       	sbc	r14, r10
    43c6:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    43c8:	8c 14       	cp	r8, r12
    43ca:	9d 04       	cpc	r9, r13
    43cc:	ae 04       	cpc	r10, r14
    43ce:	bf 04       	cpc	r11, r15
    43d0:	08 f4       	brcc	.+2      	; 0x43d4 <f_lseek+0x298>
    43d2:	a1 cf       	rjmp	.-190    	; 0x4316 <f_lseek+0x1da>
    43d4:	5e 82       	std	Y+6, r5	; 0x06
    43d6:	4d 82       	std	Y+5, r4	; 0x05
    43d8:	04 c0       	rjmp	.+8      	; 0x43e2 <f_lseek+0x2a6>
    43da:	5e 82       	std	Y+6, r5	; 0x06
    43dc:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    43de:	75 01       	movw	r14, r10
    43e0:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    43e2:	ed 81       	ldd	r30, Y+5	; 0x05
    43e4:	fe 81       	ldd	r31, Y+6	; 0x06
    43e6:	86 81       	ldd	r24, Z+6	; 0x06
    43e8:	97 81       	ldd	r25, Z+7	; 0x07
    43ea:	a0 85       	ldd	r26, Z+8	; 0x08
    43ec:	b1 85       	ldd	r27, Z+9	; 0x09
    43ee:	8c 0d       	add	r24, r12
    43f0:	9d 1d       	adc	r25, r13
    43f2:	ae 1d       	adc	r26, r14
    43f4:	bf 1d       	adc	r27, r15
    43f6:	86 83       	std	Z+6, r24	; 0x06
    43f8:	97 83       	std	Z+7, r25	; 0x07
    43fa:	a0 87       	std	Z+8, r26	; 0x08
    43fc:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    43fe:	d7 01       	movw	r26, r14
    4400:	c6 01       	movw	r24, r12
    4402:	91 70       	andi	r25, 0x01	; 1
    4404:	a0 70       	andi	r26, 0x00	; 0
    4406:	b0 70       	andi	r27, 0x00	; 0
    4408:	00 97       	sbiw	r24, 0x00	; 0
    440a:	a1 05       	cpc	r26, r1
    440c:	b1 05       	cpc	r27, r1
    440e:	49 f1       	breq	.+82     	; 0x4462 <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    4410:	80 81       	ld	r24, Z
    4412:	91 81       	ldd	r25, Z+1	; 0x01
    4414:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    4418:	dc 01       	movw	r26, r24
    441a:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    441c:	00 97       	sbiw	r24, 0x00	; 0
    441e:	a1 05       	cpc	r26, r1
    4420:	b1 05       	cpc	r27, r1
    4422:	59 f4       	brne	.+22     	; 0x443a <f_lseek+0x2fe>
    4424:	ad 81       	ldd	r26, Y+5	; 0x05
    4426:	be 81       	ldd	r27, Y+6	; 0x06
    4428:	14 96       	adiw	r26, 0x04	; 4
    442a:	8c 91       	ld	r24, X
    442c:	14 97       	sbiw	r26, 0x04	; 4
    442e:	80 68       	ori	r24, 0x80	; 128
    4430:	14 96       	adiw	r26, 0x04	; 4
    4432:	8c 93       	st	X, r24
    4434:	14 97       	sbiw	r26, 0x04	; 4
    4436:	12 e0       	ldi	r17, 0x02	; 2
    4438:	88 c0       	rjmp	.+272    	; 0x454a <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    443a:	46 01       	movw	r8, r12
    443c:	57 01       	movw	r10, r14
    443e:	07 2e       	mov	r0, r23
    4440:	79 e0       	ldi	r23, 0x09	; 9
    4442:	b6 94       	lsr	r11
    4444:	a7 94       	ror	r10
    4446:	97 94       	ror	r9
    4448:	87 94       	ror	r8
    444a:	7a 95       	dec	r23
    444c:	d1 f7       	brne	.-12     	; 0x4442 <f_lseek+0x306>
    444e:	70 2d       	mov	r23, r0
    4450:	88 0e       	add	r8, r24
    4452:	99 1e       	adc	r9, r25
    4454:	aa 1e       	adc	r10, r26
    4456:	bb 1e       	adc	r11, r27
    4458:	07 c0       	rjmp	.+14     	; 0x4468 <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    445a:	88 24       	eor	r8, r8
    445c:	99 24       	eor	r9, r9
    445e:	54 01       	movw	r10, r8
    4460:	03 c0       	rjmp	.+6      	; 0x4468 <f_lseek+0x32c>
    4462:	88 24       	eor	r8, r8
    4464:	99 24       	eor	r9, r9
    4466:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4468:	ed 81       	ldd	r30, Y+5	; 0x05
    446a:	fe 81       	ldd	r31, Y+6	; 0x06
    446c:	86 81       	ldd	r24, Z+6	; 0x06
    446e:	97 81       	ldd	r25, Z+7	; 0x07
    4470:	a0 85       	ldd	r26, Z+8	; 0x08
    4472:	b1 85       	ldd	r27, Z+9	; 0x09
    4474:	91 70       	andi	r25, 0x01	; 1
    4476:	a0 70       	andi	r26, 0x00	; 0
    4478:	b0 70       	andi	r27, 0x00	; 0
    447a:	00 97       	sbiw	r24, 0x00	; 0
    447c:	a1 05       	cpc	r26, r1
    447e:	b1 05       	cpc	r27, r1
    4480:	09 f4       	brne	.+2      	; 0x4484 <f_lseek+0x348>
    4482:	4b c0       	rjmp	.+150    	; 0x451a <f_lseek+0x3de>
    4484:	c6 88       	ldd	r12, Z+22	; 0x16
    4486:	d7 88       	ldd	r13, Z+23	; 0x17
    4488:	e0 8c       	ldd	r14, Z+24	; 0x18
    448a:	f1 8c       	ldd	r15, Z+25	; 0x19
    448c:	c8 14       	cp	r12, r8
    448e:	d9 04       	cpc	r13, r9
    4490:	ea 04       	cpc	r14, r10
    4492:	fb 04       	cpc	r15, r11
    4494:	09 f4       	brne	.+2      	; 0x4498 <f_lseek+0x35c>
    4496:	41 c0       	rjmp	.+130    	; 0x451a <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    4498:	84 81       	ldd	r24, Z+4	; 0x04
    449a:	86 ff       	sbrs	r24, 6
    449c:	1f c0       	rjmp	.+62     	; 0x44dc <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    449e:	01 90       	ld	r0, Z+
    44a0:	f0 81       	ld	r31, Z
    44a2:	e0 2d       	mov	r30, r0
    44a4:	6d 81       	ldd	r22, Y+5	; 0x05
    44a6:	7e 81       	ldd	r23, Y+6	; 0x06
    44a8:	60 5e       	subi	r22, 0xE0	; 224
    44aa:	7f 4f       	sbci	r23, 0xFF	; 255
    44ac:	81 81       	ldd	r24, Z+1	; 0x01
    44ae:	a7 01       	movw	r20, r14
    44b0:	96 01       	movw	r18, r12
    44b2:	01 e0       	ldi	r16, 0x01	; 1
    44b4:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    44b8:	88 23       	and	r24, r24
    44ba:	59 f0       	breq	.+22     	; 0x44d2 <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    44bc:	ad 81       	ldd	r26, Y+5	; 0x05
    44be:	be 81       	ldd	r27, Y+6	; 0x06
    44c0:	14 96       	adiw	r26, 0x04	; 4
    44c2:	8c 91       	ld	r24, X
    44c4:	14 97       	sbiw	r26, 0x04	; 4
    44c6:	80 68       	ori	r24, 0x80	; 128
    44c8:	14 96       	adiw	r26, 0x04	; 4
    44ca:	8c 93       	st	X, r24
    44cc:	14 97       	sbiw	r26, 0x04	; 4
    44ce:	11 e0       	ldi	r17, 0x01	; 1
    44d0:	3c c0       	rjmp	.+120    	; 0x454a <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    44d2:	ed 81       	ldd	r30, Y+5	; 0x05
    44d4:	fe 81       	ldd	r31, Y+6	; 0x06
    44d6:	84 81       	ldd	r24, Z+4	; 0x04
    44d8:	8f 7b       	andi	r24, 0xBF	; 191
    44da:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    44dc:	ad 81       	ldd	r26, Y+5	; 0x05
    44de:	be 81       	ldd	r27, Y+6	; 0x06
    44e0:	ed 91       	ld	r30, X+
    44e2:	fc 91       	ld	r31, X
    44e4:	11 97       	sbiw	r26, 0x01	; 1
    44e6:	bd 01       	movw	r22, r26
    44e8:	60 5e       	subi	r22, 0xE0	; 224
    44ea:	7f 4f       	sbci	r23, 0xFF	; 255
    44ec:	81 81       	ldd	r24, Z+1	; 0x01
    44ee:	a5 01       	movw	r20, r10
    44f0:	94 01       	movw	r18, r8
    44f2:	01 e0       	ldi	r16, 0x01	; 1
    44f4:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    44f8:	88 23       	and	r24, r24
    44fa:	39 f0       	breq	.+14     	; 0x450a <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    44fc:	ed 81       	ldd	r30, Y+5	; 0x05
    44fe:	fe 81       	ldd	r31, Y+6	; 0x06
    4500:	84 81       	ldd	r24, Z+4	; 0x04
    4502:	80 68       	ori	r24, 0x80	; 128
    4504:	84 83       	std	Z+4, r24	; 0x04
    4506:	11 e0       	ldi	r17, 0x01	; 1
    4508:	20 c0       	rjmp	.+64     	; 0x454a <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    450a:	ad 81       	ldd	r26, Y+5	; 0x05
    450c:	be 81       	ldd	r27, Y+6	; 0x06
    450e:	56 96       	adiw	r26, 0x16	; 22
    4510:	8d 92       	st	X+, r8
    4512:	9d 92       	st	X+, r9
    4514:	ad 92       	st	X+, r10
    4516:	bc 92       	st	X, r11
    4518:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    451a:	ed 81       	ldd	r30, Y+5	; 0x05
    451c:	fe 81       	ldd	r31, Y+6	; 0x06
    451e:	86 81       	ldd	r24, Z+6	; 0x06
    4520:	97 81       	ldd	r25, Z+7	; 0x07
    4522:	a0 85       	ldd	r26, Z+8	; 0x08
    4524:	b1 85       	ldd	r27, Z+9	; 0x09
    4526:	42 85       	ldd	r20, Z+10	; 0x0a
    4528:	53 85       	ldd	r21, Z+11	; 0x0b
    452a:	64 85       	ldd	r22, Z+12	; 0x0c
    452c:	75 85       	ldd	r23, Z+13	; 0x0d
    452e:	48 17       	cp	r20, r24
    4530:	59 07       	cpc	r21, r25
    4532:	6a 07       	cpc	r22, r26
    4534:	7b 07       	cpc	r23, r27
    4536:	48 f4       	brcc	.+18     	; 0x454a <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    4538:	82 87       	std	Z+10, r24	; 0x0a
    453a:	93 87       	std	Z+11, r25	; 0x0b
    453c:	a4 87       	std	Z+12, r26	; 0x0c
    453e:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    4540:	84 81       	ldd	r24, Z+4	; 0x04
    4542:	80 62       	ori	r24, 0x20	; 32
    4544:	84 83       	std	Z+4, r24	; 0x04
    4546:	01 c0       	rjmp	.+2      	; 0x454a <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4548:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    454a:	81 2f       	mov	r24, r17
    454c:	26 96       	adiw	r28, 0x06	; 6
    454e:	0f b6       	in	r0, 0x3f	; 63
    4550:	f8 94       	cli
    4552:	de bf       	out	0x3e, r29	; 62
    4554:	0f be       	out	0x3f, r0	; 63
    4556:	cd bf       	out	0x3d, r28	; 61
    4558:	df 91       	pop	r29
    455a:	cf 91       	pop	r28
    455c:	1f 91       	pop	r17
    455e:	0f 91       	pop	r16
    4560:	ff 90       	pop	r15
    4562:	ef 90       	pop	r14
    4564:	df 90       	pop	r13
    4566:	cf 90       	pop	r12
    4568:	bf 90       	pop	r11
    456a:	af 90       	pop	r10
    456c:	9f 90       	pop	r9
    456e:	8f 90       	pop	r8
    4570:	7f 90       	pop	r7
    4572:	6f 90       	pop	r6
    4574:	5f 90       	pop	r5
    4576:	4f 90       	pop	r4
    4578:	3f 90       	pop	r3
    457a:	2f 90       	pop	r2
    457c:	08 95       	ret

0000457e <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    457e:	ef 92       	push	r14
    4580:	ff 92       	push	r15
    4582:	0f 93       	push	r16
    4584:	1f 93       	push	r17
    4586:	cf 93       	push	r28
    4588:	df 93       	push	r29
    458a:	cd b7       	in	r28, 0x3d	; 61
    458c:	de b7       	in	r29, 0x3e	; 62
    458e:	2e 97       	sbiw	r28, 0x0e	; 14
    4590:	0f b6       	in	r0, 0x3f	; 63
    4592:	f8 94       	cli
    4594:	de bf       	out	0x3e, r29	; 62
    4596:	0f be       	out	0x3f, r0	; 63
    4598:	cd bf       	out	0x3d, r28	; 61
    459a:	8c 01       	movw	r16, r24
    459c:	7e 87       	std	Y+14, r23	; 0x0e
    459e:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    45a0:	00 97       	sbiw	r24, 0x00	; 0
    45a2:	09 f4       	brne	.+2      	; 0x45a6 <f_opendir+0x28>
    45a4:	4c c0       	rjmp	.+152    	; 0x463e <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    45a6:	ce 01       	movw	r24, r28
    45a8:	0d 96       	adiw	r24, 0x0d	; 13
    45aa:	b8 01       	movw	r22, r16
    45ac:	40 e0       	ldi	r20, 0x00	; 0
    45ae:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
	fs = dj->fs;
    45b2:	d8 01       	movw	r26, r16
    45b4:	ed 90       	ld	r14, X+
    45b6:	fc 90       	ld	r15, X
    45b8:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    45ba:	88 23       	and	r24, r24
    45bc:	e1 f5       	brne	.+120    	; 0x4636 <f_opendir+0xb8>
		INIT_BUF(*dj);
    45be:	ce 01       	movw	r24, r28
    45c0:	01 96       	adiw	r24, 0x01	; 1
    45c2:	55 96       	adiw	r26, 0x15	; 21
    45c4:	9c 93       	st	X, r25
    45c6:	8e 93       	st	-X, r24
    45c8:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    45ca:	6d 85       	ldd	r22, Y+13	; 0x0d
    45cc:	7e 85       	ldd	r23, Y+14	; 0x0e
    45ce:	c8 01       	movw	r24, r16
    45d0:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    45d4:	88 23       	and	r24, r24
    45d6:	11 f5       	brne	.+68     	; 0x461c <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    45d8:	d8 01       	movw	r26, r16
    45da:	52 96       	adiw	r26, 0x12	; 18
    45dc:	ed 91       	ld	r30, X+
    45de:	fc 91       	ld	r31, X
    45e0:	53 97       	sbiw	r26, 0x13	; 19
    45e2:	30 97       	sbiw	r30, 0x00	; 0
    45e4:	71 f0       	breq	.+28     	; 0x4602 <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    45e6:	83 85       	ldd	r24, Z+11	; 0x0b
    45e8:	84 ff       	sbrs	r24, 4
    45ea:	1b c0       	rjmp	.+54     	; 0x4622 <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    45ec:	c7 01       	movw	r24, r14
    45ee:	bf 01       	movw	r22, r30
    45f0:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    45f4:	dc 01       	movw	r26, r24
    45f6:	cb 01       	movw	r24, r22
    45f8:	f8 01       	movw	r30, r16
    45fa:	86 83       	std	Z+6, r24	; 0x06
    45fc:	97 83       	std	Z+7, r25	; 0x07
    45fe:	a0 87       	std	Z+8, r26	; 0x08
    4600:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    4602:	d7 01       	movw	r26, r14
    4604:	16 96       	adiw	r26, 0x06	; 6
    4606:	8d 91       	ld	r24, X+
    4608:	9c 91       	ld	r25, X
    460a:	17 97       	sbiw	r26, 0x07	; 7
    460c:	f8 01       	movw	r30, r16
    460e:	93 83       	std	Z+3, r25	; 0x03
    4610:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    4612:	c8 01       	movw	r24, r16
    4614:	60 e0       	ldi	r22, 0x00	; 0
    4616:	70 e0       	ldi	r23, 0x00	; 0
    4618:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    461c:	84 30       	cpi	r24, 0x04	; 4
    461e:	11 f4       	brne	.+4      	; 0x4624 <f_opendir+0xa6>
    4620:	04 c0       	rjmp	.+8      	; 0x462a <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    4622:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    4624:	88 23       	and	r24, r24
    4626:	61 f0       	breq	.+24     	; 0x4640 <f_opendir+0xc2>
    4628:	01 c0       	rjmp	.+2      	; 0x462c <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    462a:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    462c:	d8 01       	movw	r26, r16
    462e:	11 96       	adiw	r26, 0x01	; 1
    4630:	1c 92       	st	X, r1
    4632:	1e 92       	st	-X, r1
    4634:	05 c0       	rjmp	.+10     	; 0x4640 <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    4636:	f8 01       	movw	r30, r16
    4638:	11 82       	std	Z+1, r1	; 0x01
    463a:	10 82       	st	Z, r1
    463c:	01 c0       	rjmp	.+2      	; 0x4640 <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    463e:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    4640:	2e 96       	adiw	r28, 0x0e	; 14
    4642:	0f b6       	in	r0, 0x3f	; 63
    4644:	f8 94       	cli
    4646:	de bf       	out	0x3e, r29	; 62
    4648:	0f be       	out	0x3f, r0	; 63
    464a:	cd bf       	out	0x3d, r28	; 61
    464c:	df 91       	pop	r29
    464e:	cf 91       	pop	r28
    4650:	1f 91       	pop	r17
    4652:	0f 91       	pop	r16
    4654:	ff 90       	pop	r15
    4656:	ef 90       	pop	r14
    4658:	08 95       	ret

0000465a <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    465a:	cf 92       	push	r12
    465c:	df 92       	push	r13
    465e:	ef 92       	push	r14
    4660:	ff 92       	push	r15
    4662:	1f 93       	push	r17
    4664:	cf 93       	push	r28
    4666:	df 93       	push	r29
    4668:	cd b7       	in	r28, 0x3d	; 61
    466a:	de b7       	in	r29, 0x3e	; 62
    466c:	2c 97       	sbiw	r28, 0x0c	; 12
    466e:	0f b6       	in	r0, 0x3f	; 63
    4670:	f8 94       	cli
    4672:	de bf       	out	0x3e, r29	; 62
    4674:	0f be       	out	0x3f, r0	; 63
    4676:	cd bf       	out	0x3d, r28	; 61
    4678:	7c 01       	movw	r14, r24
    467a:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    467c:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
    4680:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4682:	88 23       	and	r24, r24
    4684:	81 f5       	brne	.+96     	; 0x46e6 <f_readdir+0x8c>
		if (!fno) {
    4686:	c1 14       	cp	r12, r1
    4688:	d1 04       	cpc	r13, r1
    468a:	39 f4       	brne	.+14     	; 0x469a <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    468c:	c7 01       	movw	r24, r14
    468e:	60 e0       	ldi	r22, 0x00	; 0
    4690:	70 e0       	ldi	r23, 0x00	; 0
    4692:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
    4696:	18 2f       	mov	r17, r24
    4698:	26 c0       	rjmp	.+76     	; 0x46e6 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    469a:	ce 01       	movw	r24, r28
    469c:	01 96       	adiw	r24, 0x01	; 1
    469e:	f7 01       	movw	r30, r14
    46a0:	95 8b       	std	Z+21, r25	; 0x15
    46a2:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    46a4:	c7 01       	movw	r24, r14
    46a6:	0e 94 5b 19 	call	0x32b6	; 0x32b6 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    46aa:	84 30       	cpi	r24, 0x04	; 4
    46ac:	31 f4       	brne	.+12     	; 0x46ba <f_readdir+0x60>
				dj->sect = 0;
    46ae:	f7 01       	movw	r30, r14
    46b0:	16 86       	std	Z+14, r1	; 0x0e
    46b2:	17 86       	std	Z+15, r1	; 0x0f
    46b4:	10 8a       	std	Z+16, r1	; 0x10
    46b6:	11 8a       	std	Z+17, r1	; 0x11
    46b8:	02 c0       	rjmp	.+4      	; 0x46be <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    46ba:	88 23       	and	r24, r24
    46bc:	89 f4       	brne	.+34     	; 0x46e0 <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    46be:	c7 01       	movw	r24, r14
    46c0:	b6 01       	movw	r22, r12
    46c2:	0e 94 55 0a 	call	0x14aa	; 0x14aa <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    46c6:	c7 01       	movw	r24, r14
    46c8:	60 e0       	ldi	r22, 0x00	; 0
    46ca:	70 e0       	ldi	r23, 0x00	; 0
    46cc:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <dir_next>
				if (res == FR_NO_FILE) {
    46d0:	84 30       	cpi	r24, 0x04	; 4
    46d2:	41 f4       	brne	.+16     	; 0x46e4 <f_readdir+0x8a>
					dj->sect = 0;
    46d4:	f7 01       	movw	r30, r14
    46d6:	16 86       	std	Z+14, r1	; 0x0e
    46d8:	17 86       	std	Z+15, r1	; 0x0f
    46da:	10 8a       	std	Z+16, r1	; 0x10
    46dc:	11 8a       	std	Z+17, r1	; 0x11
    46de:	03 c0       	rjmp	.+6      	; 0x46e6 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    46e0:	18 2f       	mov	r17, r24
    46e2:	01 c0       	rjmp	.+2      	; 0x46e6 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    46e4:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    46e6:	81 2f       	mov	r24, r17
    46e8:	2c 96       	adiw	r28, 0x0c	; 12
    46ea:	0f b6       	in	r0, 0x3f	; 63
    46ec:	f8 94       	cli
    46ee:	de bf       	out	0x3e, r29	; 62
    46f0:	0f be       	out	0x3f, r0	; 63
    46f2:	cd bf       	out	0x3d, r28	; 61
    46f4:	df 91       	pop	r29
    46f6:	cf 91       	pop	r28
    46f8:	1f 91       	pop	r17
    46fa:	ff 90       	pop	r15
    46fc:	ef 90       	pop	r14
    46fe:	df 90       	pop	r13
    4700:	cf 90       	pop	r12
    4702:	08 95       	ret

00004704 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4704:	ef 92       	push	r14
    4706:	ff 92       	push	r15
    4708:	1f 93       	push	r17
    470a:	cf 93       	push	r28
    470c:	df 93       	push	r29
    470e:	cd b7       	in	r28, 0x3d	; 61
    4710:	de b7       	in	r29, 0x3e	; 62
    4712:	a4 97       	sbiw	r28, 0x24	; 36
    4714:	0f b6       	in	r0, 0x3f	; 63
    4716:	f8 94       	cli
    4718:	de bf       	out	0x3e, r29	; 62
    471a:	0f be       	out	0x3f, r0	; 63
    471c:	cd bf       	out	0x3d, r28	; 61
    471e:	9c a3       	lds	r25, 0x5c
    4720:	8b a3       	lds	r24, 0x5b
    4722:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    4724:	ce 01       	movw	r24, r28
    4726:	83 96       	adiw	r24, 0x23	; 35
    4728:	be 01       	movw	r22, r28
    472a:	6f 5f       	subi	r22, 0xFF	; 255
    472c:	7f 4f       	sbci	r23, 0xFF	; 255
    472e:	40 e0       	ldi	r20, 0x00	; 0
    4730:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
    4734:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4736:	88 23       	and	r24, r24
    4738:	c1 f4       	brne	.+48     	; 0x476a <f_stat+0x66>
		INIT_BUF(dj);
    473a:	ce 01       	movw	r24, r28
    473c:	47 96       	adiw	r24, 0x17	; 23
    473e:	9e 8b       	std	Y+22, r25	; 0x16
    4740:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    4742:	6b a1       	lds	r22, 0x4b
    4744:	7c a1       	lds	r23, 0x4c
    4746:	ce 01       	movw	r24, r28
    4748:	01 96       	adiw	r24, 0x01	; 1
    474a:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
    474e:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4750:	88 23       	and	r24, r24
    4752:	59 f4       	brne	.+22     	; 0x476a <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    4754:	8b 89       	ldd	r24, Y+19	; 0x13
    4756:	9c 89       	ldd	r25, Y+20	; 0x14
    4758:	00 97       	sbiw	r24, 0x00	; 0
    475a:	31 f0       	breq	.+12     	; 0x4768 <f_stat+0x64>
				get_fileinfo(&dj, fno);
    475c:	ce 01       	movw	r24, r28
    475e:	01 96       	adiw	r24, 0x01	; 1
    4760:	b7 01       	movw	r22, r14
    4762:	0e 94 55 0a 	call	0x14aa	; 0x14aa <get_fileinfo>
    4766:	01 c0       	rjmp	.+2      	; 0x476a <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    4768:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    476a:	81 2f       	mov	r24, r17
    476c:	a4 96       	adiw	r28, 0x24	; 36
    476e:	0f b6       	in	r0, 0x3f	; 63
    4770:	f8 94       	cli
    4772:	de bf       	out	0x3e, r29	; 62
    4774:	0f be       	out	0x3f, r0	; 63
    4776:	cd bf       	out	0x3d, r28	; 61
    4778:	df 91       	pop	r29
    477a:	cf 91       	pop	r28
    477c:	1f 91       	pop	r17
    477e:	ff 90       	pop	r15
    4780:	ef 90       	pop	r14
    4782:	08 95       	ret

00004784 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    4784:	2f 92       	push	r2
    4786:	3f 92       	push	r3
    4788:	4f 92       	push	r4
    478a:	5f 92       	push	r5
    478c:	6f 92       	push	r6
    478e:	7f 92       	push	r7
    4790:	8f 92       	push	r8
    4792:	9f 92       	push	r9
    4794:	af 92       	push	r10
    4796:	bf 92       	push	r11
    4798:	cf 92       	push	r12
    479a:	df 92       	push	r13
    479c:	ef 92       	push	r14
    479e:	ff 92       	push	r15
    47a0:	0f 93       	push	r16
    47a2:	1f 93       	push	r17
    47a4:	cf 93       	push	r28
    47a6:	df 93       	push	r29
    47a8:	cd b7       	in	r28, 0x3d	; 61
    47aa:	de b7       	in	r29, 0x3e	; 62
    47ac:	2c 97       	sbiw	r28, 0x0c	; 12
    47ae:	0f b6       	in	r0, 0x3f	; 63
    47b0:	f8 94       	cli
    47b2:	de bf       	out	0x3e, r29	; 62
    47b4:	0f be       	out	0x3f, r0	; 63
    47b6:	cd bf       	out	0x3d, r28	; 61
    47b8:	9a 83       	std	Y+2, r25	; 0x02
    47ba:	89 83       	std	Y+1, r24	; 0x01
    47bc:	78 87       	std	Y+8, r23	; 0x08
    47be:	6f 83       	std	Y+7, r22	; 0x07
    47c0:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    47c2:	ce 01       	movw	r24, r28
    47c4:	01 96       	adiw	r24, 0x01	; 1
    47c6:	ba 01       	movw	r22, r20
    47c8:	40 e0       	ldi	r20, 0x00	; 0
    47ca:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
    47ce:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    47d0:	d8 01       	movw	r26, r16
    47d2:	8d 90       	ld	r8, X+
    47d4:	9c 90       	ld	r9, X
    47d6:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    47d8:	88 23       	and	r24, r24
    47da:	09 f0       	breq	.+2      	; 0x47de <f_getfree+0x5a>
    47dc:	03 c1       	rjmp	.+518    	; 0x49e4 <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    47de:	f4 01       	movw	r30, r8
    47e0:	86 85       	ldd	r24, Z+14	; 0x0e
    47e2:	97 85       	ldd	r25, Z+15	; 0x0f
    47e4:	a0 89       	ldd	r26, Z+16	; 0x10
    47e6:	b1 89       	ldd	r27, Z+17	; 0x11
    47e8:	c2 8c       	ldd	r12, Z+26	; 0x1a
    47ea:	d3 8c       	ldd	r13, Z+27	; 0x1b
    47ec:	e4 8c       	ldd	r14, Z+28	; 0x1c
    47ee:	f5 8c       	ldd	r15, Z+29	; 0x1d
    47f0:	b7 01       	movw	r22, r14
    47f2:	a6 01       	movw	r20, r12
    47f4:	42 50       	subi	r20, 0x02	; 2
    47f6:	50 40       	sbci	r21, 0x00	; 0
    47f8:	60 40       	sbci	r22, 0x00	; 0
    47fa:	70 40       	sbci	r23, 0x00	; 0
    47fc:	48 17       	cp	r20, r24
    47fe:	59 07       	cpc	r21, r25
    4800:	6a 07       	cpc	r22, r26
    4802:	7b 07       	cpc	r23, r27
    4804:	38 f0       	brcs	.+14     	; 0x4814 <f_getfree+0x90>
			*nclst = fs->free_clust;
    4806:	ef 81       	ldd	r30, Y+7	; 0x07
    4808:	f8 85       	ldd	r31, Y+8	; 0x08
    480a:	80 83       	st	Z, r24
    480c:	91 83       	std	Z+1, r25	; 0x01
    480e:	a2 83       	std	Z+2, r26	; 0x02
    4810:	b3 83       	std	Z+3, r27	; 0x03
    4812:	e8 c0       	rjmp	.+464    	; 0x49e4 <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    4814:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    4816:	b1 e0       	ldi	r27, 0x01	; 1
    4818:	ab 16       	cp	r10, r27
    481a:	d9 f5       	brne	.+118    	; 0x4892 <f_getfree+0x10e>
    481c:	cc 24       	eor	r12, r12
    481e:	dd 24       	eor	r13, r13
    4820:	76 01       	movw	r14, r12
    4822:	68 94       	set
    4824:	c1 f8       	bld	r12, 1
    4826:	44 24       	eor	r4, r4
    4828:	55 24       	eor	r5, r5
    482a:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    482c:	c4 01       	movw	r24, r8
    482e:	b7 01       	movw	r22, r14
    4830:	a6 01       	movw	r20, r12
    4832:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    4836:	dc 01       	movw	r26, r24
    4838:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    483a:	8f 3f       	cpi	r24, 0xFF	; 255
    483c:	ef ef       	ldi	r30, 0xFF	; 255
    483e:	9e 07       	cpc	r25, r30
    4840:	ef ef       	ldi	r30, 0xFF	; 255
    4842:	ae 07       	cpc	r26, r30
    4844:	ef ef       	ldi	r30, 0xFF	; 255
    4846:	be 07       	cpc	r27, r30
    4848:	09 f4       	brne	.+2      	; 0x484c <f_getfree+0xc8>
    484a:	b0 c0       	rjmp	.+352    	; 0x49ac <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    484c:	81 30       	cpi	r24, 0x01	; 1
    484e:	91 05       	cpc	r25, r1
    4850:	a1 05       	cpc	r26, r1
    4852:	b1 05       	cpc	r27, r1
    4854:	09 f4       	brne	.+2      	; 0x4858 <f_getfree+0xd4>
    4856:	ad c0       	rjmp	.+346    	; 0x49b2 <f_getfree+0x22e>
					if (stat == 0) n++;
    4858:	00 97       	sbiw	r24, 0x00	; 0
    485a:	a1 05       	cpc	r26, r1
    485c:	b1 05       	cpc	r27, r1
    485e:	29 f4       	brne	.+10     	; 0x486a <f_getfree+0xe6>
    4860:	08 94       	sec
    4862:	41 1c       	adc	r4, r1
    4864:	51 1c       	adc	r5, r1
    4866:	61 1c       	adc	r6, r1
    4868:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    486a:	08 94       	sec
    486c:	c1 1c       	adc	r12, r1
    486e:	d1 1c       	adc	r13, r1
    4870:	e1 1c       	adc	r14, r1
    4872:	f1 1c       	adc	r15, r1
    4874:	f4 01       	movw	r30, r8
    4876:	82 8d       	ldd	r24, Z+26	; 0x1a
    4878:	93 8d       	ldd	r25, Z+27	; 0x1b
    487a:	a4 8d       	ldd	r26, Z+28	; 0x1c
    487c:	b5 8d       	ldd	r27, Z+29	; 0x1d
    487e:	c8 16       	cp	r12, r24
    4880:	d9 06       	cpc	r13, r25
    4882:	ea 06       	cpc	r14, r26
    4884:	fb 06       	cpc	r15, r27
    4886:	90 f2       	brcs	.-92     	; 0x482c <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4888:	46 86       	std	Z+14, r4	; 0x0e
    488a:	57 86       	std	Z+15, r5	; 0x0f
    488c:	60 8a       	std	Z+16, r6	; 0x10
    488e:	71 8a       	std	Z+17, r7	; 0x11
    4890:	a2 c0       	rjmp	.+324    	; 0x49d6 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    4892:	82 a1       	lds	r24, 0x42
    4894:	93 a1       	lds	r25, 0x43
    4896:	a4 a1       	lds	r26, 0x44
    4898:	b5 a1       	lds	r27, 0x45
    489a:	8b 83       	std	Y+3, r24	; 0x03
    489c:	9c 83       	std	Y+4, r25	; 0x04
    489e:	ad 83       	std	Y+5, r26	; 0x05
    48a0:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    48a2:	e0 e0       	ldi	r30, 0x00	; 0
    48a4:	f0 e0       	ldi	r31, 0x00	; 0
    48a6:	00 e0       	ldi	r16, 0x00	; 0
    48a8:	10 e0       	ldi	r17, 0x00	; 0
    48aa:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    48ac:	44 24       	eor	r4, r4
    48ae:	55 24       	eor	r5, r5
    48b0:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    48b2:	a4 01       	movw	r20, r8
    48b4:	4e 5c       	subi	r20, 0xCE	; 206
    48b6:	5f 4f       	sbci	r21, 0xFF	; 255
    48b8:	5c 87       	std	Y+12, r21	; 0x0c
    48ba:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    48bc:	01 15       	cp	r16, r1
    48be:	11 05       	cpc	r17, r1
    48c0:	21 05       	cpc	r18, r1
    48c2:	31 05       	cpc	r19, r1
    48c4:	d9 f4       	brne	.+54     	; 0x48fc <f_getfree+0x178>
						res = move_window(fs, sect++);
    48c6:	c4 01       	movw	r24, r8
    48c8:	4b 81       	ldd	r20, Y+3	; 0x03
    48ca:	5c 81       	ldd	r21, Y+4	; 0x04
    48cc:	6d 81       	ldd	r22, Y+5	; 0x05
    48ce:	7e 81       	ldd	r23, Y+6	; 0x06
    48d0:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
						if (res != FR_OK) break;
    48d4:	88 23       	and	r24, r24
    48d6:	09 f0       	breq	.+2      	; 0x48da <f_getfree+0x156>
    48d8:	70 c0       	rjmp	.+224    	; 0x49ba <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    48da:	8b 81       	ldd	r24, Y+3	; 0x03
    48dc:	9c 81       	ldd	r25, Y+4	; 0x04
    48de:	ad 81       	ldd	r26, Y+5	; 0x05
    48e0:	be 81       	ldd	r27, Y+6	; 0x06
    48e2:	01 96       	adiw	r24, 0x01	; 1
    48e4:	a1 1d       	adc	r26, r1
    48e6:	b1 1d       	adc	r27, r1
    48e8:	8b 83       	std	Y+3, r24	; 0x03
    48ea:	9c 83       	std	Y+4, r25	; 0x04
    48ec:	ad 83       	std	Y+5, r26	; 0x05
    48ee:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    48f0:	eb 85       	ldd	r30, Y+11	; 0x0b
    48f2:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    48f4:	00 e0       	ldi	r16, 0x00	; 0
    48f6:	12 e0       	ldi	r17, 0x02	; 2
    48f8:	20 e0       	ldi	r18, 0x00	; 0
    48fa:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    48fc:	92 e0       	ldi	r25, 0x02	; 2
    48fe:	a9 16       	cp	r10, r25
    4900:	b1 f4       	brne	.+44     	; 0x492e <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    4902:	a1 81       	ldd	r26, Z+1	; 0x01
    4904:	aa 87       	std	Y+10, r26	; 0x0a
    4906:	19 86       	std	Y+9, r1	; 0x09
    4908:	80 81       	ld	r24, Z
    490a:	90 e0       	ldi	r25, 0x00	; 0
    490c:	49 85       	ldd	r20, Y+9	; 0x09
    490e:	5a 85       	ldd	r21, Y+10	; 0x0a
    4910:	84 2b       	or	r24, r20
    4912:	95 2b       	or	r25, r21
    4914:	00 97       	sbiw	r24, 0x00	; 0
    4916:	29 f4       	brne	.+10     	; 0x4922 <f_getfree+0x19e>
    4918:	08 94       	sec
    491a:	41 1c       	adc	r4, r1
    491c:	51 1c       	adc	r5, r1
    491e:	61 1c       	adc	r6, r1
    4920:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    4922:	32 96       	adiw	r30, 0x02	; 2
    4924:	02 50       	subi	r16, 0x02	; 2
    4926:	10 40       	sbci	r17, 0x00	; 0
    4928:	20 40       	sbci	r18, 0x00	; 0
    492a:	30 40       	sbci	r19, 0x00	; 0
    492c:	33 c0       	rjmp	.+102    	; 0x4994 <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    492e:	83 81       	ldd	r24, Z+3	; 0x03
    4930:	90 e0       	ldi	r25, 0x00	; 0
    4932:	a0 e0       	ldi	r26, 0x00	; 0
    4934:	b0 e0       	ldi	r27, 0x00	; 0
    4936:	78 2f       	mov	r23, r24
    4938:	66 27       	eor	r22, r22
    493a:	55 27       	eor	r21, r21
    493c:	44 27       	eor	r20, r20
    493e:	82 81       	ldd	r24, Z+2	; 0x02
    4940:	90 e0       	ldi	r25, 0x00	; 0
    4942:	a0 e0       	ldi	r26, 0x00	; 0
    4944:	b0 e0       	ldi	r27, 0x00	; 0
    4946:	dc 01       	movw	r26, r24
    4948:	99 27       	eor	r25, r25
    494a:	88 27       	eor	r24, r24
    494c:	48 2b       	or	r20, r24
    494e:	59 2b       	or	r21, r25
    4950:	6a 2b       	or	r22, r26
    4952:	7b 2b       	or	r23, r27
    4954:	80 81       	ld	r24, Z
    4956:	90 e0       	ldi	r25, 0x00	; 0
    4958:	a0 e0       	ldi	r26, 0x00	; 0
    495a:	b0 e0       	ldi	r27, 0x00	; 0
    495c:	84 2b       	or	r24, r20
    495e:	95 2b       	or	r25, r21
    4960:	a6 2b       	or	r26, r22
    4962:	b7 2b       	or	r27, r23
    4964:	31 80       	ldd	r3, Z+1	; 0x01
    4966:	22 24       	eor	r2, r2
    4968:	a1 01       	movw	r20, r2
    496a:	60 e0       	ldi	r22, 0x00	; 0
    496c:	70 e0       	ldi	r23, 0x00	; 0
    496e:	84 2b       	or	r24, r20
    4970:	95 2b       	or	r25, r21
    4972:	a6 2b       	or	r26, r22
    4974:	b7 2b       	or	r27, r23
    4976:	bf 70       	andi	r27, 0x0F	; 15
    4978:	00 97       	sbiw	r24, 0x00	; 0
    497a:	a1 05       	cpc	r26, r1
    497c:	b1 05       	cpc	r27, r1
    497e:	29 f4       	brne	.+10     	; 0x498a <f_getfree+0x206>
    4980:	08 94       	sec
    4982:	41 1c       	adc	r4, r1
    4984:	51 1c       	adc	r5, r1
    4986:	61 1c       	adc	r6, r1
    4988:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    498a:	34 96       	adiw	r30, 0x04	; 4
    498c:	04 50       	subi	r16, 0x04	; 4
    498e:	10 40       	sbci	r17, 0x00	; 0
    4990:	20 40       	sbci	r18, 0x00	; 0
    4992:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    4994:	08 94       	sec
    4996:	c1 08       	sbc	r12, r1
    4998:	d1 08       	sbc	r13, r1
    499a:	e1 08       	sbc	r14, r1
    499c:	f1 08       	sbc	r15, r1
    499e:	c1 14       	cp	r12, r1
    49a0:	d1 04       	cpc	r13, r1
    49a2:	e1 04       	cpc	r14, r1
    49a4:	f1 04       	cpc	r15, r1
    49a6:	09 f0       	breq	.+2      	; 0x49aa <f_getfree+0x226>
    49a8:	89 cf       	rjmp	.-238    	; 0x48bc <f_getfree+0x138>
    49aa:	08 c0       	rjmp	.+16     	; 0x49bc <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    49ac:	bb 24       	eor	r11, r11
    49ae:	b3 94       	inc	r11
    49b0:	05 c0       	rjmp	.+10     	; 0x49bc <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    49b2:	bb 24       	eor	r11, r11
    49b4:	68 94       	set
    49b6:	b1 f8       	bld	r11, 1
    49b8:	01 c0       	rjmp	.+2      	; 0x49bc <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    49ba:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    49bc:	d4 01       	movw	r26, r8
    49be:	1e 96       	adiw	r26, 0x0e	; 14
    49c0:	4d 92       	st	X+, r4
    49c2:	5d 92       	st	X+, r5
    49c4:	6d 92       	st	X+, r6
    49c6:	7c 92       	st	X, r7
    49c8:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    49ca:	b3 e0       	ldi	r27, 0x03	; 3
    49cc:	ab 16       	cp	r10, r27
    49ce:	19 f4       	brne	.+6      	; 0x49d6 <f_getfree+0x252>
    49d0:	81 e0       	ldi	r24, 0x01	; 1
    49d2:	f4 01       	movw	r30, r8
    49d4:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    49d6:	af 81       	ldd	r26, Y+7	; 0x07
    49d8:	b8 85       	ldd	r27, Y+8	; 0x08
    49da:	4d 92       	st	X+, r4
    49dc:	5d 92       	st	X+, r5
    49de:	6d 92       	st	X+, r6
    49e0:	7c 92       	st	X, r7
    49e2:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    49e4:	8b 2d       	mov	r24, r11
    49e6:	2c 96       	adiw	r28, 0x0c	; 12
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	f8 94       	cli
    49ec:	de bf       	out	0x3e, r29	; 62
    49ee:	0f be       	out	0x3f, r0	; 63
    49f0:	cd bf       	out	0x3d, r28	; 61
    49f2:	df 91       	pop	r29
    49f4:	cf 91       	pop	r28
    49f6:	1f 91       	pop	r17
    49f8:	0f 91       	pop	r16
    49fa:	ff 90       	pop	r15
    49fc:	ef 90       	pop	r14
    49fe:	df 90       	pop	r13
    4a00:	cf 90       	pop	r12
    4a02:	bf 90       	pop	r11
    4a04:	af 90       	pop	r10
    4a06:	9f 90       	pop	r9
    4a08:	8f 90       	pop	r8
    4a0a:	7f 90       	pop	r7
    4a0c:	6f 90       	pop	r6
    4a0e:	5f 90       	pop	r5
    4a10:	4f 90       	pop	r4
    4a12:	3f 90       	pop	r3
    4a14:	2f 90       	pop	r2
    4a16:	08 95       	ret

00004a18 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4a18:	cf 92       	push	r12
    4a1a:	df 92       	push	r13
    4a1c:	ef 92       	push	r14
    4a1e:	ff 92       	push	r15
    4a20:	0f 93       	push	r16
    4a22:	1f 93       	push	r17
    4a24:	cf 93       	push	r28
    4a26:	df 93       	push	r29
    4a28:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4a2a:	00 97       	sbiw	r24, 0x00	; 0
    4a2c:	09 f4       	brne	.+2      	; 0x4a30 <f_truncate+0x18>
    4a2e:	69 c0       	rjmp	.+210    	; 0x4b02 <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    4a30:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <validate>
	if (res == FR_OK) {
    4a34:	88 23       	and	r24, r24
    4a36:	09 f0       	breq	.+2      	; 0x4a3a <f_truncate+0x22>
    4a38:	65 c0       	rjmp	.+202    	; 0x4b04 <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3c:	99 23       	and	r25, r25
    4a3e:	24 f0       	brlt	.+8      	; 0x4a48 <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    4a40:	91 fd       	sbrc	r25, 1
    4a42:	69 c0       	rjmp	.+210    	; 0x4b16 <f_truncate+0xfe>
				res = FR_DENIED;
    4a44:	87 e0       	ldi	r24, 0x07	; 7
    4a46:	5e c0       	rjmp	.+188    	; 0x4b04 <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4a48:	82 e0       	ldi	r24, 0x02	; 2
    4a4a:	5c c0       	rjmp	.+184    	; 0x4b04 <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4a4c:	4a 87       	std	Y+10, r20	; 0x0a
    4a4e:	5b 87       	std	Y+11, r21	; 0x0b
    4a50:	6c 87       	std	Y+12, r22	; 0x0c
    4a52:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    4a54:	8c 81       	ldd	r24, Y+4	; 0x04
    4a56:	80 62       	ori	r24, 0x20	; 32
    4a58:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4a5a:	41 15       	cp	r20, r1
    4a5c:	51 05       	cpc	r21, r1
    4a5e:	61 05       	cpc	r22, r1
    4a60:	71 05       	cpc	r23, r1
    4a62:	69 f4       	brne	.+26     	; 0x4a7e <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    4a64:	4e 85       	ldd	r20, Y+14	; 0x0e
    4a66:	5f 85       	ldd	r21, Y+15	; 0x0f
    4a68:	68 89       	ldd	r22, Y+16	; 0x10
    4a6a:	79 89       	ldd	r23, Y+17	; 0x11
    4a6c:	88 81       	ld	r24, Y
    4a6e:	99 81       	ldd	r25, Y+1	; 0x01
    4a70:	0e 94 8b 19 	call	0x3316	; 0x3316 <remove_chain>
				fp->sclust = 0;
    4a74:	1e 86       	std	Y+14, r1	; 0x0e
    4a76:	1f 86       	std	Y+15, r1	; 0x0f
    4a78:	18 8a       	std	Y+16, r1	; 0x10
    4a7a:	19 8a       	std	Y+17, r1	; 0x11
    4a7c:	3c c0       	rjmp	.+120    	; 0x4af6 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4a7e:	4a 89       	ldd	r20, Y+18	; 0x12
    4a80:	5b 89       	ldd	r21, Y+19	; 0x13
    4a82:	6c 89       	ldd	r22, Y+20	; 0x14
    4a84:	7d 89       	ldd	r23, Y+21	; 0x15
    4a86:	88 81       	ld	r24, Y
    4a88:	99 81       	ldd	r25, Y+1	; 0x01
    4a8a:	0e 94 41 11 	call	0x2282	; 0x2282 <get_fat>
    4a8e:	6b 01       	movw	r12, r22
    4a90:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4a92:	81 e0       	ldi	r24, 0x01	; 1
    4a94:	c8 16       	cp	r12, r24
    4a96:	d1 04       	cpc	r13, r1
    4a98:	e1 04       	cpc	r14, r1
    4a9a:	f1 04       	cpc	r15, r1
    4a9c:	09 f4       	brne	.+2      	; 0x4aa0 <f_truncate+0x88>
    4a9e:	4a c0       	rjmp	.+148    	; 0x4b34 <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    4aa0:	81 e0       	ldi	r24, 0x01	; 1
    4aa2:	9f ef       	ldi	r25, 0xFF	; 255
    4aa4:	c9 16       	cp	r12, r25
    4aa6:	9f ef       	ldi	r25, 0xFF	; 255
    4aa8:	d9 06       	cpc	r13, r25
    4aaa:	9f ef       	ldi	r25, 0xFF	; 255
    4aac:	e9 06       	cpc	r14, r25
    4aae:	9f ef       	ldi	r25, 0xFF	; 255
    4ab0:	f9 06       	cpc	r15, r25
    4ab2:	09 f0       	breq	.+2      	; 0x4ab6 <f_truncate+0x9e>
    4ab4:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4ab6:	88 23       	and	r24, r24
    4ab8:	01 f5       	brne	.+64     	; 0x4afa <f_truncate+0xe2>
    4aba:	e8 81       	ld	r30, Y
    4abc:	f9 81       	ldd	r31, Y+1	; 0x01
    4abe:	42 8d       	ldd	r20, Z+26	; 0x1a
    4ac0:	53 8d       	ldd	r21, Z+27	; 0x1b
    4ac2:	64 8d       	ldd	r22, Z+28	; 0x1c
    4ac4:	75 8d       	ldd	r23, Z+29	; 0x1d
    4ac6:	c4 16       	cp	r12, r20
    4ac8:	d5 06       	cpc	r13, r21
    4aca:	e6 06       	cpc	r14, r22
    4acc:	f7 06       	cpc	r15, r23
    4ace:	d0 f4       	brcc	.+52     	; 0x4b04 <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    4ad0:	4a 89       	ldd	r20, Y+18	; 0x12
    4ad2:	5b 89       	ldd	r21, Y+19	; 0x13
    4ad4:	6c 89       	ldd	r22, Y+20	; 0x14
    4ad6:	7d 89       	ldd	r23, Y+21	; 0x15
    4ad8:	cf 01       	movw	r24, r30
    4ada:	0f ef       	ldi	r16, 0xFF	; 255
    4adc:	1f ef       	ldi	r17, 0xFF	; 255
    4ade:	2f ef       	ldi	r18, 0xFF	; 255
    4ae0:	3f e0       	ldi	r19, 0x0F	; 15
    4ae2:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4ae6:	88 23       	and	r24, r24
    4ae8:	41 f4       	brne	.+16     	; 0x4afa <f_truncate+0xe2>
    4aea:	88 81       	ld	r24, Y
    4aec:	99 81       	ldd	r25, Y+1	; 0x01
    4aee:	b7 01       	movw	r22, r14
    4af0:	a6 01       	movw	r20, r12
    4af2:	0e 94 8b 19 	call	0x3316	; 0x3316 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4af6:	88 23       	and	r24, r24
    4af8:	29 f0       	breq	.+10     	; 0x4b04 <f_truncate+0xec>
    4afa:	9c 81       	ldd	r25, Y+4	; 0x04
    4afc:	90 68       	ori	r25, 0x80	; 128
    4afe:	9c 83       	std	Y+4, r25	; 0x04
    4b00:	01 c0       	rjmp	.+2      	; 0x4b04 <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4b02:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    4b04:	df 91       	pop	r29
    4b06:	cf 91       	pop	r28
    4b08:	1f 91       	pop	r17
    4b0a:	0f 91       	pop	r16
    4b0c:	ff 90       	pop	r15
    4b0e:	ef 90       	pop	r14
    4b10:	df 90       	pop	r13
    4b12:	cf 90       	pop	r12
    4b14:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4b16:	4e 81       	ldd	r20, Y+6	; 0x06
    4b18:	5f 81       	ldd	r21, Y+7	; 0x07
    4b1a:	68 85       	ldd	r22, Y+8	; 0x08
    4b1c:	79 85       	ldd	r23, Y+9	; 0x09
    4b1e:	0a 85       	ldd	r16, Y+10	; 0x0a
    4b20:	1b 85       	ldd	r17, Y+11	; 0x0b
    4b22:	2c 85       	ldd	r18, Y+12	; 0x0c
    4b24:	3d 85       	ldd	r19, Y+13	; 0x0d
    4b26:	40 17       	cp	r20, r16
    4b28:	51 07       	cpc	r21, r17
    4b2a:	62 07       	cpc	r22, r18
    4b2c:	73 07       	cpc	r23, r19
    4b2e:	08 f4       	brcc	.+2      	; 0x4b32 <f_truncate+0x11a>
    4b30:	8d cf       	rjmp	.-230    	; 0x4a4c <f_truncate+0x34>
    4b32:	e8 cf       	rjmp	.-48     	; 0x4b04 <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4b34:	82 e0       	ldi	r24, 0x02	; 2
    4b36:	e1 cf       	rjmp	.-62     	; 0x4afa <f_truncate+0xe2>

00004b38 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4b38:	cf 92       	push	r12
    4b3a:	df 92       	push	r13
    4b3c:	ef 92       	push	r14
    4b3e:	ff 92       	push	r15
    4b40:	1f 93       	push	r17
    4b42:	cf 93       	push	r28
    4b44:	df 93       	push	r29
    4b46:	cd b7       	in	r28, 0x3d	; 61
    4b48:	de b7       	in	r29, 0x3e	; 62
    4b4a:	ea 97       	sbiw	r28, 0x3a	; 58
    4b4c:	0f b6       	in	r0, 0x3f	; 63
    4b4e:	f8 94       	cli
    4b50:	de bf       	out	0x3e, r29	; 62
    4b52:	0f be       	out	0x3f, r0	; 63
    4b54:	cd bf       	out	0x3d, r28	; 61
    4b56:	9a af       	sts	0x7a, r25
    4b58:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4b5a:	ce 01       	movw	r24, r28
    4b5c:	c9 96       	adiw	r24, 0x39	; 57
    4b5e:	be 01       	movw	r22, r28
    4b60:	6f 5f       	subi	r22, 0xFF	; 255
    4b62:	7f 4f       	sbci	r23, 0xFF	; 255
    4b64:	41 e0       	ldi	r20, 0x01	; 1
    4b66:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
	if (res == FR_OK) {
    4b6a:	88 23       	and	r24, r24
    4b6c:	09 f0       	breq	.+2      	; 0x4b70 <f_unlink+0x38>
    4b6e:	63 c0       	rjmp	.+198    	; 0x4c36 <f_unlink+0xfe>
		INIT_BUF(dj);
    4b70:	ce 01       	movw	r24, r28
    4b72:	8d 96       	adiw	r24, 0x2d	; 45
    4b74:	9e 8b       	std	Y+22, r25	; 0x16
    4b76:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4b78:	69 ad       	sts	0x69, r22
    4b7a:	7a ad       	sts	0x6a, r23
    4b7c:	ce 01       	movw	r24, r28
    4b7e:	01 96       	adiw	r24, 0x01	; 1
    4b80:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4b84:	88 23       	and	r24, r24
    4b86:	09 f0       	breq	.+2      	; 0x4b8a <f_unlink+0x52>
    4b88:	56 c0       	rjmp	.+172    	; 0x4c36 <f_unlink+0xfe>
    4b8a:	ed 89       	ldd	r30, Y+21	; 0x15
    4b8c:	fe 89       	ldd	r31, Y+22	; 0x16
    4b8e:	83 85       	ldd	r24, Z+11	; 0x0b
    4b90:	85 ff       	sbrs	r24, 5
    4b92:	5f c0       	rjmp	.+190    	; 0x4c52 <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    4b94:	86 e0       	ldi	r24, 0x06	; 6
    4b96:	4f c0       	rjmp	.+158    	; 0x4c36 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4b98:	fb 01       	movw	r30, r22
    4b9a:	13 85       	ldd	r17, Z+11	; 0x0b
    4b9c:	10 ff       	sbrs	r17, 0
    4b9e:	60 c0       	rjmp	.+192    	; 0x4c60 <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    4ba0:	87 e0       	ldi	r24, 0x07	; 7
    4ba2:	49 c0       	rjmp	.+146    	; 0x4c36 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    4ba4:	86 e0       	ldi	r24, 0x06	; 6
    4ba6:	47 c0       	rjmp	.+142    	; 0x4c36 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4ba8:	f2 e0       	ldi	r31, 0x02	; 2
    4baa:	cf 16       	cp	r12, r31
    4bac:	d1 04       	cpc	r13, r1
    4bae:	e1 04       	cpc	r14, r1
    4bb0:	f1 04       	cpc	r15, r1
    4bb2:	08 f4       	brcc	.+2      	; 0x4bb6 <f_unlink+0x7e>
    4bb4:	5e c0       	rjmp	.+188    	; 0x4c72 <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4bb6:	ce 01       	movw	r24, r28
    4bb8:	47 96       	adiw	r24, 0x17	; 23
    4bba:	be 01       	movw	r22, r28
    4bbc:	6f 5f       	subi	r22, 0xFF	; 255
    4bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    4bc0:	26 e1       	ldi	r18, 0x16	; 22
    4bc2:	30 e0       	ldi	r19, 0x00	; 0
    4bc4:	40 e0       	ldi	r20, 0x00	; 0
    4bc6:	50 e0       	ldi	r21, 0x00	; 0
    4bc8:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
					sdj.sclust = dclst;
    4bcc:	cd 8e       	std	Y+29, r12	; 0x1d
    4bce:	de 8e       	std	Y+30, r13	; 0x1e
    4bd0:	ef 8e       	std	Y+31, r14	; 0x1f
    4bd2:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    4bd4:	ce 01       	movw	r24, r28
    4bd6:	47 96       	adiw	r24, 0x17	; 23
    4bd8:	62 e0       	ldi	r22, 0x02	; 2
    4bda:	70 e0       	ldi	r23, 0x00	; 0
    4bdc:	0e 94 78 12 	call	0x24f0	; 0x24f0 <dir_sdi>
					if (res == FR_OK) {
    4be0:	88 23       	and	r24, r24
    4be2:	49 f5       	brne	.+82     	; 0x4c36 <f_unlink+0xfe>
						res = dir_read(&sdj);
    4be4:	ce 01       	movw	r24, r28
    4be6:	47 96       	adiw	r24, 0x17	; 23
    4be8:	0e 94 5b 19 	call	0x32b6	; 0x32b6 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4bec:	88 23       	and	r24, r24
    4bee:	71 f0       	breq	.+28     	; 0x4c0c <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    4bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    4bf4:	46 89       	ldd	r20, Z+22	; 0x16
    4bf6:	57 89       	ldd	r21, Z+23	; 0x17
    4bf8:	60 8d       	ldd	r22, Z+24	; 0x18
    4bfa:	71 8d       	ldd	r23, Z+25	; 0x19
    4bfc:	4c 15       	cp	r20, r12
    4bfe:	5d 05       	cpc	r21, r13
    4c00:	6e 05       	cpc	r22, r14
    4c02:	7f 05       	cpc	r23, r15
    4c04:	29 f0       	breq	.+10     	; 0x4c10 <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4c06:	84 30       	cpi	r24, 0x04	; 4
    4c08:	b1 f1       	breq	.+108    	; 0x4c76 <f_unlink+0x13e>
    4c0a:	15 c0       	rjmp	.+42     	; 0x4c36 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4c0c:	87 e0       	ldi	r24, 0x07	; 7
    4c0e:	13 c0       	rjmp	.+38     	; 0x4c36 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c10:	87 e0       	ldi	r24, 0x07	; 7
    4c12:	11 c0       	rjmp	.+34     	; 0x4c36 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    4c14:	c1 14       	cp	r12, r1
    4c16:	d1 04       	cpc	r13, r1
    4c18:	e1 04       	cpc	r14, r1
    4c1a:	f1 04       	cpc	r15, r1
    4c1c:	41 f0       	breq	.+16     	; 0x4c2e <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4c1e:	89 81       	ldd	r24, Y+1	; 0x01
    4c20:	9a 81       	ldd	r25, Y+2	; 0x02
    4c22:	b7 01       	movw	r22, r14
    4c24:	a6 01       	movw	r20, r12
    4c26:	0e 94 8b 19 	call	0x3316	; 0x3316 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4c2a:	88 23       	and	r24, r24
    4c2c:	21 f4       	brne	.+8      	; 0x4c36 <f_unlink+0xfe>
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	9a 81       	ldd	r25, Y+2	; 0x02
    4c32:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4c36:	ea 96       	adiw	r28, 0x3a	; 58
    4c38:	0f b6       	in	r0, 0x3f	; 63
    4c3a:	f8 94       	cli
    4c3c:	de bf       	out	0x3e, r29	; 62
    4c3e:	0f be       	out	0x3f, r0	; 63
    4c40:	cd bf       	out	0x3d, r28	; 61
    4c42:	df 91       	pop	r29
    4c44:	cf 91       	pop	r28
    4c46:	1f 91       	pop	r17
    4c48:	ff 90       	pop	r15
    4c4a:	ef 90       	pop	r14
    4c4c:	df 90       	pop	r13
    4c4e:	cf 90       	pop	r12
    4c50:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    4c52:	6b 89       	ldd	r22, Y+19	; 0x13
    4c54:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4c56:	61 15       	cp	r22, r1
    4c58:	71 05       	cpc	r23, r1
    4c5a:	09 f0       	breq	.+2      	; 0x4c5e <f_unlink+0x126>
    4c5c:	9d cf       	rjmp	.-198    	; 0x4b98 <f_unlink+0x60>
    4c5e:	a2 cf       	rjmp	.-188    	; 0x4ba4 <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    4c60:	89 81       	ldd	r24, Y+1	; 0x01
    4c62:	9a 81       	ldd	r25, Y+2	; 0x02
    4c64:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    4c68:	6b 01       	movw	r12, r22
    4c6a:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4c6c:	14 fd       	sbrc	r17, 4
    4c6e:	9c cf       	rjmp	.-200    	; 0x4ba8 <f_unlink+0x70>
    4c70:	02 c0       	rjmp	.+4      	; 0x4c76 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    4c72:	82 e0       	ldi	r24, 0x02	; 2
    4c74:	e0 cf       	rjmp	.-64     	; 0x4c36 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4c76:	ce 01       	movw	r24, r28
    4c78:	01 96       	adiw	r24, 0x01	; 1
    4c7a:	0e 94 3d 13 	call	0x267a	; 0x267a <dir_remove>
				if (res == FR_OK) {
    4c7e:	88 23       	and	r24, r24
    4c80:	49 f2       	breq	.-110    	; 0x4c14 <f_unlink+0xdc>
    4c82:	d9 cf       	rjmp	.-78     	; 0x4c36 <f_unlink+0xfe>

00004c84 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    4c84:	2f 92       	push	r2
    4c86:	3f 92       	push	r3
    4c88:	4f 92       	push	r4
    4c8a:	5f 92       	push	r5
    4c8c:	6f 92       	push	r6
    4c8e:	7f 92       	push	r7
    4c90:	8f 92       	push	r8
    4c92:	9f 92       	push	r9
    4c94:	af 92       	push	r10
    4c96:	bf 92       	push	r11
    4c98:	cf 92       	push	r12
    4c9a:	df 92       	push	r13
    4c9c:	ef 92       	push	r14
    4c9e:	ff 92       	push	r15
    4ca0:	0f 93       	push	r16
    4ca2:	1f 93       	push	r17
    4ca4:	cf 93       	push	r28
    4ca6:	df 93       	push	r29
    4ca8:	cd b7       	in	r28, 0x3d	; 61
    4caa:	de b7       	in	r29, 0x3e	; 62
    4cac:	a8 97       	sbiw	r28, 0x28	; 40
    4cae:	0f b6       	in	r0, 0x3f	; 63
    4cb0:	f8 94       	cli
    4cb2:	de bf       	out	0x3e, r29	; 62
    4cb4:	0f be       	out	0x3f, r0	; 63
    4cb6:	cd bf       	out	0x3d, r28	; 61
    4cb8:	9c a3       	lds	r25, 0x5c
    4cba:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4cbc:	0e 94 07 11 	call	0x220e	; 0x220e <get_fattime>
    4cc0:	6b 01       	movw	r12, r22
    4cc2:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4cc4:	ce 01       	movw	r24, r28
    4cc6:	83 96       	adiw	r24, 0x23	; 35
    4cc8:	be 01       	movw	r22, r28
    4cca:	6f 5f       	subi	r22, 0xFF	; 255
    4ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    4cce:	41 e0       	ldi	r20, 0x01	; 1
    4cd0:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
    4cd4:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4cd6:	88 23       	and	r24, r24
    4cd8:	09 f0       	breq	.+2      	; 0x4cdc <f_mkdir+0x58>
    4cda:	f6 c0       	rjmp	.+492    	; 0x4ec8 <f_mkdir+0x244>
		INIT_BUF(dj);
    4cdc:	ce 01       	movw	r24, r28
    4cde:	47 96       	adiw	r24, 0x17	; 23
    4ce0:	9e 8b       	std	Y+22, r25	; 0x16
    4ce2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4ce4:	6b a1       	lds	r22, 0x4b
    4ce6:	7c a1       	lds	r23, 0x4c
    4ce8:	ce 01       	movw	r24, r28
    4cea:	01 96       	adiw	r24, 0x01	; 1
    4cec:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4cf0:	88 23       	and	r24, r24
    4cf2:	49 f0       	breq	.+18     	; 0x4d06 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4cf4:	84 30       	cpi	r24, 0x04	; 4
    4cf6:	41 f4       	brne	.+16     	; 0x4d08 <f_mkdir+0x84>
    4cf8:	ed 89       	ldd	r30, Y+21	; 0x15
    4cfa:	fe 89       	ldd	r31, Y+22	; 0x16
    4cfc:	83 85       	ldd	r24, Z+11	; 0x0b
    4cfe:	85 ff       	sbrs	r24, 5
    4d00:	fd c0       	rjmp	.+506    	; 0x4efc <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4d02:	86 e0       	ldi	r24, 0x06	; 6
    4d04:	01 c0       	rjmp	.+2      	; 0x4d08 <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d06:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4d08:	18 2f       	mov	r17, r24
    4d0a:	de c0       	rjmp	.+444    	; 0x4ec8 <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4d0c:	81 e0       	ldi	r24, 0x01	; 1
    4d0e:	48 16       	cp	r4, r24
    4d10:	51 04       	cpc	r5, r1
    4d12:	61 04       	cpc	r6, r1
    4d14:	71 04       	cpc	r7, r1
    4d16:	09 f4       	brne	.+2      	; 0x4d1a <f_mkdir+0x96>
    4d18:	01 c1       	rjmp	.+514    	; 0x4f1c <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4d1a:	ef ef       	ldi	r30, 0xFF	; 255
    4d1c:	4e 16       	cp	r4, r30
    4d1e:	ef ef       	ldi	r30, 0xFF	; 255
    4d20:	5e 06       	cpc	r5, r30
    4d22:	ef ef       	ldi	r30, 0xFF	; 255
    4d24:	6e 06       	cpc	r6, r30
    4d26:	ef ef       	ldi	r30, 0xFF	; 255
    4d28:	7e 06       	cpc	r7, r30
    4d2a:	09 f4       	brne	.+2      	; 0x4d2e <f_mkdir+0xaa>
    4d2c:	f9 c0       	rjmp	.+498    	; 0x4f20 <f_mkdir+0x29c>
    4d2e:	01 c0       	rjmp	.+2      	; 0x4d32 <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4d30:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4d32:	11 23       	and	r17, r17
    4d34:	09 f0       	breq	.+2      	; 0x4d38 <f_mkdir+0xb4>
    4d36:	a8 c0       	rjmp	.+336    	; 0x4e88 <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4d38:	89 81       	ldd	r24, Y+1	; 0x01
    4d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d3c:	40 e0       	ldi	r20, 0x00	; 0
    4d3e:	50 e0       	ldi	r21, 0x00	; 0
    4d40:	ba 01       	movw	r22, r20
    4d42:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    4d46:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4d48:	88 23       	and	r24, r24
    4d4a:	09 f0       	breq	.+2      	; 0x4d4e <f_mkdir+0xca>
    4d4c:	9d c0       	rjmp	.+314    	; 0x4e88 <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4d4e:	09 81       	ldd	r16, Y+1	; 0x01
    4d50:	1a 81       	ldd	r17, Y+2	; 0x02
    4d52:	c8 01       	movw	r24, r16
    4d54:	b3 01       	movw	r22, r6
    4d56:	a2 01       	movw	r20, r4
    4d58:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    4d5c:	4b 01       	movw	r8, r22
    4d5e:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4d60:	0f 2e       	mov	r0, r31
    4d62:	f2 e3       	ldi	r31, 0x32	; 50
    4d64:	2f 2e       	mov	r2, r31
    4d66:	33 24       	eor	r3, r3
    4d68:	f0 2d       	mov	r31, r0
    4d6a:	20 0e       	add	r2, r16
    4d6c:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4d6e:	c1 01       	movw	r24, r2
    4d70:	60 e0       	ldi	r22, 0x00	; 0
    4d72:	70 e0       	ldi	r23, 0x00	; 0
    4d74:	20 e0       	ldi	r18, 0x00	; 0
    4d76:	32 e0       	ldi	r19, 0x02	; 2
    4d78:	40 e0       	ldi	r20, 0x00	; 0
    4d7a:	50 e0       	ldi	r21, 0x00	; 0
    4d7c:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4d80:	c1 01       	movw	r24, r2
    4d82:	60 e2       	ldi	r22, 0x20	; 32
    4d84:	70 e0       	ldi	r23, 0x00	; 0
    4d86:	2b e0       	ldi	r18, 0x0B	; 11
    4d88:	30 e0       	ldi	r19, 0x00	; 0
    4d8a:	40 e0       	ldi	r20, 0x00	; 0
    4d8c:	50 e0       	ldi	r21, 0x00	; 0
    4d8e:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
				dir[DIR_Name] = '.';
    4d92:	8e e2       	ldi	r24, 0x2E	; 46
    4d94:	f8 01       	movw	r30, r16
    4d96:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4d98:	80 e1       	ldi	r24, 0x10	; 16
    4d9a:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4d9c:	cd a2       	lds	r28, 0x9d
    4d9e:	e8 5b       	subi	r30, 0xB8	; 184
    4da0:	ff 4f       	sbci	r31, 0xFF	; 255
    4da2:	c0 82       	st	Z, r12
    4da4:	8d 2d       	mov	r24, r13
    4da6:	99 27       	eor	r25, r25
    4da8:	8e a3       	lds	r24, 0x5e
    4daa:	f8 01       	movw	r30, r16
    4dac:	e7 5b       	subi	r30, 0xB7	; 183
    4dae:	ff 4f       	sbci	r31, 0xFF	; 255
    4db0:	80 83       	st	Z, r24
    4db2:	c7 01       	movw	r24, r14
    4db4:	aa 27       	eor	r26, r26
    4db6:	bb 27       	eor	r27, r27
    4db8:	8f a3       	lds	r24, 0x5f
    4dba:	f8 01       	movw	r30, r16
    4dbc:	e6 5b       	subi	r30, 0xB6	; 182
    4dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    4dc0:	80 83       	st	Z, r24
    4dc2:	cf 2c       	mov	r12, r15
    4dc4:	dd 24       	eor	r13, r13
    4dc6:	ee 24       	eor	r14, r14
    4dc8:	ff 24       	eor	r15, r15
    4dca:	c8 a6       	lds	r28, 0xb8
    4dcc:	f8 01       	movw	r30, r16
    4dce:	e5 5b       	subi	r30, 0xB5	; 181
    4dd0:	ff 4f       	sbci	r31, 0xFF	; 255
    4dd2:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4dd4:	c1 01       	movw	r24, r2
    4dd6:	b3 01       	movw	r22, r6
    4dd8:	a2 01       	movw	r20, r4
    4dda:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4dde:	0f 2e       	mov	r0, r31
    4de0:	f2 e5       	ldi	r31, 0x52	; 82
    4de2:	cf 2e       	mov	r12, r31
    4de4:	dd 24       	eor	r13, r13
    4de6:	f0 2d       	mov	r31, r0
    4de8:	c0 0e       	add	r12, r16
    4dea:	d1 1e       	adc	r13, r17
    4dec:	c6 01       	movw	r24, r12
    4dee:	b1 01       	movw	r22, r2
    4df0:	20 e2       	ldi	r18, 0x20	; 32
    4df2:	30 e0       	ldi	r19, 0x00	; 0
    4df4:	40 e0       	ldi	r20, 0x00	; 0
    4df6:	50 e0       	ldi	r21, 0x00	; 0
    4df8:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4dfc:	f8 01       	movw	r30, r16
    4dfe:	ed 5a       	subi	r30, 0xAD	; 173
    4e00:	ff 4f       	sbci	r31, 0xFF	; 255
    4e02:	8e e2       	ldi	r24, 0x2E	; 46
    4e04:	80 83       	st	Z, r24
    4e06:	4f 81       	ldd	r20, Y+7	; 0x07
    4e08:	58 85       	ldd	r21, Y+8	; 0x08
    4e0a:	69 85       	ldd	r22, Y+9	; 0x09
    4e0c:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e10:	fa 81       	ldd	r31, Y+2	; 0x02
    4e12:	80 81       	ld	r24, Z
    4e14:	83 30       	cpi	r24, 0x03	; 3
    4e16:	61 f4       	brne	.+24     	; 0x4e30 <f_mkdir+0x1ac>
    4e18:	86 a1       	lds	r24, 0x46
    4e1a:	97 a1       	lds	r25, 0x47
    4e1c:	a0 a5       	lds	r26, 0x60
    4e1e:	b1 a5       	lds	r27, 0x61
    4e20:	84 17       	cp	r24, r20
    4e22:	95 07       	cpc	r25, r21
    4e24:	a6 07       	cpc	r26, r22
    4e26:	b7 07       	cpc	r27, r23
    4e28:	19 f4       	brne	.+6      	; 0x4e30 <f_mkdir+0x1ac>
					pcl = 0;
    4e2a:	40 e0       	ldi	r20, 0x00	; 0
    4e2c:	50 e0       	ldi	r21, 0x00	; 0
    4e2e:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4e30:	c6 01       	movw	r24, r12
    4e32:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4e36:	e9 81       	ldd	r30, Y+1	; 0x01
    4e38:	fa 81       	ldd	r31, Y+2	; 0x02
    4e3a:	02 81       	ldd	r16, Z+2	; 0x02
    4e3c:	00 23       	and	r16, r16
    4e3e:	09 f4       	brne	.+2      	; 0x4e42 <f_mkdir+0x1be>
    4e40:	71 c0       	rjmp	.+226    	; 0x4f24 <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    4e42:	cc 24       	eor	r12, r12
    4e44:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    4e46:	89 81       	ldd	r24, Y+1	; 0x01
    4e48:	9a 81       	ldd	r25, Y+2	; 0x02
    4e4a:	fc 01       	movw	r30, r24
    4e4c:	86 a6       	lds	r24, 0xb6
    4e4e:	97 a6       	lds	r25, 0xb7
    4e50:	a0 aa       	sts	0x90, r26
    4e52:	b1 aa       	sts	0x91, r27
    4e54:	08 94       	sec
    4e56:	81 1c       	adc	r8, r1
    4e58:	91 1c       	adc	r9, r1
    4e5a:	a1 1c       	adc	r10, r1
    4e5c:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4e5e:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    4e60:	40 e0       	ldi	r20, 0x00	; 0
    4e62:	50 e0       	ldi	r21, 0x00	; 0
    4e64:	ba 01       	movw	r22, r20
    4e66:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
    4e6a:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4e6c:	88 23       	and	r24, r24
    4e6e:	61 f4       	brne	.+24     	; 0x4e88 <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    4e70:	c1 01       	movw	r24, r2
    4e72:	60 e0       	ldi	r22, 0x00	; 0
    4e74:	70 e0       	ldi	r23, 0x00	; 0
    4e76:	20 e0       	ldi	r18, 0x00	; 0
    4e78:	32 e0       	ldi	r19, 0x02	; 2
    4e7a:	40 e0       	ldi	r20, 0x00	; 0
    4e7c:	50 e0       	ldi	r21, 0x00	; 0
    4e7e:	0e 94 16 0a 	call	0x142c	; 0x142c <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4e82:	01 50       	subi	r16, 0x01	; 1
    4e84:	01 f7       	brne	.-64     	; 0x4e46 <f_mkdir+0x1c2>
    4e86:	4e c0       	rjmp	.+156    	; 0x4f24 <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4e88:	89 81       	ldd	r24, Y+1	; 0x01
    4e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8c:	b3 01       	movw	r22, r6
    4e8e:	a2 01       	movw	r20, r4
    4e90:	0e 94 8b 19 	call	0x3316	; 0x3316 <remove_chain>
    4e94:	19 c0       	rjmp	.+50     	; 0x4ec8 <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4e96:	eb 89       	ldd	r30, Y+19	; 0x13
    4e98:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4e9a:	80 e1       	ldi	r24, 0x10	; 16
    4e9c:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4e9e:	8d a1       	lds	r24, 0x4d
    4ea0:	86 8b       	std	Z+22, r24	; 0x16
    4ea2:	8e a1       	lds	r24, 0x4e
    4ea4:	87 8b       	std	Z+23, r24	; 0x17
    4ea6:	8f a1       	lds	r24, 0x4f
    4ea8:	80 8f       	std	Z+24, r24	; 0x18
    4eaa:	88 a5       	lds	r24, 0x68
    4eac:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4eae:	cf 01       	movw	r24, r30
    4eb0:	b3 01       	movw	r22, r6
    4eb2:	a2 01       	movw	r20, r4
    4eb4:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
				dj.fs->wflag = 1;
    4eb8:	89 81       	ldd	r24, Y+1	; 0x01
    4eba:	9a 81       	ldd	r25, Y+2	; 0x02
    4ebc:	21 e0       	ldi	r18, 0x01	; 1
    4ebe:	fc 01       	movw	r30, r24
    4ec0:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4ec2:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
    4ec6:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4ec8:	81 2f       	mov	r24, r17
    4eca:	a8 96       	adiw	r28, 0x28	; 40
    4ecc:	0f b6       	in	r0, 0x3f	; 63
    4ece:	f8 94       	cli
    4ed0:	de bf       	out	0x3e, r29	; 62
    4ed2:	0f be       	out	0x3f, r0	; 63
    4ed4:	cd bf       	out	0x3d, r28	; 61
    4ed6:	df 91       	pop	r29
    4ed8:	cf 91       	pop	r28
    4eda:	1f 91       	pop	r17
    4edc:	0f 91       	pop	r16
    4ede:	ff 90       	pop	r15
    4ee0:	ef 90       	pop	r14
    4ee2:	df 90       	pop	r13
    4ee4:	cf 90       	pop	r12
    4ee6:	bf 90       	pop	r11
    4ee8:	af 90       	pop	r10
    4eea:	9f 90       	pop	r9
    4eec:	8f 90       	pop	r8
    4eee:	7f 90       	pop	r7
    4ef0:	6f 90       	pop	r6
    4ef2:	5f 90       	pop	r5
    4ef4:	4f 90       	pop	r4
    4ef6:	3f 90       	pop	r3
    4ef8:	2f 90       	pop	r2
    4efa:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    4efc:	89 81       	ldd	r24, Y+1	; 0x01
    4efe:	9a 81       	ldd	r25, Y+2	; 0x02
    4f00:	40 e0       	ldi	r20, 0x00	; 0
    4f02:	50 e0       	ldi	r21, 0x00	; 0
    4f04:	ba 01       	movw	r22, r20
    4f06:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <create_chain>
    4f0a:	2b 01       	movw	r4, r22
    4f0c:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4f0e:	61 15       	cp	r22, r1
    4f10:	71 05       	cpc	r23, r1
    4f12:	81 05       	cpc	r24, r1
    4f14:	91 05       	cpc	r25, r1
    4f16:	09 f4       	brne	.+2      	; 0x4f1a <f_mkdir+0x296>
    4f18:	0b cf       	rjmp	.-490    	; 0x4d30 <f_mkdir+0xac>
    4f1a:	f8 ce       	rjmp	.-528    	; 0x4d0c <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    4f1c:	12 e0       	ldi	r17, 0x02	; 2
    4f1e:	b4 cf       	rjmp	.-152    	; 0x4e88 <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4f20:	11 e0       	ldi	r17, 0x01	; 1
    4f22:	b2 cf       	rjmp	.-156    	; 0x4e88 <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    4f24:	ce 01       	movw	r24, r28
    4f26:	01 96       	adiw	r24, 0x01	; 1
    4f28:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <dir_register>
    4f2c:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    4f2e:	88 23       	and	r24, r24
    4f30:	09 f4       	brne	.+2      	; 0x4f34 <f_mkdir+0x2b0>
    4f32:	b1 cf       	rjmp	.-158    	; 0x4e96 <f_mkdir+0x212>
    4f34:	a9 cf       	rjmp	.-174    	; 0x4e88 <f_mkdir+0x204>

00004f36 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    4f36:	0f 93       	push	r16
    4f38:	1f 93       	push	r17
    4f3a:	cf 93       	push	r28
    4f3c:	df 93       	push	r29
    4f3e:	cd b7       	in	r28, 0x3d	; 61
    4f40:	de b7       	in	r29, 0x3e	; 62
    4f42:	a4 97       	sbiw	r28, 0x24	; 36
    4f44:	0f b6       	in	r0, 0x3f	; 63
    4f46:	f8 94       	cli
    4f48:	de bf       	out	0x3e, r29	; 62
    4f4a:	0f be       	out	0x3f, r0	; 63
    4f4c:	cd bf       	out	0x3d, r28	; 61
    4f4e:	9c a3       	lds	r25, 0x5c
    4f50:	8b a3       	lds	r24, 0x5b
    4f52:	06 2f       	mov	r16, r22
    4f54:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4f56:	ce 01       	movw	r24, r28
    4f58:	83 96       	adiw	r24, 0x23	; 35
    4f5a:	be 01       	movw	r22, r28
    4f5c:	6f 5f       	subi	r22, 0xFF	; 255
    4f5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4f60:	41 e0       	ldi	r20, 0x01	; 1
    4f62:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
	if (res == FR_OK) {
    4f66:	88 23       	and	r24, r24
    4f68:	29 f5       	brne	.+74     	; 0x4fb4 <f_chmod+0x7e>
		INIT_BUF(dj);
    4f6a:	ce 01       	movw	r24, r28
    4f6c:	47 96       	adiw	r24, 0x17	; 23
    4f6e:	9e 8b       	std	Y+22, r25	; 0x16
    4f70:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4f72:	6b a1       	lds	r22, 0x4b
    4f74:	7c a1       	lds	r23, 0x4c
    4f76:	ce 01       	movw	r24, r28
    4f78:	01 96       	adiw	r24, 0x01	; 1
    4f7a:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4f7e:	88 23       	and	r24, r24
    4f80:	c9 f4       	brne	.+50     	; 0x4fb4 <f_chmod+0x7e>
    4f82:	ed 89       	ldd	r30, Y+21	; 0x15
    4f84:	fe 89       	ldd	r31, Y+22	; 0x16
    4f86:	83 85       	ldd	r24, Z+11	; 0x0b
    4f88:	85 ff       	sbrs	r24, 5
    4f8a:	1f c0       	rjmp	.+62     	; 0x4fca <f_chmod+0x94>
			res = FR_INVALID_NAME;
    4f8c:	86 e0       	ldi	r24, 0x06	; 6
    4f8e:	12 c0       	rjmp	.+36     	; 0x4fb4 <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    4f90:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    4f92:	91 2f       	mov	r25, r17
    4f94:	90 95       	com	r25
    4f96:	83 85       	ldd	r24, Z+11	; 0x0b
    4f98:	89 23       	and	r24, r25
    4f9a:	01 23       	and	r16, r17
    4f9c:	18 2f       	mov	r17, r24
    4f9e:	10 2b       	or	r17, r16
    4fa0:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    4fa2:	89 81       	ldd	r24, Y+1	; 0x01
    4fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa6:	21 e0       	ldi	r18, 0x01	; 1
    4fa8:	fc 01       	movw	r30, r24
    4faa:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4fac:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
    4fb0:	01 c0       	rjmp	.+2      	; 0x4fb4 <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    4fb2:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    4fb4:	a4 96       	adiw	r28, 0x24	; 36
    4fb6:	0f b6       	in	r0, 0x3f	; 63
    4fb8:	f8 94       	cli
    4fba:	de bf       	out	0x3e, r29	; 62
    4fbc:	0f be       	out	0x3f, r0	; 63
    4fbe:	cd bf       	out	0x3d, r28	; 61
    4fc0:	df 91       	pop	r29
    4fc2:	cf 91       	pop	r28
    4fc4:	1f 91       	pop	r17
    4fc6:	0f 91       	pop	r16
    4fc8:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4fca:	eb 89       	ldd	r30, Y+19	; 0x13
    4fcc:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    4fce:	30 97       	sbiw	r30, 0x00	; 0
    4fd0:	f9 f6       	brne	.-66     	; 0x4f90 <f_chmod+0x5a>
    4fd2:	ef cf       	rjmp	.-34     	; 0x4fb2 <f_chmod+0x7c>

00004fd4 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    4fd4:	0f 93       	push	r16
    4fd6:	1f 93       	push	r17
    4fd8:	cf 93       	push	r28
    4fda:	df 93       	push	r29
    4fdc:	cd b7       	in	r28, 0x3d	; 61
    4fde:	de b7       	in	r29, 0x3e	; 62
    4fe0:	a4 97       	sbiw	r28, 0x24	; 36
    4fe2:	0f b6       	in	r0, 0x3f	; 63
    4fe4:	f8 94       	cli
    4fe6:	de bf       	out	0x3e, r29	; 62
    4fe8:	0f be       	out	0x3f, r0	; 63
    4fea:	cd bf       	out	0x3d, r28	; 61
    4fec:	9c a3       	lds	r25, 0x5c
    4fee:	8b a3       	lds	r24, 0x5b
    4ff0:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4ff2:	ce 01       	movw	r24, r28
    4ff4:	83 96       	adiw	r24, 0x23	; 35
    4ff6:	be 01       	movw	r22, r28
    4ff8:	6f 5f       	subi	r22, 0xFF	; 255
    4ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    4ffc:	41 e0       	ldi	r20, 0x01	; 1
    4ffe:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
	if (res == FR_OK) {
    5002:	88 23       	and	r24, r24
    5004:	61 f5       	brne	.+88     	; 0x505e <f_utime+0x8a>
		INIT_BUF(dj);
    5006:	ce 01       	movw	r24, r28
    5008:	47 96       	adiw	r24, 0x17	; 23
    500a:	9e 8b       	std	Y+22, r25	; 0x16
    500c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    500e:	6b a1       	lds	r22, 0x4b
    5010:	7c a1       	lds	r23, 0x4c
    5012:	ce 01       	movw	r24, r28
    5014:	01 96       	adiw	r24, 0x01	; 1
    5016:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    501a:	88 23       	and	r24, r24
    501c:	01 f5       	brne	.+64     	; 0x505e <f_utime+0x8a>
    501e:	ed 89       	ldd	r30, Y+21	; 0x15
    5020:	fe 89       	ldd	r31, Y+22	; 0x16
    5022:	83 85       	ldd	r24, Z+11	; 0x0b
    5024:	85 ff       	sbrs	r24, 5
    5026:	26 c0       	rjmp	.+76     	; 0x5074 <f_utime+0xa0>
			res = FR_INVALID_NAME;
    5028:	86 e0       	ldi	r24, 0x06	; 6
    502a:	19 c0       	rjmp	.+50     	; 0x505e <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    502c:	d8 01       	movw	r26, r16
    502e:	16 96       	adiw	r26, 0x06	; 6
    5030:	8c 91       	ld	r24, X
    5032:	16 97       	sbiw	r26, 0x06	; 6
    5034:	86 8b       	std	Z+22, r24	; 0x16
    5036:	17 96       	adiw	r26, 0x07	; 7
    5038:	8c 91       	ld	r24, X
    503a:	17 97       	sbiw	r26, 0x07	; 7
    503c:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    503e:	14 96       	adiw	r26, 0x04	; 4
    5040:	8c 91       	ld	r24, X
    5042:	14 97       	sbiw	r26, 0x04	; 4
    5044:	80 8f       	std	Z+24, r24	; 0x18
    5046:	15 96       	adiw	r26, 0x05	; 5
    5048:	8c 91       	ld	r24, X
    504a:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    504c:	89 81       	ldd	r24, Y+1	; 0x01
    504e:	9a 81       	ldd	r25, Y+2	; 0x02
    5050:	21 e0       	ldi	r18, 0x01	; 1
    5052:	fc 01       	movw	r30, r24
    5054:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    5056:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
    505a:	01 c0       	rjmp	.+2      	; 0x505e <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    505c:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    505e:	a4 96       	adiw	r28, 0x24	; 36
    5060:	0f b6       	in	r0, 0x3f	; 63
    5062:	f8 94       	cli
    5064:	de bf       	out	0x3e, r29	; 62
    5066:	0f be       	out	0x3f, r0	; 63
    5068:	cd bf       	out	0x3d, r28	; 61
    506a:	df 91       	pop	r29
    506c:	cf 91       	pop	r28
    506e:	1f 91       	pop	r17
    5070:	0f 91       	pop	r16
    5072:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    5074:	eb 89       	ldd	r30, Y+19	; 0x13
    5076:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    5078:	30 97       	sbiw	r30, 0x00	; 0
    507a:	c1 f6       	brne	.-80     	; 0x502c <f_utime+0x58>
    507c:	ef cf       	rjmp	.-34     	; 0x505c <f_utime+0x88>

0000507e <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    507e:	ef 92       	push	r14
    5080:	ff 92       	push	r15
    5082:	0f 93       	push	r16
    5084:	1f 93       	push	r17
    5086:	cf 93       	push	r28
    5088:	df 93       	push	r29
    508a:	cd b7       	in	r28, 0x3d	; 61
    508c:	de b7       	in	r29, 0x3e	; 62
    508e:	cf 54       	subi	r28, 0x4F	; 79
    5090:	d0 40       	sbci	r29, 0x00	; 0
    5092:	0f b6       	in	r0, 0x3f	; 63
    5094:	f8 94       	cli
    5096:	de bf       	out	0x3e, r29	; 62
    5098:	0f be       	out	0x3f, r0	; 63
    509a:	cd bf       	out	0x3d, r28	; 61
    509c:	60 96       	adiw	r28, 0x10	; 16
    509e:	9f af       	sts	0x7f, r25
    50a0:	8e af       	sts	0x7e, r24
    50a2:	60 97       	sbiw	r28, 0x10	; 16
    50a4:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    50a6:	ce 01       	movw	r24, r28
    50a8:	82 5b       	subi	r24, 0xB2	; 178
    50aa:	9f 4f       	sbci	r25, 0xFF	; 255
    50ac:	be 01       	movw	r22, r28
    50ae:	6f 5f       	subi	r22, 0xFF	; 255
    50b0:	7f 4f       	sbci	r23, 0xFF	; 255
    50b2:	41 e0       	ldi	r20, 0x01	; 1
    50b4:	0e 94 a4 0b 	call	0x1748	; 0x1748 <chk_mounted>
	if (res == FR_OK) {
    50b8:	88 23       	and	r24, r24
    50ba:	09 f0       	breq	.+2      	; 0x50be <f_rename+0x40>
    50bc:	b7 c0       	rjmp	.+366    	; 0x522c <f_rename+0x1ae>
		djn.fs = djo.fs;
    50be:	89 81       	ldd	r24, Y+1	; 0x01
    50c0:	9a 81       	ldd	r25, Y+2	; 0x02
    50c2:	98 8f       	std	Y+24, r25	; 0x18
    50c4:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    50c6:	ce 01       	movw	r24, r28
    50c8:	8e 5b       	subi	r24, 0xBE	; 190
    50ca:	9f 4f       	sbci	r25, 0xFF	; 255
    50cc:	9e 8b       	std	Y+22, r25	; 0x16
    50ce:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    50d0:	60 96       	adiw	r28, 0x10	; 16
    50d2:	6e ad       	sts	0x6e, r22
    50d4:	7f ad       	sts	0x6f, r23
    50d6:	60 97       	sbiw	r28, 0x10	; 16
    50d8:	ce 01       	movw	r24, r28
    50da:	01 96       	adiw	r24, 0x01	; 1
    50dc:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    50e0:	88 23       	and	r24, r24
    50e2:	09 f0       	breq	.+2      	; 0x50e6 <f_rename+0x68>
    50e4:	a3 c0       	rjmp	.+326    	; 0x522c <f_rename+0x1ae>
    50e6:	ed 89       	ldd	r30, Y+21	; 0x15
    50e8:	fe 89       	ldd	r31, Y+22	; 0x16
    50ea:	83 85       	ldd	r24, Z+11	; 0x0b
    50ec:	85 ff       	sbrs	r24, 5
    50ee:	ac c0       	rjmp	.+344    	; 0x5248 <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    50f0:	86 e0       	ldi	r24, 0x06	; 6
    50f2:	9c c0       	rjmp	.+312    	; 0x522c <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    50f4:	65 5f       	subi	r22, 0xF5	; 245
    50f6:	7f 4f       	sbci	r23, 0xFF	; 255
    50f8:	ce 01       	movw	r24, r28
    50fa:	8d 96       	adiw	r24, 0x2d	; 45
    50fc:	25 e1       	ldi	r18, 0x15	; 21
    50fe:	30 e0       	ldi	r19, 0x00	; 0
    5100:	40 e0       	ldi	r20, 0x00	; 0
    5102:	50 e0       	ldi	r21, 0x00	; 0
    5104:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    5108:	ce 01       	movw	r24, r28
    510a:	47 96       	adiw	r24, 0x17	; 23
    510c:	be 01       	movw	r22, r28
    510e:	6f 5f       	subi	r22, 0xFF	; 255
    5110:	7f 4f       	sbci	r23, 0xFF	; 255
    5112:	26 e1       	ldi	r18, 0x16	; 22
    5114:	30 e0       	ldi	r19, 0x00	; 0
    5116:	40 e0       	ldi	r20, 0x00	; 0
    5118:	50 e0       	ldi	r21, 0x00	; 0
    511a:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
				res = follow_path(&djn, path_new);
    511e:	ce 01       	movw	r24, r28
    5120:	47 96       	adiw	r24, 0x17	; 23
    5122:	b8 01       	movw	r22, r16
    5124:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    5128:	88 23       	and	r24, r24
    512a:	09 f4       	brne	.+2      	; 0x512e <f_rename+0xb0>
    512c:	7c c0       	rjmp	.+248    	; 0x5226 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    512e:	84 30       	cpi	r24, 0x04	; 4
    5130:	09 f0       	breq	.+2      	; 0x5134 <f_rename+0xb6>
    5132:	7c c0       	rjmp	.+248    	; 0x522c <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    5134:	ce 01       	movw	r24, r28
    5136:	47 96       	adiw	r24, 0x17	; 23
    5138:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <dir_register>
					if (res == FR_OK) {
    513c:	88 23       	and	r24, r24
    513e:	09 f0       	breq	.+2      	; 0x5142 <f_rename+0xc4>
    5140:	75 c0       	rjmp	.+234    	; 0x522c <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    5142:	09 a5       	lds	r16, 0x69
    5144:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    5146:	c8 01       	movw	r24, r16
    5148:	0d 96       	adiw	r24, 0x0d	; 13
    514a:	be 01       	movw	r22, r28
    514c:	61 5d       	subi	r22, 0xD1	; 209
    514e:	7f 4f       	sbci	r23, 0xFF	; 255
    5150:	23 e1       	ldi	r18, 0x13	; 19
    5152:	30 e0       	ldi	r19, 0x00	; 0
    5154:	40 e0       	ldi	r20, 0x00	; 0
    5156:	50 e0       	ldi	r21, 0x00	; 0
    5158:	0e 94 01 0a 	call	0x1402	; 0x1402 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    515c:	8d a5       	lds	r24, 0x6d
    515e:	80 62       	ori	r24, 0x20	; 32
    5160:	f8 01       	movw	r30, r16
    5162:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    5164:	e9 80       	ldd	r14, Y+1	; 0x01
    5166:	fa 80       	ldd	r15, Y+2	; 0x02
    5168:	81 e0       	ldi	r24, 0x01	; 1
    516a:	f7 01       	movw	r30, r14
    516c:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    516e:	4f 81       	ldd	r20, Y+7	; 0x07
    5170:	58 85       	ldd	r21, Y+8	; 0x08
    5172:	69 85       	ldd	r22, Y+9	; 0x09
    5174:	7a 85       	ldd	r23, Y+10	; 0x0a
    5176:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5178:	9e 8d       	ldd	r25, Y+30	; 0x1e
    517a:	af 8d       	ldd	r26, Y+31	; 0x1f
    517c:	b8 a1       	lds	r27, 0x48
    517e:	48 17       	cp	r20, r24
    5180:	59 07       	cpc	r21, r25
    5182:	6a 07       	cpc	r22, r26
    5184:	7b 07       	cpc	r23, r27
    5186:	09 f4       	brne	.+2      	; 0x518a <f_rename+0x10c>
    5188:	43 c0       	rjmp	.+134    	; 0x5210 <f_rename+0x192>
    518a:	f8 01       	movw	r30, r16
    518c:	83 85       	ldd	r24, Z+11	; 0x0b
    518e:	84 ff       	sbrs	r24, 4
    5190:	3f c0       	rjmp	.+126    	; 0x5210 <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    5192:	c7 01       	movw	r24, r14
    5194:	b8 01       	movw	r22, r16
    5196:	0e 94 27 0a 	call	0x144e	; 0x144e <ld_clust>
    519a:	ab 01       	movw	r20, r22
    519c:	bc 01       	movw	r22, r24
    519e:	c7 01       	movw	r24, r14
    51a0:	0e 94 0b 11 	call	0x2216	; 0x2216 <clust2sect>
    51a4:	ab 01       	movw	r20, r22
    51a6:	bc 01       	movw	r22, r24
							if (!dw) {
    51a8:	41 15       	cp	r20, r1
    51aa:	51 05       	cpc	r21, r1
    51ac:	61 05       	cpc	r22, r1
    51ae:	71 05       	cpc	r23, r1
    51b0:	09 f4       	brne	.+2      	; 0x51b4 <f_rename+0x136>
    51b2:	51 c0       	rjmp	.+162    	; 0x5256 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    51b4:	c7 01       	movw	r24, r14
    51b6:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    51ba:	e9 81       	ldd	r30, Y+1	; 0x01
    51bc:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    51be:	88 23       	and	r24, r24
    51c0:	a9 f5       	brne	.+106    	; 0x522c <f_rename+0x1ae>
    51c2:	df 01       	movw	r26, r30
    51c4:	ad 5a       	subi	r26, 0xAD	; 173
    51c6:	bf 4f       	sbci	r27, 0xFF	; 255
    51c8:	8c 91       	ld	r24, X
    51ca:	8e 32       	cpi	r24, 0x2E	; 46
    51cc:	09 f5       	brne	.+66     	; 0x5210 <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    51ce:	80 81       	ld	r24, Z
    51d0:	83 30       	cpi	r24, 0x03	; 3
    51d2:	69 f4       	brne	.+26     	; 0x51ee <f_rename+0x170>
    51d4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    51d6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    51d8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    51da:	78 a1       	lds	r23, 0x48
    51dc:	86 a1       	lds	r24, 0x46
    51de:	97 a1       	lds	r25, 0x47
    51e0:	a0 a5       	lds	r26, 0x60
    51e2:	b1 a5       	lds	r27, 0x61
    51e4:	48 17       	cp	r20, r24
    51e6:	59 07       	cpc	r21, r25
    51e8:	6a 07       	cpc	r22, r26
    51ea:	7b 07       	cpc	r23, r27
    51ec:	29 f0       	breq	.+10     	; 0x51f8 <f_rename+0x17a>
    51ee:	4d 8d       	ldd	r20, Y+29	; 0x1d
    51f0:	5e 8d       	ldd	r21, Y+30	; 0x1e
    51f2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    51f4:	78 a1       	lds	r23, 0x48
    51f6:	03 c0       	rjmp	.+6      	; 0x51fe <f_rename+0x180>
    51f8:	40 e0       	ldi	r20, 0x00	; 0
    51fa:	50 e0       	ldi	r21, 0x00	; 0
    51fc:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    51fe:	cf 01       	movw	r24, r30
    5200:	8e 5a       	subi	r24, 0xAE	; 174
    5202:	9f 4f       	sbci	r25, 0xFF	; 255
    5204:	0e 94 4c 0a 	call	0x1498	; 0x1498 <st_clust>
									djo.fs->wflag = 1;
    5208:	e9 81       	ldd	r30, Y+1	; 0x01
    520a:	fa 81       	ldd	r31, Y+2	; 0x02
    520c:	81 e0       	ldi	r24, 0x01	; 1
    520e:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    5210:	ce 01       	movw	r24, r28
    5212:	01 96       	adiw	r24, 0x01	; 1
    5214:	0e 94 3d 13 	call	0x267a	; 0x267a <dir_remove>
							if (res == FR_OK)
    5218:	88 23       	and	r24, r24
    521a:	41 f4       	brne	.+16     	; 0x522c <f_rename+0x1ae>
								res = sync(djo.fs);
    521c:	89 81       	ldd	r24, Y+1	; 0x01
    521e:	9a 81       	ldd	r25, Y+2	; 0x02
    5220:	0e 94 79 10 	call	0x20f2	; 0x20f2 <sync>
    5224:	03 c0       	rjmp	.+6      	; 0x522c <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    5226:	88 e0       	ldi	r24, 0x08	; 8
    5228:	01 c0       	rjmp	.+2      	; 0x522c <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    522a:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    522c:	c1 5b       	subi	r28, 0xB1	; 177
    522e:	df 4f       	sbci	r29, 0xFF	; 255
    5230:	0f b6       	in	r0, 0x3f	; 63
    5232:	f8 94       	cli
    5234:	de bf       	out	0x3e, r29	; 62
    5236:	0f be       	out	0x3f, r0	; 63
    5238:	cd bf       	out	0x3d, r28	; 61
    523a:	df 91       	pop	r29
    523c:	cf 91       	pop	r28
    523e:	1f 91       	pop	r17
    5240:	0f 91       	pop	r16
    5242:	ff 90       	pop	r15
    5244:	ef 90       	pop	r14
    5246:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    5248:	6b 89       	ldd	r22, Y+19	; 0x13
    524a:	7c 89       	ldd	r23, Y+20	; 0x14
    524c:	61 15       	cp	r22, r1
    524e:	71 05       	cpc	r23, r1
    5250:	09 f0       	breq	.+2      	; 0x5254 <f_rename+0x1d6>
    5252:	50 cf       	rjmp	.-352    	; 0x50f4 <f_rename+0x76>
    5254:	ea cf       	rjmp	.-44     	; 0x522a <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    5256:	82 e0       	ldi	r24, 0x02	; 2
    5258:	e9 cf       	rjmp	.-46     	; 0x522c <f_rename+0x1ae>

0000525a <put_rc>:
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
    525a:	88 23       	and	r24, r24
    525c:	b1 f0       	breq	.+44     	; 0x528a <put_rc+0x30>
    525e:	e9 ea       	ldi	r30, 0xA9	; 169
    5260:	f1 e0       	ldi	r31, 0x01	; 1
    5262:	e4 91       	lpm	r30, Z
    5264:	ee 23       	and	r30, r30
    5266:	a1 f0       	breq	.+40     	; 0x5290 <put_rc+0x36>
    5268:	90 e0       	ldi	r25, 0x00	; 0
    526a:	29 ea       	ldi	r18, 0xA9	; 169
    526c:	31 e0       	ldi	r19, 0x01	; 1
		while(pgm_read_byte_near(p++));
    526e:	f9 01       	movw	r30, r18
    5270:	2f 5f       	subi	r18, 0xFF	; 255
    5272:	3f 4f       	sbci	r19, 0xFF	; 255
    5274:	e4 91       	lpm	r30, Z
    5276:	ee 23       	and	r30, r30
    5278:	d1 f7       	brne	.-12     	; 0x526e <put_rc+0x14>
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
    527a:	9f 5f       	subi	r25, 0xFF	; 255
    527c:	89 17       	cp	r24, r25
    527e:	51 f0       	breq	.+20     	; 0x5294 <put_rc+0x3a>
    5280:	f9 01       	movw	r30, r18
    5282:	44 91       	lpm	r20, Z
    5284:	44 23       	and	r20, r20
    5286:	99 f7       	brne	.-26     	; 0x526e <put_rc+0x14>
    5288:	05 c0       	rjmp	.+10     	; 0x5294 <put_rc+0x3a>
    528a:	29 ea       	ldi	r18, 0xA9	; 169
    528c:	31 e0       	ldi	r19, 0x01	; 1
    528e:	02 c0       	rjmp	.+4      	; 0x5294 <put_rc+0x3a>
    5290:	29 ea       	ldi	r18, 0xA9	; 169
    5292:	31 e0       	ldi	r19, 0x01	; 1
		while(pgm_read_byte_near(p++));
	}
	xprintf(PSTR("rc=%u FR_%S\n"), rc, p);
    5294:	00 d0       	rcall	.+0      	; 0x5296 <put_rc+0x3c>
    5296:	00 d0       	rcall	.+0      	; 0x5298 <put_rc+0x3e>
    5298:	00 d0       	rcall	.+0      	; 0x529a <put_rc+0x40>
    529a:	ed b7       	in	r30, 0x3d	; 61
    529c:	fe b7       	in	r31, 0x3e	; 62
    529e:	31 96       	adiw	r30, 0x01	; 1
    52a0:	45 e4       	ldi	r20, 0x45	; 69
    52a2:	59 e0       	ldi	r21, 0x09	; 9
    52a4:	ad b7       	in	r26, 0x3d	; 61
    52a6:	be b7       	in	r27, 0x3e	; 62
    52a8:	12 96       	adiw	r26, 0x02	; 2
    52aa:	5c 93       	st	X, r21
    52ac:	4e 93       	st	-X, r20
    52ae:	11 97       	sbiw	r26, 0x01	; 1
    52b0:	82 83       	std	Z+2, r24	; 0x02
    52b2:	13 82       	std	Z+3, r1	; 0x03
    52b4:	35 83       	std	Z+5, r19	; 0x05
    52b6:	24 83       	std	Z+4, r18	; 0x04
    52b8:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    52bc:	ed b7       	in	r30, 0x3d	; 61
    52be:	fe b7       	in	r31, 0x3e	; 62
    52c0:	36 96       	adiw	r30, 0x06	; 6
    52c2:	0f b6       	in	r0, 0x3f	; 63
    52c4:	f8 94       	cli
    52c6:	fe bf       	out	0x3e, r31	; 62
    52c8:	0f be       	out	0x3f, r0	; 63
    52ca:	ed bf       	out	0x3d, r30	; 61
}
    52cc:	08 95       	ret

000052ce <put_dump>:
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}

static
void put_dump (const BYTE *buff, DWORD ofs, BYTE cnt)
{
    52ce:	cf 92       	push	r12
    52d0:	df 92       	push	r13
    52d2:	ef 92       	push	r14
    52d4:	ff 92       	push	r15
    52d6:	0f 93       	push	r16
    52d8:	1f 93       	push	r17
    52da:	cf 93       	push	r28
    52dc:	df 93       	push	r29
    52de:	c8 2f       	mov	r28, r24
    52e0:	e9 2e       	mov	r14, r25
    52e2:	d2 2f       	mov	r29, r18
	BYTE i;


	xprintf(PSTR("%08lX "), ofs);
    52e4:	00 d0       	rcall	.+0      	; 0x52e6 <put_dump+0x18>
    52e6:	00 d0       	rcall	.+0      	; 0x52e8 <put_dump+0x1a>
    52e8:	00 d0       	rcall	.+0      	; 0x52ea <put_dump+0x1c>
    52ea:	88 e3       	ldi	r24, 0x38	; 56
    52ec:	99 e0       	ldi	r25, 0x09	; 9
    52ee:	ad b7       	in	r26, 0x3d	; 61
    52f0:	be b7       	in	r27, 0x3e	; 62
    52f2:	12 96       	adiw	r26, 0x02	; 2
    52f4:	9c 93       	st	X, r25
    52f6:	8e 93       	st	-X, r24
    52f8:	11 97       	sbiw	r26, 0x01	; 1
    52fa:	ed b7       	in	r30, 0x3d	; 61
    52fc:	fe b7       	in	r31, 0x3e	; 62
    52fe:	43 83       	std	Z+3, r20	; 0x03
    5300:	54 83       	std	Z+4, r21	; 0x04
    5302:	65 83       	std	Z+5, r22	; 0x05
    5304:	76 83       	std	Z+6, r23	; 0x06
    5306:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>

	for(i = 0; i < cnt; i++)
    530a:	8d b7       	in	r24, 0x3d	; 61
    530c:	9e b7       	in	r25, 0x3e	; 62
    530e:	06 96       	adiw	r24, 0x06	; 6
    5310:	0f b6       	in	r0, 0x3f	; 63
    5312:	f8 94       	cli
    5314:	9e bf       	out	0x3e, r25	; 62
    5316:	0f be       	out	0x3f, r0	; 63
    5318:	8d bf       	out	0x3d, r24	; 61
    531a:	dd 23       	and	r29, r29
    531c:	09 f4       	brne	.+2      	; 0x5320 <put_dump+0x52>
    531e:	40 c0       	rjmp	.+128    	; 0x53a0 <put_dump+0xd2>
    5320:	0c 2f       	mov	r16, r28
    5322:	1e 2d       	mov	r17, r14
    5324:	78 01       	movw	r14, r16
    5326:	c0 e0       	ldi	r28, 0x00	; 0
	xprintf(PSTR(" %02X"), buff[i]);
    5328:	0f 2e       	mov	r0, r31
    532a:	ff e3       	ldi	r31, 0x3F	; 63
    532c:	cf 2e       	mov	r12, r31
    532e:	f9 e0       	ldi	r31, 0x09	; 9
    5330:	df 2e       	mov	r13, r31
    5332:	f0 2d       	mov	r31, r0
    5334:	d7 01       	movw	r26, r14
    5336:	8d 91       	ld	r24, X+
    5338:	7d 01       	movw	r14, r26
    533a:	00 d0       	rcall	.+0      	; 0x533c <put_dump+0x6e>
    533c:	00 d0       	rcall	.+0      	; 0x533e <put_dump+0x70>
    533e:	ed b7       	in	r30, 0x3d	; 61
    5340:	fe b7       	in	r31, 0x3e	; 62
    5342:	31 96       	adiw	r30, 0x01	; 1
    5344:	ad b7       	in	r26, 0x3d	; 61
    5346:	be b7       	in	r27, 0x3e	; 62
    5348:	12 96       	adiw	r26, 0x02	; 2
    534a:	dc 92       	st	X, r13
    534c:	ce 92       	st	-X, r12
    534e:	11 97       	sbiw	r26, 0x01	; 1
    5350:	82 83       	std	Z+2, r24	; 0x02
    5352:	13 82       	std	Z+3, r1	; 0x03
    5354:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
	BYTE i;


	xprintf(PSTR("%08lX "), ofs);

	for(i = 0; i < cnt; i++)
    5358:	cf 5f       	subi	r28, 0xFF	; 255
    535a:	0f 90       	pop	r0
    535c:	0f 90       	pop	r0
    535e:	0f 90       	pop	r0
    5360:	0f 90       	pop	r0
    5362:	cd 17       	cp	r28, r29
    5364:	39 f7       	brne	.-50     	; 0x5334 <put_dump+0x66>
	xprintf(PSTR(" %02X"), buff[i]);

	xputc(' ');
    5366:	80 e2       	ldi	r24, 0x20	; 32
    5368:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>
	for(i = 0; i < cnt; i++)
    536c:	c0 e0       	ldi	r28, 0x00	; 0
	xputc((buff[i] >= ' ' && buff[i] <= '~') ? buff[i] : '.');
    536e:	f8 01       	movw	r30, r16
    5370:	81 91       	ld	r24, Z+
    5372:	8f 01       	movw	r16, r30
    5374:	98 2f       	mov	r25, r24
    5376:	90 52       	subi	r25, 0x20	; 32
    5378:	9f 35       	cpi	r25, 0x5F	; 95
    537a:	08 f0       	brcs	.+2      	; 0x537e <put_dump+0xb0>
    537c:	8e e2       	ldi	r24, 0x2E	; 46
    537e:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>

	for(i = 0; i < cnt; i++)
	xprintf(PSTR(" %02X"), buff[i]);

	xputc(' ');
	for(i = 0; i < cnt; i++)
    5382:	cf 5f       	subi	r28, 0xFF	; 255
    5384:	cd 17       	cp	r28, r29
    5386:	99 f7       	brne	.-26     	; 0x536e <put_dump+0xa0>
	xputc((buff[i] >= ' ' && buff[i] <= '~') ? buff[i] : '.');

	xputc('\n');
    5388:	8a e0       	ldi	r24, 0x0A	; 10
    538a:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>
}
    538e:	df 91       	pop	r29
    5390:	cf 91       	pop	r28
    5392:	1f 91       	pop	r17
    5394:	0f 91       	pop	r16
    5396:	ff 90       	pop	r15
    5398:	ef 90       	pop	r14
    539a:	df 90       	pop	r13
    539c:	cf 90       	pop	r12
    539e:	08 95       	ret
	xprintf(PSTR("%08lX "), ofs);

	for(i = 0; i < cnt; i++)
	xprintf(PSTR(" %02X"), buff[i]);

	xputc(' ');
    53a0:	80 e2       	ldi	r24, 0x20	; 32
    53a2:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>
    53a6:	f0 cf       	rjmp	.-32     	; 0x5388 <put_dump+0xba>

000053a8 <scan_files>:

static
FRESULT scan_files (
	char* path		/* Pointer to the working buffer with start path */
)
{
    53a8:	4f 92       	push	r4
    53aa:	5f 92       	push	r5
    53ac:	7f 92       	push	r7
    53ae:	8f 92       	push	r8
    53b0:	9f 92       	push	r9
    53b2:	af 92       	push	r10
    53b4:	bf 92       	push	r11
    53b6:	cf 92       	push	r12
    53b8:	df 92       	push	r13
    53ba:	ef 92       	push	r14
    53bc:	ff 92       	push	r15
    53be:	0f 93       	push	r16
    53c0:	1f 93       	push	r17
    53c2:	cf 93       	push	r28
    53c4:	df 93       	push	r29
    53c6:	cd b7       	in	r28, 0x3d	; 61
    53c8:	de b7       	in	r29, 0x3e	; 62
    53ca:	66 97       	sbiw	r28, 0x16	; 22
    53cc:	0f b6       	in	r0, 0x3f	; 63
    53ce:	f8 94       	cli
    53d0:	de bf       	out	0x3e, r29	; 62
    53d2:	0f be       	out	0x3f, r0	; 63
    53d4:	cd bf       	out	0x3d, r28	; 61
    53d6:	5c 01       	movw	r10, r24
	DIR dirs;
	FRESULT res;
	int i;
	char *fn;

	res = f_opendir(&dirs, path);
    53d8:	ce 01       	movw	r24, r28
    53da:	01 96       	adiw	r24, 0x01	; 1
    53dc:	b5 01       	movw	r22, r10
    53de:	0e 94 bf 22 	call	0x457e	; 0x457e <f_opendir>
	if (res == FR_OK) {
    53e2:	88 23       	and	r24, r24
    53e4:	09 f0       	breq	.+2      	; 0x53e8 <scan_files+0x40>
    53e6:	6f c0       	rjmp	.+222    	; 0x54c6 <scan_files+0x11e>
		i = strlen(path);
    53e8:	ea 2d       	mov	r30, r10
    53ea:	fb 2d       	mov	r31, r11
    53ec:	df 01       	movw	r26, r30
    53ee:	0d 90       	ld	r0, X+
    53f0:	00 20       	and	r0, r0
    53f2:	e9 f7       	brne	.-6      	; 0x53ee <scan_files+0x46>
    53f4:	cd 01       	movw	r24, r26
    53f6:	01 97       	sbiw	r24, 0x01	; 1
    53f8:	8e 1b       	sub	r24, r30
    53fa:	9f 0b       	sbc	r25, r31
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
    53fc:	0f eb       	ldi	r16, 0xBF	; 191
    53fe:	14 e0       	ldi	r17, 0x04	; 4
    5400:	0f 2e       	mov	r0, r31
    5402:	f8 ec       	ldi	r31, 0xC8	; 200
    5404:	ef 2e       	mov	r14, r31
    5406:	f4 e0       	ldi	r31, 0x04	; 4
    5408:	ff 2e       	mov	r15, r31
    540a:	f0 2d       	mov	r31, r0
#if _USE_LFN
			fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
#else
			fn = Finfo.fname;
#endif
			if (Finfo.fattrib & AM_DIR) {
    540c:	0f 2e       	mov	r0, r31
    540e:	f7 ec       	ldi	r31, 0xC7	; 199
    5410:	cf 2e       	mov	r12, r31
    5412:	f4 e0       	ldi	r31, 0x04	; 4
    5414:	df 2e       	mov	r13, r31
    5416:	f0 2d       	mov	r31, r0
				AccDirs++;
				*(path+i) = '/'; strcpy(path+i+1, fn);
    5418:	45 01       	movw	r8, r10
    541a:	88 0e       	add	r8, r24
    541c:	99 1e       	adc	r9, r25
    541e:	0f 2e       	mov	r0, r31
    5420:	ff e2       	ldi	r31, 0x2F	; 47
    5422:	7f 2e       	mov	r7, r31
    5424:	f0 2d       	mov	r31, r0
    5426:	01 96       	adiw	r24, 0x01	; 1
    5428:	25 01       	movw	r4, r10
    542a:	48 0e       	add	r4, r24
    542c:	59 1e       	adc	r5, r25
	char *fn;

	res = f_opendir(&dirs, path);
	if (res == FR_OK) {
		i = strlen(path);
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
    542e:	3f c0       	rjmp	.+126    	; 0x54ae <scan_files+0x106>
			if (_FS_RPATH && Finfo.fname[0] == '.') continue;
    5430:	9e 32       	cpi	r25, 0x2E	; 46
    5432:	e9 f1       	breq	.+122    	; 0x54ae <scan_files+0x106>
#if _USE_LFN
			fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
#else
			fn = Finfo.fname;
#endif
			if (Finfo.fattrib & AM_DIR) {
    5434:	f6 01       	movw	r30, r12
    5436:	80 81       	ld	r24, Z
    5438:	84 ff       	sbrs	r24, 4
    543a:	17 c0       	rjmp	.+46     	; 0x546a <scan_files+0xc2>
				AccDirs++;
    543c:	80 91 80 0d 	lds	r24, 0x0D80
    5440:	90 91 81 0d 	lds	r25, 0x0D81
    5444:	01 96       	adiw	r24, 0x01	; 1
    5446:	90 93 81 0d 	sts	0x0D81, r25
    544a:	80 93 80 0d 	sts	0x0D80, r24
				*(path+i) = '/'; strcpy(path+i+1, fn);
    544e:	d4 01       	movw	r26, r8
    5450:	7c 92       	st	X, r7
    5452:	c2 01       	movw	r24, r4
    5454:	b7 01       	movw	r22, r14
    5456:	0e 94 e6 3b 	call	0x77cc	; 0x77cc <strcpy>
				res = scan_files(path);
    545a:	c5 01       	movw	r24, r10
    545c:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <scan_files>
				*(path+i) = '\0';
    5460:	f4 01       	movw	r30, r8
    5462:	10 82       	st	Z, r1
				if (res != FR_OK) break;
    5464:	88 23       	and	r24, r24
    5466:	19 f1       	breq	.+70     	; 0x54ae <scan_files+0x106>
    5468:	2e c0       	rjmp	.+92     	; 0x54c6 <scan_files+0x11e>
			} else {
//				xprintf(PSTR("%s/%s\n"), path, fn);
				AccFiles++;
    546a:	80 91 82 0d 	lds	r24, 0x0D82
    546e:	90 91 83 0d 	lds	r25, 0x0D83
    5472:	01 96       	adiw	r24, 0x01	; 1
    5474:	90 93 83 0d 	sts	0x0D83, r25
    5478:	80 93 82 0d 	sts	0x0D82, r24
				AccSize += Finfo.fsize;
    547c:	80 91 16 09 	lds	r24, 0x0916
    5480:	90 91 17 09 	lds	r25, 0x0917
    5484:	a0 91 18 09 	lds	r26, 0x0918
    5488:	b0 91 19 09 	lds	r27, 0x0919
    548c:	f8 01       	movw	r30, r16
    548e:	40 81       	ld	r20, Z
    5490:	51 81       	ldd	r21, Z+1	; 0x01
    5492:	62 81       	ldd	r22, Z+2	; 0x02
    5494:	73 81       	ldd	r23, Z+3	; 0x03
    5496:	84 0f       	add	r24, r20
    5498:	95 1f       	adc	r25, r21
    549a:	a6 1f       	adc	r26, r22
    549c:	b7 1f       	adc	r27, r23
    549e:	80 93 16 09 	sts	0x0916, r24
    54a2:	90 93 17 09 	sts	0x0917, r25
    54a6:	a0 93 18 09 	sts	0x0918, r26
    54aa:	b0 93 19 09 	sts	0x0919, r27
	char *fn;

	res = f_opendir(&dirs, path);
	if (res == FR_OK) {
		i = strlen(path);
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
    54ae:	ce 01       	movw	r24, r28
    54b0:	01 96       	adiw	r24, 0x01	; 1
    54b2:	b8 01       	movw	r22, r16
    54b4:	0e 94 2d 23 	call	0x465a	; 0x465a <f_readdir>
    54b8:	88 23       	and	r24, r24
    54ba:	29 f4       	brne	.+10     	; 0x54c6 <scan_files+0x11e>
    54bc:	d7 01       	movw	r26, r14
    54be:	9c 91       	ld	r25, X
    54c0:	99 23       	and	r25, r25
    54c2:	09 f0       	breq	.+2      	; 0x54c6 <scan_files+0x11e>
    54c4:	b5 cf       	rjmp	.-150    	; 0x5430 <scan_files+0x88>
			}
		}
	}

	return res;
}
    54c6:	66 96       	adiw	r28, 0x16	; 22
    54c8:	0f b6       	in	r0, 0x3f	; 63
    54ca:	f8 94       	cli
    54cc:	de bf       	out	0x3e, r29	; 62
    54ce:	0f be       	out	0x3f, r0	; 63
    54d0:	cd bf       	out	0x3d, r28	; 61
    54d2:	df 91       	pop	r29
    54d4:	cf 91       	pop	r28
    54d6:	1f 91       	pop	r17
    54d8:	0f 91       	pop	r16
    54da:	ff 90       	pop	r15
    54dc:	ef 90       	pop	r14
    54de:	df 90       	pop	r13
    54e0:	cf 90       	pop	r12
    54e2:	bf 90       	pop	r11
    54e4:	af 90       	pop	r10
    54e6:	9f 90       	pop	r9
    54e8:	8f 90       	pop	r8
    54ea:	7f 90       	pop	r7
    54ec:	5f 90       	pop	r5
    54ee:	4f 90       	pop	r4
    54f0:	08 95       	ret

000054f2 <__vector_16>:


volatile UINT Timer;		

ISR(TIMER0_COMPA_vect)
{
    54f2:	1f 92       	push	r1
    54f4:	0f 92       	push	r0
    54f6:	0f b6       	in	r0, 0x3f	; 63
    54f8:	0f 92       	push	r0
    54fa:	11 24       	eor	r1, r1
    54fc:	2f 93       	push	r18
    54fe:	3f 93       	push	r19
    5500:	4f 93       	push	r20
    5502:	5f 93       	push	r21
    5504:	6f 93       	push	r22
    5506:	7f 93       	push	r23
    5508:	8f 93       	push	r24
    550a:	9f 93       	push	r25
    550c:	af 93       	push	r26
    550e:	bf 93       	push	r27
    5510:	ef 93       	push	r30
    5512:	ff 93       	push	r31
	Timer++;			/* Performance counter for this module */
    5514:	80 91 84 0d 	lds	r24, 0x0D84
    5518:	90 91 85 0d 	lds	r25, 0x0D85
    551c:	a0 91 86 0d 	lds	r26, 0x0D86
    5520:	b0 91 87 0d 	lds	r27, 0x0D87
    5524:	01 96       	adiw	r24, 0x01	; 1
    5526:	a1 1d       	adc	r26, r1
    5528:	b1 1d       	adc	r27, r1
    552a:	80 93 84 0d 	sts	0x0D84, r24
    552e:	90 93 85 0d 	sts	0x0D85, r25
    5532:	a0 93 86 0d 	sts	0x0D86, r26
    5536:	b0 93 87 0d 	sts	0x0D87, r27
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
    553a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <disk_timerproc>
}
    553e:	ff 91       	pop	r31
    5540:	ef 91       	pop	r30
    5542:	bf 91       	pop	r27
    5544:	af 91       	pop	r26
    5546:	9f 91       	pop	r25
    5548:	8f 91       	pop	r24
    554a:	7f 91       	pop	r23
    554c:	6f 91       	pop	r22
    554e:	5f 91       	pop	r21
    5550:	4f 91       	pop	r20
    5552:	3f 91       	pop	r19
    5554:	2f 91       	pop	r18
    5556:	0f 90       	pop	r0
    5558:	0f be       	out	0x3f, r0	; 63
    555a:	0f 90       	pop	r0
    555c:	1f 90       	pop	r1
    555e:	18 95       	reti

00005560 <main>:
/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
    5560:	cf 93       	push	r28
    5562:	df 93       	push	r29
    5564:	cd b7       	in	r28, 0x3d	; 61
    5566:	de b7       	in	r29, 0x3e	; 62
    5568:	c3 54       	subi	r28, 0x43	; 67
    556a:	d0 40       	sbci	r29, 0x00	; 0
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
	DWORD ofs, sect = 0;
	FATFS *fs;
	DIR dir;
	unsigned  long int i = 0;
	
	IO_Init();				/* Initialize port settings and start system timer process */
    5576:	0e 94 2c 05 	call	0xa58	; 0xa58 <IO_Init>
	USART0_Init();			/* Initialize UART driver */
    557a:	0e 94 0e 3a 	call	0x741c	; 0x741c <USART0_Init>
	xdev_out(Usart_SendChar);		/* Register uart_put() to xitoa module as console output */
    557e:	8a e1       	ldi	r24, 0x1A	; 26
    5580:	9a e3       	ldi	r25, 0x3A	; 58
    5582:	90 93 8c 02 	sts	0x028C, r25
    5586:	80 93 8b 02 	sts	0x028B, r24
	char temp = MCUSR;		//Get Status of MCU
    558a:	24 b7       	in	r18, 0x34	; 52
	MCUSR = 0;				//Clease status
    558c:	14 be       	out	0x34, r1	; 52
	xprintf(PSTR("MCUSR = %d\n"), temp);//Print status 
    558e:	00 d0       	rcall	.+0      	; 0x5590 <main+0x30>
    5590:	00 d0       	rcall	.+0      	; 0x5592 <main+0x32>
    5592:	ed b7       	in	r30, 0x3d	; 61
    5594:	fe b7       	in	r31, 0x3e	; 62
    5596:	31 96       	adiw	r30, 0x01	; 1
    5598:	8c ed       	ldi	r24, 0xDC	; 220
    559a:	90 e0       	ldi	r25, 0x00	; 0
    559c:	ad b7       	in	r26, 0x3d	; 61
    559e:	be b7       	in	r27, 0x3e	; 62
    55a0:	12 96       	adiw	r26, 0x02	; 2
    55a2:	9c 93       	st	X, r25
    55a4:	8e 93       	st	-X, r24
    55a6:	11 97       	sbiw	r26, 0x01	; 1
    55a8:	22 83       	std	Z+2, r18	; 0x02
    55aa:	13 82       	std	Z+3, r1	; 0x03
    55ac:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
	xputs(PSTR("\nOV7670 Camera Test Application.\n")); 
    55b0:	0f 90       	pop	r0
    55b2:	0f 90       	pop	r0
    55b4:	0f 90       	pop	r0
    55b6:	0f 90       	pop	r0
    55b8:	88 ee       	ldi	r24, 0xE8	; 232
    55ba:	90 e0       	ldi	r25, 0x00	; 0
    55bc:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
	xputs(_USE_LFN ? PSTR("LFN Enabled") : PSTR("LFN Disabled"));
    55c0:	8a e0       	ldi	r24, 0x0A	; 10
    55c2:	91 e0       	ldi	r25, 0x01	; 1
    55c4:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
	xprintf(PSTR(", Code page: %u\n"), _CODE_PAGE);
    55c8:	00 d0       	rcall	.+0      	; 0x55ca <main+0x6a>
    55ca:	00 d0       	rcall	.+0      	; 0x55cc <main+0x6c>
    55cc:	87 e1       	ldi	r24, 0x17	; 23
    55ce:	91 e0       	ldi	r25, 0x01	; 1
    55d0:	ed b7       	in	r30, 0x3d	; 61
    55d2:	fe b7       	in	r31, 0x3e	; 62
    55d4:	92 83       	std	Z+2, r25	; 0x02
    55d6:	81 83       	std	Z+1, r24	; 0x01
    55d8:	84 ea       	ldi	r24, 0xA4	; 164
    55da:	93 e0       	ldi	r25, 0x03	; 3
    55dc:	94 83       	std	Z+4, r25	; 0x04
    55de:	83 83       	std	Z+3, r24	; 0x03
    55e0:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
	xputs(PSTR("RTC is not supported. All files will have timestamp of 0\n"));
    55e4:	0f 90       	pop	r0
    55e6:	0f 90       	pop	r0
    55e8:	0f 90       	pop	r0
    55ea:	0f 90       	pop	r0
    55ec:	88 e2       	ldi	r24, 0x28	; 40
    55ee:	91 e0       	ldi	r25, 0x01	; 1
    55f0:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
	
	TWI_Master_Initialise();
    55f4:	0e 94 16 39 	call	0x722c	; 0x722c <TWI_Master_Initialise>
	xprintf(PSTR("TWI Initialised.\n"));
    55f8:	00 d0       	rcall	.+0      	; 0x55fa <main+0x9a>
    55fa:	82 e6       	ldi	r24, 0x62	; 98
    55fc:	91 e0       	ldi	r25, 0x01	; 1
    55fe:	ad b7       	in	r26, 0x3d	; 61
    5600:	be b7       	in	r27, 0x3e	; 62
    5602:	12 96       	adiw	r26, 0x02	; 2
    5604:	9c 93       	st	X, r25
    5606:	8e 93       	st	-X, r24
    5608:	11 97       	sbiw	r26, 0x01	; 1
    560a:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
	xprintf(PSTR("FIFO Initialised %d\n"), FIFO_init());
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	0e 94 08 38 	call	0x7010	; 0x7010 <FIFO_init>
    5616:	00 d0       	rcall	.+0      	; 0x5618 <main+0xb8>
    5618:	00 d0       	rcall	.+0      	; 0x561a <main+0xba>
    561a:	ed b7       	in	r30, 0x3d	; 61
    561c:	fe b7       	in	r31, 0x3e	; 62
    561e:	31 96       	adiw	r30, 0x01	; 1
    5620:	24 e7       	ldi	r18, 0x74	; 116
    5622:	31 e0       	ldi	r19, 0x01	; 1
    5624:	ad b7       	in	r26, 0x3d	; 61
    5626:	be b7       	in	r27, 0x3e	; 62
    5628:	12 96       	adiw	r26, 0x02	; 2
    562a:	3c 93       	st	X, r19
    562c:	2e 93       	st	-X, r18
    562e:	11 97       	sbiw	r26, 0x01	; 1
    5630:	82 83       	std	Z+2, r24	; 0x02
    5632:	13 82       	std	Z+3, r1	; 0x03
    5634:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
	xprintf(PSTR("OV7670 Initialise: %d\n"), OV7670_init());
    5638:	0f 90       	pop	r0
    563a:	0f 90       	pop	r0
    563c:	0f 90       	pop	r0
    563e:	0f 90       	pop	r0
    5640:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <OV7670_init>
    5644:	00 d0       	rcall	.+0      	; 0x5646 <main+0xe6>
    5646:	00 d0       	rcall	.+0      	; 0x5648 <main+0xe8>
    5648:	ed b7       	in	r30, 0x3d	; 61
    564a:	fe b7       	in	r31, 0x3e	; 62
    564c:	31 96       	adiw	r30, 0x01	; 1
    564e:	29 e8       	ldi	r18, 0x89	; 137
    5650:	31 e0       	ldi	r19, 0x01	; 1
    5652:	ad b7       	in	r26, 0x3d	; 61
    5654:	be b7       	in	r27, 0x3e	; 62
    5656:	12 96       	adiw	r26, 0x02	; 2
    5658:	3c 93       	st	X, r19
    565a:	2e 93       	st	-X, r18
    565c:	11 97       	sbiw	r26, 0x01	; 1
    565e:	82 83       	std	Z+2, r24	; 0x02
    5660:	13 82       	std	Z+3, r1	; 0x03
    5662:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    5666:	0f 90       	pop	r0
    5668:	0f 90       	pop	r0
    566a:	0f 90       	pop	r0
    566c:	0f 90       	pop	r0
	//Variables used in Main
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b1, *bp;
	UINT s1, s2, cnt;
	DWORD ofs, sect = 0;
    566e:	18 ae       	sts	0xb8, r17
    5670:	19 ae       	sts	0xb9, r17
    5672:	1a ae       	sts	0xba, r17
    5674:	1b ae       	sts	0xbb, r17
#endif

	for (;;) 
	{
		xputc('>');
		ptr = (char*)Line;
    5676:	0f 2e       	mov	r0, r31
    5678:	fc e1       	ldi	r31, 0x1C	; 28
    567a:	8f 2e       	mov	r8, r31
    567c:	fd e0       	ldi	r31, 0x0D	; 13
    567e:	9f 2e       	mov	r9, r31
    5680:	f0 2d       	mov	r31, r0
				put_rc(f_chmod(ptr, p1, p2));
				break;

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
    5682:	0f 2e       	mov	r0, r31
    5684:	f3 ec       	ldi	r31, 0xC3	; 195
    5686:	4f 2e       	mov	r4, r31
    5688:	f4 e0       	ldi	r31, 0x04	; 4
    568a:	5f 2e       	mov	r5, r31
    568c:	f0 2d       	mov	r31, r0
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
					res = f_readdir(&dir, &Finfo);
					if ((res != FR_OK) || !Finfo.fname[0]) break;
					if (Finfo.fattrib & AM_DIR) {
    568e:	0f 2e       	mov	r0, r31
    5690:	f7 ec       	ldi	r31, 0xC7	; 199
    5692:	6f 2e       	mov	r6, r31
    5694:	f4 e0       	ldi	r31, 0x04	; 4
    5696:	7f 2e       	mov	r7, r31
    5698:	f0 2d       	mov	r31, r0
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    569a:	f2 01       	movw	r30, r4
    569c:	34 97       	sbiw	r30, 0x04	; 4
    569e:	fd ab       	sts	0x5d, r31
    56a0:	ec ab       	sts	0x5c, r30
    56a2:	39 96       	adiw	r30, 0x09	; 9
    56a4:	ff ab       	sts	0x5f, r31
    56a6:	ee ab       	sts	0x5e, r30
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16);
				}
				if (disk_ioctl((BYTE)p1, ATA_GET_MODEL, Line) == RES_OK)
					{ Line[40] = '\0'; xprintf(PSTR("Model: %s\n"), Line); }
				if (disk_ioctl((BYTE)p1, ATA_GET_SN, Line) == RES_OK)
					{ Line[20] = '\0'; xprintf(PSTR("S/N: %s\n"), Line); }
    56a8:	20 e3       	ldi	r18, 0x30	; 48
    56aa:	3d e0       	ldi	r19, 0x0D	; 13
    56ac:	24 51       	subi	r18, 0x14	; 20
    56ae:	30 40       	sbci	r19, 0x00	; 0
    56b0:	22 96       	adiw	r28, 0x02	; 2
    56b2:	3f af       	sts	0x7f, r19
    56b4:	2e af       	sts	0x7e, r18
    56b6:	22 97       	sbiw	r28, 0x02	; 2
				if (disk_ioctl((BYTE)p1, MMC_GET_SDSTAT, Buff) == RES_OK) {
					xputs(PSTR("SD Status:\n"));
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16);
				}
				if (disk_ioctl((BYTE)p1, ATA_GET_MODEL, Line) == RES_OK)
					{ Line[40] = '\0'; xprintf(PSTR("Model: %s\n"), Line); }
    56b8:	44 e4       	ldi	r20, 0x44	; 68
    56ba:	5d e0       	ldi	r21, 0x0D	; 13
    56bc:	48 52       	subi	r20, 0x28	; 40
    56be:	50 40       	sbci	r21, 0x00	; 0
    56c0:	24 96       	adiw	r28, 0x04	; 4
    56c2:	5f af       	sts	0x7f, r21
    56c4:	4e af       	sts	0x7e, r20
    56c6:	24 97       	sbiw	r28, 0x04	; 4
	Finfo.lfsize = sizeof Lfname;
#endif

	for (;;) 
	{
		xputc('>');
    56c8:	8e e3       	ldi	r24, 0x3E	; 62
    56ca:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>
		ptr = (char*)Line;
    56ce:	9a 82       	std	Y+2, r9	; 0x02
    56d0:	89 82       	std	Y+1, r8	; 0x01
		Usart_get_line(ptr, sizeof Line);
    56d2:	c4 01       	movw	r24, r8
    56d4:	64 e6       	ldi	r22, 0x64	; 100
    56d6:	70 e0       	ldi	r23, 0x00	; 0
    56d8:	0e 94 38 3a 	call	0x7470	; 0x7470 <Usart_get_line>
		switch (*ptr++) 
    56dc:	29 81       	ldd	r18, Y+1	; 0x01
    56de:	3a 81       	ldd	r19, Y+2	; 0x02
    56e0:	f9 01       	movw	r30, r18
    56e2:	81 91       	ld	r24, Z+
    56e4:	fa 83       	std	Y+2, r31	; 0x02
    56e6:	e9 83       	std	Y+1, r30	; 0x01
    56e8:	84 36       	cpi	r24, 0x64	; 100
    56ea:	81 f0       	breq	.+32     	; 0x570c <main+0x1ac>
    56ec:	85 36       	cpi	r24, 0x65	; 101
    56ee:	38 f4       	brcc	.+14     	; 0x56fe <main+0x19e>
    56f0:	8f 33       	cpi	r24, 0x3F	; 63
    56f2:	11 f4       	brne	.+4      	; 0x56f8 <main+0x198>
    56f4:	0c 94 27 37 	jmp	0x6e4e	; 0x6e4e <main+0x18ee>
    56f8:	82 36       	cpi	r24, 0x62	; 98
    56fa:	31 f7       	brne	.-52     	; 0x56c8 <main+0x168>
    56fc:	da c1       	rjmp	.+948    	; 0x5ab2 <main+0x552>
    56fe:	86 36       	cpi	r24, 0x66	; 102
    5700:	09 f4       	brne	.+2      	; 0x5704 <main+0x1a4>
    5702:	67 c3       	rjmp	.+1742   	; 0x5dd2 <main+0x872>
    5704:	80 37       	cpi	r24, 0x70	; 112
    5706:	01 f7       	brne	.-64     	; 0x56c8 <main+0x168>
    5708:	0c 94 19 37 	jmp	0x6e32	; 0x6e32 <main+0x18d2>
		{
			//FatFS Commands
		case 'd' :
			switch (*ptr++) {
    570c:	d9 01       	movw	r26, r18
    570e:	11 96       	adiw	r26, 0x01	; 1
    5710:	4c 91       	ld	r20, X
    5712:	11 97       	sbiw	r26, 0x01	; 1
    5714:	c9 01       	movw	r24, r18
    5716:	02 96       	adiw	r24, 0x02	; 2
    5718:	9a 83       	std	Y+2, r25	; 0x02
    571a:	89 83       	std	Y+1, r24	; 0x01
    571c:	49 36       	cpi	r20, 0x69	; 105
    571e:	09 f4       	brne	.+2      	; 0x5722 <main+0x1c2>
    5720:	86 c0       	rjmp	.+268    	; 0x582e <main+0x2ce>
    5722:	43 37       	cpi	r20, 0x73	; 115
    5724:	09 f4       	brne	.+2      	; 0x5728 <main+0x1c8>
    5726:	a6 c0       	rjmp	.+332    	; 0x5874 <main+0x314>
    5728:	44 36       	cpi	r20, 0x64	; 100
    572a:	71 f6       	brne	.-100    	; 0x56c8 <main+0x168>
			case 'd' :	/* dd <phy_drv#> [<sector>] - Dump secrtor */
				if (!xatoi(&ptr, &p1)) break;
    572c:	ce 01       	movw	r24, r28
    572e:	01 96       	adiw	r24, 0x01	; 1
    5730:	be 01       	movw	r22, r28
    5732:	6d 5f       	subi	r22, 0xFD	; 253
    5734:	7f 4f       	sbci	r23, 0xFF	; 255
    5736:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    573a:	88 23       	and	r24, r24
    573c:	29 f2       	breq	.-118    	; 0x56c8 <main+0x168>
				if (!xatoi(&ptr, &p2)) p2 = sect;
    573e:	ce 01       	movw	r24, r28
    5740:	01 96       	adiw	r24, 0x01	; 1
    5742:	be 01       	movw	r22, r28
    5744:	69 5f       	subi	r22, 0xF9	; 249
    5746:	7f 4f       	sbci	r23, 0xFF	; 255
    5748:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    574c:	88 23       	and	r24, r24
    574e:	41 f4       	brne	.+16     	; 0x5760 <main+0x200>
    5750:	28 ad       	sts	0x68, r18
    5752:	39 ad       	sts	0x69, r19
    5754:	4a ad       	sts	0x6a, r20
    5756:	5b ad       	sts	0x6b, r21
    5758:	2f 83       	std	Y+7, r18	; 0x07
    575a:	38 87       	std	Y+8, r19	; 0x08
    575c:	49 87       	std	Y+9, r20	; 0x09
    575e:	5a 87       	std	Y+10, r21	; 0x0a
				res = disk_read((BYTE)p1, Buff, p2, 1);
    5760:	2f 81       	ldd	r18, Y+7	; 0x07
    5762:	38 85       	ldd	r19, Y+8	; 0x08
    5764:	49 85       	ldd	r20, Y+9	; 0x09
    5766:	5a 85       	ldd	r21, Y+10	; 0x0a
    5768:	8b 81       	ldd	r24, Y+3	; 0x03
    576a:	6a e1       	ldi	r22, 0x1A	; 26
    576c:	79 e0       	ldi	r23, 0x09	; 9
    576e:	01 e0       	ldi	r16, 0x01	; 1
    5770:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
				if (res) { xprintf(PSTR("rc=%d\n"), res); break; }
    5774:	88 23       	and	r24, r24
    5776:	b1 f0       	breq	.+44     	; 0x57a4 <main+0x244>
    5778:	00 d0       	rcall	.+0      	; 0x577a <main+0x21a>
    577a:	00 d0       	rcall	.+0      	; 0x577c <main+0x21c>
    577c:	ed b7       	in	r30, 0x3d	; 61
    577e:	fe b7       	in	r31, 0x3e	; 62
    5780:	31 96       	adiw	r30, 0x01	; 1
    5782:	20 ea       	ldi	r18, 0xA0	; 160
    5784:	31 e0       	ldi	r19, 0x01	; 1
    5786:	ad b7       	in	r26, 0x3d	; 61
    5788:	be b7       	in	r27, 0x3e	; 62
    578a:	12 96       	adiw	r26, 0x02	; 2
    578c:	3c 93       	st	X, r19
    578e:	2e 93       	st	-X, r18
    5790:	11 97       	sbiw	r26, 0x01	; 1
    5792:	82 83       	std	Z+2, r24	; 0x02
    5794:	13 82       	std	Z+3, r1	; 0x03
    5796:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    579a:	0f 90       	pop	r0
    579c:	0f 90       	pop	r0
    579e:	0f 90       	pop	r0
    57a0:	0f 90       	pop	r0
    57a2:	92 cf       	rjmp	.-220    	; 0x56c8 <main+0x168>
				sect = p2 + 1;
    57a4:	8f 81       	ldd	r24, Y+7	; 0x07
    57a6:	98 85       	ldd	r25, Y+8	; 0x08
    57a8:	a9 85       	ldd	r26, Y+9	; 0x09
    57aa:	ba 85       	ldd	r27, Y+10	; 0x0a
    57ac:	9c 01       	movw	r18, r24
    57ae:	ad 01       	movw	r20, r26
    57b0:	2f 5f       	subi	r18, 0xFF	; 255
    57b2:	3f 4f       	sbci	r19, 0xFF	; 255
    57b4:	4f 4f       	sbci	r20, 0xFF	; 255
    57b6:	5f 4f       	sbci	r21, 0xFF	; 255
    57b8:	28 af       	sts	0x78, r18
    57ba:	39 af       	sts	0x79, r19
    57bc:	4a af       	sts	0x7a, r20
    57be:	5b af       	sts	0x7b, r21
				xprintf(PSTR("Sector:%lu\n"), p2);
    57c0:	00 d0       	rcall	.+0      	; 0x57c2 <main+0x262>
    57c2:	00 d0       	rcall	.+0      	; 0x57c4 <main+0x264>
    57c4:	00 d0       	rcall	.+0      	; 0x57c6 <main+0x266>
    57c6:	27 ea       	ldi	r18, 0xA7	; 167
    57c8:	31 e0       	ldi	r19, 0x01	; 1
    57ca:	ed b7       	in	r30, 0x3d	; 61
    57cc:	fe b7       	in	r31, 0x3e	; 62
    57ce:	32 83       	std	Z+2, r19	; 0x02
    57d0:	21 83       	std	Z+1, r18	; 0x01
    57d2:	83 83       	std	Z+3, r24	; 0x03
    57d4:	94 83       	std	Z+4, r25	; 0x04
    57d6:	a5 83       	std	Z+5, r26	; 0x05
    57d8:	b6 83       	std	Z+6, r27	; 0x06
    57da:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    57de:	0f 2e       	mov	r0, r31
    57e0:	fa e1       	ldi	r31, 0x1A	; 26
    57e2:	af 2e       	mov	r10, r31
    57e4:	fb e0       	ldi	r31, 0x0B	; 11
    57e6:	bf 2e       	mov	r11, r31
    57e8:	f0 2d       	mov	r31, r0
    57ea:	2d b7       	in	r18, 0x3d	; 61
    57ec:	3e b7       	in	r19, 0x3e	; 62
    57ee:	2a 5f       	subi	r18, 0xFA	; 250
    57f0:	3f 4f       	sbci	r19, 0xFF	; 255
    57f2:	0f b6       	in	r0, 0x3f	; 63
    57f4:	f8 94       	cli
    57f6:	3e bf       	out	0x3e, r19	; 62
    57f8:	0f be       	out	0x3f, r0	; 63
    57fa:	2d bf       	out	0x3d, r18	; 61
				if (!xatoi(&ptr, &p2)) p2 = sect;
				res = disk_read((BYTE)p1, Buff, p2, 1);
				if (res) { xprintf(PSTR("rc=%d\n"), res); break; }
				sect = p2 + 1;
				xprintf(PSTR("Sector:%lu\n"), p2);
				for (bp=Buff, ofs = 0; ofs < 0x200; bp+=16, ofs+=16)
    57fc:	cc 24       	eor	r12, r12
    57fe:	dd 24       	eor	r13, r13
    5800:	76 01       	movw	r14, r12
    5802:	0a e1       	ldi	r16, 0x1A	; 26
    5804:	19 e0       	ldi	r17, 0x09	; 9
					put_dump(bp, ofs, 16);
    5806:	c8 01       	movw	r24, r16
    5808:	b7 01       	movw	r22, r14
    580a:	a6 01       	movw	r20, r12
    580c:	20 e1       	ldi	r18, 0x10	; 16
    580e:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
				if (!xatoi(&ptr, &p2)) p2 = sect;
				res = disk_read((BYTE)p1, Buff, p2, 1);
				if (res) { xprintf(PSTR("rc=%d\n"), res); break; }
				sect = p2 + 1;
				xprintf(PSTR("Sector:%lu\n"), p2);
				for (bp=Buff, ofs = 0; ofs < 0x200; bp+=16, ofs+=16)
    5812:	00 5f       	subi	r16, 0xF0	; 240
    5814:	1f 4f       	sbci	r17, 0xFF	; 255
    5816:	80 e1       	ldi	r24, 0x10	; 16
    5818:	90 e0       	ldi	r25, 0x00	; 0
    581a:	a0 e0       	ldi	r26, 0x00	; 0
    581c:	b0 e0       	ldi	r27, 0x00	; 0
    581e:	c8 0e       	add	r12, r24
    5820:	d9 1e       	adc	r13, r25
    5822:	ea 1e       	adc	r14, r26
    5824:	fb 1e       	adc	r15, r27
    5826:	0a 15       	cp	r16, r10
    5828:	1b 05       	cpc	r17, r11
    582a:	69 f7       	brne	.-38     	; 0x5806 <main+0x2a6>
    582c:	4d cf       	rjmp	.-358    	; 0x56c8 <main+0x168>
					put_dump(bp, ofs, 16);
				break;

			case 'i' :	/* di <phy_drv#> - Initialize disk */
				if (!xatoi(&ptr, &p1)) break;
    582e:	ce 01       	movw	r24, r28
    5830:	01 96       	adiw	r24, 0x01	; 1
    5832:	be 01       	movw	r22, r28
    5834:	6d 5f       	subi	r22, 0xFD	; 253
    5836:	7f 4f       	sbci	r23, 0xFF	; 255
    5838:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    583c:	88 23       	and	r24, r24
    583e:	09 f4       	brne	.+2      	; 0x5842 <main+0x2e2>
    5840:	43 cf       	rjmp	.-378    	; 0x56c8 <main+0x168>
				xprintf(PSTR("rc=%d\n"), disk_initialize((BYTE)p1));
    5842:	8b 81       	ldd	r24, Y+3	; 0x03
    5844:	0e 94 41 06 	call	0xc82	; 0xc82 <disk_initialize>
    5848:	00 d0       	rcall	.+0      	; 0x584a <main+0x2ea>
    584a:	00 d0       	rcall	.+0      	; 0x584c <main+0x2ec>
    584c:	ed b7       	in	r30, 0x3d	; 61
    584e:	fe b7       	in	r31, 0x3e	; 62
    5850:	31 96       	adiw	r30, 0x01	; 1
    5852:	23 eb       	ldi	r18, 0xB3	; 179
    5854:	31 e0       	ldi	r19, 0x01	; 1
    5856:	ad b7       	in	r26, 0x3d	; 61
    5858:	be b7       	in	r27, 0x3e	; 62
    585a:	12 96       	adiw	r26, 0x02	; 2
    585c:	3c 93       	st	X, r19
    585e:	2e 93       	st	-X, r18
    5860:	11 97       	sbiw	r26, 0x01	; 1
    5862:	82 83       	std	Z+2, r24	; 0x02
    5864:	13 82       	std	Z+3, r1	; 0x03
    5866:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				break;
    586a:	0f 90       	pop	r0
    586c:	0f 90       	pop	r0
    586e:	0f 90       	pop	r0
    5870:	0f 90       	pop	r0
    5872:	2a cf       	rjmp	.-428    	; 0x56c8 <main+0x168>

			case 's' :	/* ds <phy_drv#> - Show disk status */
				if (!xatoi(&ptr, &p1)) break;
    5874:	ce 01       	movw	r24, r28
    5876:	01 96       	adiw	r24, 0x01	; 1
    5878:	be 01       	movw	r22, r28
    587a:	6d 5f       	subi	r22, 0xFD	; 253
    587c:	7f 4f       	sbci	r23, 0xFF	; 255
    587e:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5882:	88 23       	and	r24, r24
    5884:	09 f4       	brne	.+2      	; 0x5888 <main+0x328>
    5886:	20 cf       	rjmp	.-448    	; 0x56c8 <main+0x168>
				if (disk_ioctl((BYTE)p1, GET_SECTOR_COUNT, &p2) == RES_OK)
    5888:	8b 81       	ldd	r24, Y+3	; 0x03
    588a:	61 e0       	ldi	r22, 0x01	; 1
    588c:	ae 01       	movw	r20, r28
    588e:	49 5f       	subi	r20, 0xF9	; 249
    5890:	5f 4f       	sbci	r21, 0xFF	; 255
    5892:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    5896:	88 23       	and	r24, r24
    5898:	e1 f4       	brne	.+56     	; 0x58d2 <main+0x372>
					{ xprintf(PSTR("Drive size: %lu sectors\n"), p2); }
    589a:	00 d0       	rcall	.+0      	; 0x589c <main+0x33c>
    589c:	00 d0       	rcall	.+0      	; 0x589e <main+0x33e>
    589e:	00 d0       	rcall	.+0      	; 0x58a0 <main+0x340>
    58a0:	8a eb       	ldi	r24, 0xBA	; 186
    58a2:	91 e0       	ldi	r25, 0x01	; 1
    58a4:	ed b7       	in	r30, 0x3d	; 61
    58a6:	fe b7       	in	r31, 0x3e	; 62
    58a8:	92 83       	std	Z+2, r25	; 0x02
    58aa:	81 83       	std	Z+1, r24	; 0x01
    58ac:	8f 81       	ldd	r24, Y+7	; 0x07
    58ae:	98 85       	ldd	r25, Y+8	; 0x08
    58b0:	a9 85       	ldd	r26, Y+9	; 0x09
    58b2:	ba 85       	ldd	r27, Y+10	; 0x0a
    58b4:	83 83       	std	Z+3, r24	; 0x03
    58b6:	94 83       	std	Z+4, r25	; 0x04
    58b8:	a5 83       	std	Z+5, r26	; 0x05
    58ba:	b6 83       	std	Z+6, r27	; 0x06
    58bc:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    58c0:	2d b7       	in	r18, 0x3d	; 61
    58c2:	3e b7       	in	r19, 0x3e	; 62
    58c4:	2a 5f       	subi	r18, 0xFA	; 250
    58c6:	3f 4f       	sbci	r19, 0xFF	; 255
    58c8:	0f b6       	in	r0, 0x3f	; 63
    58ca:	f8 94       	cli
    58cc:	3e bf       	out	0x3e, r19	; 62
    58ce:	0f be       	out	0x3f, r0	; 63
    58d0:	2d bf       	out	0x3d, r18	; 61
				if (disk_ioctl((BYTE)p1, GET_BLOCK_SIZE, &p2) == RES_OK)
    58d2:	8b 81       	ldd	r24, Y+3	; 0x03
    58d4:	63 e0       	ldi	r22, 0x03	; 3
    58d6:	ae 01       	movw	r20, r28
    58d8:	49 5f       	subi	r20, 0xF9	; 249
    58da:	5f 4f       	sbci	r21, 0xFF	; 255
    58dc:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    58e0:	88 23       	and	r24, r24
    58e2:	01 f5       	brne	.+64     	; 0x5924 <main+0x3c4>
					{ xprintf(PSTR("Erase block: %lu sectors\n"), p2); }
    58e4:	00 d0       	rcall	.+0      	; 0x58e6 <main+0x386>
    58e6:	00 d0       	rcall	.+0      	; 0x58e8 <main+0x388>
    58e8:	00 d0       	rcall	.+0      	; 0x58ea <main+0x38a>
    58ea:	83 ed       	ldi	r24, 0xD3	; 211
    58ec:	91 e0       	ldi	r25, 0x01	; 1
    58ee:	ad b7       	in	r26, 0x3d	; 61
    58f0:	be b7       	in	r27, 0x3e	; 62
    58f2:	12 96       	adiw	r26, 0x02	; 2
    58f4:	9c 93       	st	X, r25
    58f6:	8e 93       	st	-X, r24
    58f8:	11 97       	sbiw	r26, 0x01	; 1
    58fa:	8f 81       	ldd	r24, Y+7	; 0x07
    58fc:	98 85       	ldd	r25, Y+8	; 0x08
    58fe:	a9 85       	ldd	r26, Y+9	; 0x09
    5900:	ba 85       	ldd	r27, Y+10	; 0x0a
    5902:	ed b7       	in	r30, 0x3d	; 61
    5904:	fe b7       	in	r31, 0x3e	; 62
    5906:	83 83       	std	Z+3, r24	; 0x03
    5908:	94 83       	std	Z+4, r25	; 0x04
    590a:	a5 83       	std	Z+5, r26	; 0x05
    590c:	b6 83       	std	Z+6, r27	; 0x06
    590e:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    5912:	2d b7       	in	r18, 0x3d	; 61
    5914:	3e b7       	in	r19, 0x3e	; 62
    5916:	2a 5f       	subi	r18, 0xFA	; 250
    5918:	3f 4f       	sbci	r19, 0xFF	; 255
    591a:	0f b6       	in	r0, 0x3f	; 63
    591c:	f8 94       	cli
    591e:	3e bf       	out	0x3e, r19	; 62
    5920:	0f be       	out	0x3f, r0	; 63
    5922:	2d bf       	out	0x3d, r18	; 61
				if (disk_ioctl((BYTE)p1, MMC_GET_TYPE, &b1) == RES_OK)
    5924:	8b 81       	ldd	r24, Y+3	; 0x03
    5926:	6a e0       	ldi	r22, 0x0A	; 10
    5928:	ae 01       	movw	r20, r28
    592a:	41 5f       	subi	r20, 0xF1	; 241
    592c:	5f 4f       	sbci	r21, 0xFF	; 255
    592e:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    5932:	88 23       	and	r24, r24
    5934:	b1 f4       	brne	.+44     	; 0x5962 <main+0x402>
					{ xprintf(PSTR("Card type: %u\n"), b1); }
    5936:	00 d0       	rcall	.+0      	; 0x5938 <main+0x3d8>
    5938:	00 d0       	rcall	.+0      	; 0x593a <main+0x3da>
    593a:	ed b7       	in	r30, 0x3d	; 61
    593c:	fe b7       	in	r31, 0x3e	; 62
    593e:	31 96       	adiw	r30, 0x01	; 1
    5940:	8d ee       	ldi	r24, 0xED	; 237
    5942:	91 e0       	ldi	r25, 0x01	; 1
    5944:	ad b7       	in	r26, 0x3d	; 61
    5946:	be b7       	in	r27, 0x3e	; 62
    5948:	12 96       	adiw	r26, 0x02	; 2
    594a:	9c 93       	st	X, r25
    594c:	8e 93       	st	-X, r24
    594e:	11 97       	sbiw	r26, 0x01	; 1
    5950:	8f 85       	ldd	r24, Y+15	; 0x0f
    5952:	82 83       	std	Z+2, r24	; 0x02
    5954:	13 82       	std	Z+3, r1	; 0x03
    5956:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    595a:	0f 90       	pop	r0
    595c:	0f 90       	pop	r0
    595e:	0f 90       	pop	r0
    5960:	0f 90       	pop	r0
				if (disk_ioctl((BYTE)p1, MMC_GET_CSD, Buff) == RES_OK)
    5962:	8b 81       	ldd	r24, Y+3	; 0x03
    5964:	6b e0       	ldi	r22, 0x0B	; 11
    5966:	4a e1       	ldi	r20, 0x1A	; 26
    5968:	59 e0       	ldi	r21, 0x09	; 9
    596a:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    596e:	88 23       	and	r24, r24
    5970:	61 f4       	brne	.+24     	; 0x598a <main+0x42a>
					{ xputs(PSTR("CSD:\n")); put_dump(Buff, 0, 16); }
    5972:	8c ef       	ldi	r24, 0xFC	; 252
    5974:	91 e0       	ldi	r25, 0x01	; 1
    5976:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
    597a:	8a e1       	ldi	r24, 0x1A	; 26
    597c:	99 e0       	ldi	r25, 0x09	; 9
    597e:	40 e0       	ldi	r20, 0x00	; 0
    5980:	50 e0       	ldi	r21, 0x00	; 0
    5982:	ba 01       	movw	r22, r20
    5984:	20 e1       	ldi	r18, 0x10	; 16
    5986:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_CID, Buff) == RES_OK)
    598a:	8b 81       	ldd	r24, Y+3	; 0x03
    598c:	6c e0       	ldi	r22, 0x0C	; 12
    598e:	4a e1       	ldi	r20, 0x1A	; 26
    5990:	59 e0       	ldi	r21, 0x09	; 9
    5992:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    5996:	88 23       	and	r24, r24
    5998:	61 f4       	brne	.+24     	; 0x59b2 <main+0x452>
					{ xputs(PSTR("CID:\n")); put_dump(Buff, 0, 16); }
    599a:	82 e0       	ldi	r24, 0x02	; 2
    599c:	92 e0       	ldi	r25, 0x02	; 2
    599e:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
    59a2:	8a e1       	ldi	r24, 0x1A	; 26
    59a4:	99 e0       	ldi	r25, 0x09	; 9
    59a6:	40 e0       	ldi	r20, 0x00	; 0
    59a8:	50 e0       	ldi	r21, 0x00	; 0
    59aa:	ba 01       	movw	r22, r20
    59ac:	20 e1       	ldi	r18, 0x10	; 16
    59ae:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_OCR, Buff) == RES_OK)
    59b2:	8b 81       	ldd	r24, Y+3	; 0x03
    59b4:	6d e0       	ldi	r22, 0x0D	; 13
    59b6:	4a e1       	ldi	r20, 0x1A	; 26
    59b8:	59 e0       	ldi	r21, 0x09	; 9
    59ba:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    59be:	88 23       	and	r24, r24
    59c0:	61 f4       	brne	.+24     	; 0x59da <main+0x47a>
					{ xputs(PSTR("OCR:\n")); put_dump(Buff, 0, 4); }
    59c2:	88 e0       	ldi	r24, 0x08	; 8
    59c4:	92 e0       	ldi	r25, 0x02	; 2
    59c6:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
    59ca:	8a e1       	ldi	r24, 0x1A	; 26
    59cc:	99 e0       	ldi	r25, 0x09	; 9
    59ce:	40 e0       	ldi	r20, 0x00	; 0
    59d0:	50 e0       	ldi	r21, 0x00	; 0
    59d2:	ba 01       	movw	r22, r20
    59d4:	24 e0       	ldi	r18, 0x04	; 4
    59d6:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_SDSTAT, Buff) == RES_OK) {
    59da:	8b 81       	ldd	r24, Y+3	; 0x03
    59dc:	6e e0       	ldi	r22, 0x0E	; 14
    59de:	4a e1       	ldi	r20, 0x1A	; 26
    59e0:	59 e0       	ldi	r21, 0x09	; 9
    59e2:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    59e6:	88 23       	and	r24, r24
    59e8:	11 f5       	brne	.+68     	; 0x5a2e <main+0x4ce>
					xputs(PSTR("SD Status:\n"));
    59ea:	8e e0       	ldi	r24, 0x0E	; 14
    59ec:	92 e0       	ldi	r25, 0x02	; 2
    59ee:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16);
    59f2:	18 8a       	std	Y+16, r1	; 0x10
    59f4:	19 8a       	std	Y+17, r1	; 0x11
    59f6:	1a 8a       	std	Y+18, r1	; 0x12
    59f8:	1b 8a       	std	Y+19, r1	; 0x13
    59fa:	40 e0       	ldi	r20, 0x00	; 0
    59fc:	50 e0       	ldi	r21, 0x00	; 0
    59fe:	ba 01       	movw	r22, r20
    5a00:	ca 01       	movw	r24, r20
    5a02:	86 5e       	subi	r24, 0xE6	; 230
    5a04:	96 4f       	sbci	r25, 0xF6	; 246
    5a06:	20 e1       	ldi	r18, 0x10	; 16
    5a08:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
    5a0c:	48 89       	ldd	r20, Y+16	; 0x10
    5a0e:	59 89       	ldd	r21, Y+17	; 0x11
    5a10:	6a 89       	ldd	r22, Y+18	; 0x12
    5a12:	7b 89       	ldd	r23, Y+19	; 0x13
    5a14:	40 5f       	subi	r20, 0xF0	; 240
    5a16:	5f 4f       	sbci	r21, 0xFF	; 255
    5a18:	6f 4f       	sbci	r22, 0xFF	; 255
    5a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    5a1c:	48 8b       	std	Y+16, r20	; 0x10
    5a1e:	59 8b       	std	Y+17, r21	; 0x11
    5a20:	6a 8b       	std	Y+18, r22	; 0x12
    5a22:	7b 8b       	std	Y+19, r23	; 0x13
    5a24:	40 34       	cpi	r20, 0x40	; 64
    5a26:	51 05       	cpc	r21, r1
    5a28:	61 05       	cpc	r22, r1
    5a2a:	71 05       	cpc	r23, r1
    5a2c:	48 f3       	brcs	.-46     	; 0x5a00 <main+0x4a0>
				}
				if (disk_ioctl((BYTE)p1, ATA_GET_MODEL, Line) == RES_OK)
    5a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a30:	65 e1       	ldi	r22, 0x15	; 21
    5a32:	a4 01       	movw	r20, r8
    5a34:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    5a38:	88 23       	and	r24, r24
    5a3a:	d9 f4       	brne	.+54     	; 0x5a72 <main+0x512>
					{ Line[40] = '\0'; xprintf(PSTR("Model: %s\n"), Line); }
    5a3c:	e4 e4       	ldi	r30, 0x44	; 68
    5a3e:	fd e0       	ldi	r31, 0x0D	; 13
    5a40:	10 82       	st	Z, r1
    5a42:	00 d0       	rcall	.+0      	; 0x5a44 <main+0x4e4>
    5a44:	00 d0       	rcall	.+0      	; 0x5a46 <main+0x4e6>
    5a46:	8a e1       	ldi	r24, 0x1A	; 26
    5a48:	92 e0       	ldi	r25, 0x02	; 2
    5a4a:	ad b7       	in	r26, 0x3d	; 61
    5a4c:	be b7       	in	r27, 0x3e	; 62
    5a4e:	12 96       	adiw	r26, 0x02	; 2
    5a50:	9c 93       	st	X, r25
    5a52:	8e 93       	st	-X, r24
    5a54:	11 97       	sbiw	r26, 0x01	; 1
    5a56:	24 96       	adiw	r28, 0x04	; 4
    5a58:	ee ad       	sts	0x6e, r30
    5a5a:	ff ad       	sts	0x6f, r31
    5a5c:	24 97       	sbiw	r28, 0x04	; 4
    5a5e:	14 96       	adiw	r26, 0x04	; 4
    5a60:	fc 93       	st	X, r31
    5a62:	ee 93       	st	-X, r30
    5a64:	13 97       	sbiw	r26, 0x03	; 3
    5a66:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    5a6a:	0f 90       	pop	r0
    5a6c:	0f 90       	pop	r0
    5a6e:	0f 90       	pop	r0
    5a70:	0f 90       	pop	r0
				if (disk_ioctl((BYTE)p1, ATA_GET_SN, Line) == RES_OK)
    5a72:	8b 81       	ldd	r24, Y+3	; 0x03
    5a74:	66 e1       	ldi	r22, 0x16	; 22
    5a76:	a4 01       	movw	r20, r8
    5a78:	0e 94 e5 07 	call	0xfca	; 0xfca <disk_ioctl>
    5a7c:	88 23       	and	r24, r24
    5a7e:	09 f0       	breq	.+2      	; 0x5a82 <main+0x522>
    5a80:	23 ce       	rjmp	.-954    	; 0x56c8 <main+0x168>
					{ Line[20] = '\0'; xprintf(PSTR("S/N: %s\n"), Line); }
    5a82:	a0 e3       	ldi	r26, 0x30	; 48
    5a84:	bd e0       	ldi	r27, 0x0D	; 13
    5a86:	1c 92       	st	X, r1
    5a88:	00 d0       	rcall	.+0      	; 0x5a8a <main+0x52a>
    5a8a:	00 d0       	rcall	.+0      	; 0x5a8c <main+0x52c>
    5a8c:	85 e2       	ldi	r24, 0x25	; 37
    5a8e:	92 e0       	ldi	r25, 0x02	; 2
    5a90:	ed b7       	in	r30, 0x3d	; 61
    5a92:	fe b7       	in	r31, 0x3e	; 62
    5a94:	92 83       	std	Z+2, r25	; 0x02
    5a96:	81 83       	std	Z+1, r24	; 0x01
    5a98:	22 96       	adiw	r28, 0x02	; 2
    5a9a:	2e ad       	sts	0x6e, r18
    5a9c:	3f ad       	sts	0x6f, r19
    5a9e:	22 97       	sbiw	r28, 0x02	; 2
    5aa0:	34 83       	std	Z+4, r19	; 0x04
    5aa2:	23 83       	std	Z+3, r18	; 0x03
    5aa4:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    5aa8:	0f 90       	pop	r0
    5aaa:	0f 90       	pop	r0
    5aac:	0f 90       	pop	r0
    5aae:	0f 90       	pop	r0
    5ab0:	0b ce       	rjmp	.-1002   	; 0x56c8 <main+0x168>
				break;
			}
			break;

		case 'b' :
			switch (*ptr++) {
    5ab2:	d9 01       	movw	r26, r18
    5ab4:	11 96       	adiw	r26, 0x01	; 1
    5ab6:	4c 91       	ld	r20, X
    5ab8:	11 97       	sbiw	r26, 0x01	; 1
    5aba:	c9 01       	movw	r24, r18
    5abc:	02 96       	adiw	r24, 0x02	; 2
    5abe:	9a 83       	std	Y+2, r25	; 0x02
    5ac0:	89 83       	std	Y+1, r24	; 0x01
    5ac2:	46 36       	cpi	r20, 0x66	; 102
    5ac4:	09 f4       	brne	.+2      	; 0x5ac8 <main+0x568>
    5ac6:	72 c1       	rjmp	.+740    	; 0x5dac <main+0x84c>
    5ac8:	47 36       	cpi	r20, 0x67	; 103
    5aca:	30 f4       	brcc	.+12     	; 0x5ad8 <main+0x578>
    5acc:	44 36       	cpi	r20, 0x64	; 100
    5ace:	59 f0       	breq	.+22     	; 0x5ae6 <main+0x586>
    5ad0:	45 36       	cpi	r20, 0x65	; 101
    5ad2:	09 f0       	breq	.+2      	; 0x5ad6 <main+0x576>
    5ad4:	f9 cd       	rjmp	.-1038   	; 0x56c8 <main+0x168>
    5ad6:	49 c0       	rjmp	.+146    	; 0x5b6a <main+0x60a>
    5ad8:	42 37       	cpi	r20, 0x72	; 114
    5ada:	09 f4       	brne	.+2      	; 0x5ade <main+0x57e>
    5adc:	dd c0       	rjmp	.+442    	; 0x5c98 <main+0x738>
    5ade:	47 37       	cpi	r20, 0x77	; 119
    5ae0:	09 f0       	breq	.+2      	; 0x5ae4 <main+0x584>
    5ae2:	f2 cd       	rjmp	.-1052   	; 0x56c8 <main+0x168>
    5ae4:	1e c1       	rjmp	.+572    	; 0x5d22 <main+0x7c2>
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
    5ae6:	ce 01       	movw	r24, r28
    5ae8:	01 96       	adiw	r24, 0x01	; 1
    5aea:	be 01       	movw	r22, r28
    5aec:	6d 5f       	subi	r22, 0xFD	; 253
    5aee:	7f 4f       	sbci	r23, 0xFF	; 255
    5af0:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5af4:	88 23       	and	r24, r24
    5af6:	09 f4       	brne	.+2      	; 0x5afa <main+0x59a>
    5af8:	e7 cd       	rjmp	.-1074   	; 0x56c8 <main+0x168>
				for (bp=&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
    5afa:	8b 81       	ldd	r24, Y+3	; 0x03
    5afc:	9c 81       	ldd	r25, Y+4	; 0x04
    5afe:	ad 81       	ldd	r26, Y+5	; 0x05
    5b00:	be 81       	ldd	r27, Y+6	; 0x06
    5b02:	8c 01       	movw	r16, r24
    5b04:	06 5e       	subi	r16, 0xE6	; 230
    5b06:	16 4f       	sbci	r17, 0xF6	; 246
    5b08:	6c 01       	movw	r12, r24
    5b0a:	7d 01       	movw	r14, r26
    5b0c:	80 e2       	ldi	r24, 0x20	; 32
    5b0e:	90 e0       	ldi	r25, 0x00	; 0
    5b10:	a0 e0       	ldi	r26, 0x00	; 0
    5b12:	b0 e0       	ldi	r27, 0x00	; 0
    5b14:	88 8f       	std	Y+24, r24	; 0x18
    5b16:	99 8f       	std	Y+25, r25	; 0x19
    5b18:	aa 8f       	std	Y+26, r26	; 0x1a
    5b1a:	bb 8f       	std	Y+27, r27	; 0x1b
					put_dump(bp, ofs, 16);
    5b1c:	c8 01       	movw	r24, r16
    5b1e:	b7 01       	movw	r22, r14
    5b20:	a6 01       	movw	r20, r12
    5b22:	20 e1       	ldi	r18, 0x10	; 16
    5b24:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>

		case 'b' :
			switch (*ptr++) {
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				for (bp=&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
    5b28:	88 8d       	ldd	r24, Y+24	; 0x18
    5b2a:	99 8d       	ldd	r25, Y+25	; 0x19
    5b2c:	aa 8d       	ldd	r26, Y+26	; 0x1a
    5b2e:	bb 8d       	ldd	r27, Y+27	; 0x1b
    5b30:	ac 01       	movw	r20, r24
    5b32:	bd 01       	movw	r22, r26
    5b34:	41 50       	subi	r20, 0x01	; 1
    5b36:	50 40       	sbci	r21, 0x00	; 0
    5b38:	60 40       	sbci	r22, 0x00	; 0
    5b3a:	70 40       	sbci	r23, 0x00	; 0
    5b3c:	48 8f       	std	Y+24, r20	; 0x18
    5b3e:	59 8f       	std	Y+25, r21	; 0x19
    5b40:	6a 8f       	std	Y+26, r22	; 0x1a
    5b42:	7b 8f       	std	Y+27, r23	; 0x1b
    5b44:	89 81       	ldd	r24, Y+1	; 0x01
    5b46:	9a 81       	ldd	r25, Y+2	; 0x02
    5b48:	40 96       	adiw	r24, 0x10	; 16
    5b4a:	9a 83       	std	Y+2, r25	; 0x02
    5b4c:	89 83       	std	Y+1, r24	; 0x01
    5b4e:	80 e1       	ldi	r24, 0x10	; 16
    5b50:	90 e0       	ldi	r25, 0x00	; 0
    5b52:	a0 e0       	ldi	r26, 0x00	; 0
    5b54:	b0 e0       	ldi	r27, 0x00	; 0
    5b56:	c8 0e       	add	r12, r24
    5b58:	d9 1e       	adc	r13, r25
    5b5a:	ea 1e       	adc	r14, r26
    5b5c:	fb 1e       	adc	r15, r27
    5b5e:	41 15       	cp	r20, r1
    5b60:	51 05       	cpc	r21, r1
    5b62:	61 05       	cpc	r22, r1
    5b64:	71 05       	cpc	r23, r1
    5b66:	d1 f6       	brne	.-76     	; 0x5b1c <main+0x5bc>
    5b68:	af cd       	rjmp	.-1186   	; 0x56c8 <main+0x168>
					put_dump(bp, ofs, 16);
				break;

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
    5b6a:	ce 01       	movw	r24, r28
    5b6c:	01 96       	adiw	r24, 0x01	; 1
    5b6e:	be 01       	movw	r22, r28
    5b70:	6d 5f       	subi	r22, 0xFD	; 253
    5b72:	7f 4f       	sbci	r23, 0xFF	; 255
    5b74:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5b78:	88 23       	and	r24, r24
    5b7a:	09 f4       	brne	.+2      	; 0x5b7e <main+0x61e>
    5b7c:	a5 cd       	rjmp	.-1206   	; 0x56c8 <main+0x168>
				if (xatoi(&ptr, &p2)) {
    5b7e:	ce 01       	movw	r24, r28
    5b80:	01 96       	adiw	r24, 0x01	; 1
    5b82:	be 01       	movw	r22, r28
    5b84:	69 5f       	subi	r22, 0xF9	; 249
    5b86:	7f 4f       	sbci	r23, 0xFF	; 255
    5b88:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5b8c:	88 23       	and	r24, r24
    5b8e:	e1 f0       	breq	.+56     	; 0x5bc8 <main+0x668>
					do {
						Buff[p1++] = (BYTE)p2;
    5b90:	0a e1       	ldi	r16, 0x1A	; 26
    5b92:	19 e0       	ldi	r17, 0x09	; 9
    5b94:	8b 81       	ldd	r24, Y+3	; 0x03
    5b96:	9c 81       	ldd	r25, Y+4	; 0x04
    5b98:	ad 81       	ldd	r26, Y+5	; 0x05
    5b9a:	be 81       	ldd	r27, Y+6	; 0x06
    5b9c:	f8 01       	movw	r30, r16
    5b9e:	e8 0f       	add	r30, r24
    5ba0:	f9 1f       	adc	r31, r25
    5ba2:	2f 81       	ldd	r18, Y+7	; 0x07
    5ba4:	20 83       	st	Z, r18
    5ba6:	01 96       	adiw	r24, 0x01	; 1
    5ba8:	a1 1d       	adc	r26, r1
    5baa:	b1 1d       	adc	r27, r1
    5bac:	8b 83       	std	Y+3, r24	; 0x03
    5bae:	9c 83       	std	Y+4, r25	; 0x04
    5bb0:	ad 83       	std	Y+5, r26	; 0x05
    5bb2:	be 83       	std	Y+6, r27	; 0x06
					} while (xatoi(&ptr, &p2));
    5bb4:	ce 01       	movw	r24, r28
    5bb6:	01 96       	adiw	r24, 0x01	; 1
    5bb8:	be 01       	movw	r22, r28
    5bba:	69 5f       	subi	r22, 0xF9	; 249
    5bbc:	7f 4f       	sbci	r23, 0xFF	; 255
    5bbe:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5bc2:	88 23       	and	r24, r24
    5bc4:	39 f7       	brne	.-50     	; 0x5b94 <main+0x634>
    5bc6:	80 cd       	rjmp	.-1280   	; 0x56c8 <main+0x168>
					break;
				}
				for (;;) {
					xprintf(PSTR("%04X %02X-"), (WORD)p1, Buff[p1]);
    5bc8:	0f 2e       	mov	r0, r31
    5bca:	fe e2       	ldi	r31, 0x2E	; 46
    5bcc:	ef 2e       	mov	r14, r31
    5bce:	f2 e0       	ldi	r31, 0x02	; 2
    5bd0:	ff 2e       	mov	r15, r31
    5bd2:	f0 2d       	mov	r31, r0
    5bd4:	0a e1       	ldi	r16, 0x1A	; 26
    5bd6:	19 e0       	ldi	r17, 0x09	; 9
					if (*ptr == '.') break;
					if (*ptr < ' ') { p1++; continue; }
					if (xatoi(&ptr, &p2))
						Buff[p1++] = (BYTE)p2;
					else
						xputs(PSTR("???\n"));
    5bd8:	0f 2e       	mov	r0, r31
    5bda:	f9 e3       	ldi	r31, 0x39	; 57
    5bdc:	cf 2e       	mov	r12, r31
    5bde:	f2 e0       	ldi	r31, 0x02	; 2
    5be0:	df 2e       	mov	r13, r31
    5be2:	f0 2d       	mov	r31, r0
						Buff[p1++] = (BYTE)p2;
					} while (xatoi(&ptr, &p2));
					break;
				}
				for (;;) {
					xprintf(PSTR("%04X %02X-"), (WORD)p1, Buff[p1]);
    5be4:	8b 81       	ldd	r24, Y+3	; 0x03
    5be6:	9c 81       	ldd	r25, Y+4	; 0x04
    5be8:	ad 81       	ldd	r26, Y+5	; 0x05
    5bea:	be 81       	ldd	r27, Y+6	; 0x06
    5bec:	00 d0       	rcall	.+0      	; 0x5bee <main+0x68e>
    5bee:	00 d0       	rcall	.+0      	; 0x5bf0 <main+0x690>
    5bf0:	00 d0       	rcall	.+0      	; 0x5bf2 <main+0x692>
    5bf2:	2d b7       	in	r18, 0x3d	; 61
    5bf4:	3e b7       	in	r19, 0x3e	; 62
    5bf6:	2f 5f       	subi	r18, 0xFF	; 255
    5bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    5bfa:	ed b7       	in	r30, 0x3d	; 61
    5bfc:	fe b7       	in	r31, 0x3e	; 62
    5bfe:	f2 82       	std	Z+2, r15	; 0x02
    5c00:	e1 82       	std	Z+1, r14	; 0x01
    5c02:	f9 01       	movw	r30, r18
    5c04:	93 83       	std	Z+3, r25	; 0x03
    5c06:	82 83       	std	Z+2, r24	; 0x02
    5c08:	80 0f       	add	r24, r16
    5c0a:	91 1f       	adc	r25, r17
    5c0c:	dc 01       	movw	r26, r24
    5c0e:	8c 91       	ld	r24, X
    5c10:	84 83       	std	Z+4, r24	; 0x04
    5c12:	15 82       	std	Z+5, r1	; 0x05
    5c14:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
					Usart_get_line(Line, sizeof Line);
    5c18:	ed b7       	in	r30, 0x3d	; 61
    5c1a:	fe b7       	in	r31, 0x3e	; 62
    5c1c:	36 96       	adiw	r30, 0x06	; 6
    5c1e:	0f b6       	in	r0, 0x3f	; 63
    5c20:	f8 94       	cli
    5c22:	fe bf       	out	0x3e, r31	; 62
    5c24:	0f be       	out	0x3f, r0	; 63
    5c26:	ed bf       	out	0x3d, r30	; 61
    5c28:	c4 01       	movw	r24, r8
    5c2a:	64 e6       	ldi	r22, 0x64	; 100
    5c2c:	70 e0       	ldi	r23, 0x00	; 0
    5c2e:	0e 94 38 3a 	call	0x7470	; 0x7470 <Usart_get_line>
					ptr = Line;
    5c32:	9a 82       	std	Y+2, r9	; 0x02
    5c34:	89 82       	std	Y+1, r8	; 0x01
					if (*ptr == '.') break;
    5c36:	d4 01       	movw	r26, r8
    5c38:	8c 91       	ld	r24, X
    5c3a:	8e 32       	cpi	r24, 0x2E	; 46
    5c3c:	09 f4       	brne	.+2      	; 0x5c40 <main+0x6e0>
    5c3e:	44 cd       	rjmp	.-1400   	; 0x56c8 <main+0x168>
					if (*ptr < ' ') { p1++; continue; }
    5c40:	80 32       	cpi	r24, 0x20	; 32
    5c42:	60 f4       	brcc	.+24     	; 0x5c5c <main+0x6fc>
    5c44:	8b 81       	ldd	r24, Y+3	; 0x03
    5c46:	9c 81       	ldd	r25, Y+4	; 0x04
    5c48:	ad 81       	ldd	r26, Y+5	; 0x05
    5c4a:	be 81       	ldd	r27, Y+6	; 0x06
    5c4c:	01 96       	adiw	r24, 0x01	; 1
    5c4e:	a1 1d       	adc	r26, r1
    5c50:	b1 1d       	adc	r27, r1
    5c52:	8b 83       	std	Y+3, r24	; 0x03
    5c54:	9c 83       	std	Y+4, r25	; 0x04
    5c56:	ad 83       	std	Y+5, r26	; 0x05
    5c58:	be 83       	std	Y+6, r27	; 0x06
    5c5a:	c4 cf       	rjmp	.-120    	; 0x5be4 <main+0x684>
					if (xatoi(&ptr, &p2))
    5c5c:	ce 01       	movw	r24, r28
    5c5e:	01 96       	adiw	r24, 0x01	; 1
    5c60:	be 01       	movw	r22, r28
    5c62:	69 5f       	subi	r22, 0xF9	; 249
    5c64:	7f 4f       	sbci	r23, 0xFF	; 255
    5c66:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5c6a:	88 23       	and	r24, r24
    5c6c:	89 f0       	breq	.+34     	; 0x5c90 <main+0x730>
						Buff[p1++] = (BYTE)p2;
    5c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c70:	9c 81       	ldd	r25, Y+4	; 0x04
    5c72:	ad 81       	ldd	r26, Y+5	; 0x05
    5c74:	be 81       	ldd	r27, Y+6	; 0x06
    5c76:	f8 01       	movw	r30, r16
    5c78:	e8 0f       	add	r30, r24
    5c7a:	f9 1f       	adc	r31, r25
    5c7c:	2f 81       	ldd	r18, Y+7	; 0x07
    5c7e:	20 83       	st	Z, r18
    5c80:	01 96       	adiw	r24, 0x01	; 1
    5c82:	a1 1d       	adc	r26, r1
    5c84:	b1 1d       	adc	r27, r1
    5c86:	8b 83       	std	Y+3, r24	; 0x03
    5c88:	9c 83       	std	Y+4, r25	; 0x04
    5c8a:	ad 83       	std	Y+5, r26	; 0x05
    5c8c:	be 83       	std	Y+6, r27	; 0x06
    5c8e:	aa cf       	rjmp	.-172    	; 0x5be4 <main+0x684>
					else
						xputs(PSTR("???\n"));
    5c90:	c6 01       	movw	r24, r12
    5c92:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
    5c96:	a6 cf       	rjmp	.-180    	; 0x5be4 <main+0x684>
				}
				break;

			case 'r' :	/* br <phy_drv#> <sector> [<n>] - Read disk into R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
    5c98:	ce 01       	movw	r24, r28
    5c9a:	01 96       	adiw	r24, 0x01	; 1
    5c9c:	be 01       	movw	r22, r28
    5c9e:	6d 5f       	subi	r22, 0xFD	; 253
    5ca0:	7f 4f       	sbci	r23, 0xFF	; 255
    5ca2:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5ca6:	88 23       	and	r24, r24
    5ca8:	09 f4       	brne	.+2      	; 0x5cac <main+0x74c>
    5caa:	0e cd       	rjmp	.-1508   	; 0x56c8 <main+0x168>
				if (!xatoi(&ptr, &p2)) break;
    5cac:	ce 01       	movw	r24, r28
    5cae:	01 96       	adiw	r24, 0x01	; 1
    5cb0:	be 01       	movw	r22, r28
    5cb2:	69 5f       	subi	r22, 0xF9	; 249
    5cb4:	7f 4f       	sbci	r23, 0xFF	; 255
    5cb6:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5cba:	88 23       	and	r24, r24
    5cbc:	09 f4       	brne	.+2      	; 0x5cc0 <main+0x760>
    5cbe:	04 cd       	rjmp	.-1528   	; 0x56c8 <main+0x168>
				if (!xatoi(&ptr, &p3)) p3 = 1;
    5cc0:	ce 01       	movw	r24, r28
    5cc2:	01 96       	adiw	r24, 0x01	; 1
    5cc4:	be 01       	movw	r22, r28
    5cc6:	65 5f       	subi	r22, 0xF5	; 245
    5cc8:	7f 4f       	sbci	r23, 0xFF	; 255
    5cca:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5cce:	88 23       	and	r24, r24
    5cd0:	41 f4       	brne	.+16     	; 0x5ce2 <main+0x782>
    5cd2:	81 e0       	ldi	r24, 0x01	; 1
    5cd4:	90 e0       	ldi	r25, 0x00	; 0
    5cd6:	a0 e0       	ldi	r26, 0x00	; 0
    5cd8:	b0 e0       	ldi	r27, 0x00	; 0
    5cda:	8b 87       	std	Y+11, r24	; 0x0b
    5cdc:	9c 87       	std	Y+12, r25	; 0x0c
    5cde:	ad 87       	std	Y+13, r26	; 0x0d
    5ce0:	be 87       	std	Y+14, r27	; 0x0e
				xprintf(PSTR("rc=%u\n"), disk_read((BYTE)p1, Buff, p2, p3));
    5ce2:	2f 81       	ldd	r18, Y+7	; 0x07
    5ce4:	38 85       	ldd	r19, Y+8	; 0x08
    5ce6:	49 85       	ldd	r20, Y+9	; 0x09
    5ce8:	5a 85       	ldd	r21, Y+10	; 0x0a
    5cea:	8b 81       	ldd	r24, Y+3	; 0x03
    5cec:	6a e1       	ldi	r22, 0x1A	; 26
    5cee:	79 e0       	ldi	r23, 0x09	; 9
    5cf0:	0b 85       	ldd	r16, Y+11	; 0x0b
    5cf2:	0e 94 18 07 	call	0xe30	; 0xe30 <disk_read>
    5cf6:	00 d0       	rcall	.+0      	; 0x5cf8 <main+0x798>
    5cf8:	00 d0       	rcall	.+0      	; 0x5cfa <main+0x79a>
    5cfa:	ed b7       	in	r30, 0x3d	; 61
    5cfc:	fe b7       	in	r31, 0x3e	; 62
    5cfe:	31 96       	adiw	r30, 0x01	; 1
    5d00:	2e e3       	ldi	r18, 0x3E	; 62
    5d02:	32 e0       	ldi	r19, 0x02	; 2
    5d04:	ad b7       	in	r26, 0x3d	; 61
    5d06:	be b7       	in	r27, 0x3e	; 62
    5d08:	12 96       	adiw	r26, 0x02	; 2
    5d0a:	3c 93       	st	X, r19
    5d0c:	2e 93       	st	-X, r18
    5d0e:	11 97       	sbiw	r26, 0x01	; 1
    5d10:	82 83       	std	Z+2, r24	; 0x02
    5d12:	13 82       	std	Z+3, r1	; 0x03
    5d14:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				break;
    5d18:	0f 90       	pop	r0
    5d1a:	0f 90       	pop	r0
    5d1c:	0f 90       	pop	r0
    5d1e:	0f 90       	pop	r0
    5d20:	d3 cc       	rjmp	.-1626   	; 0x56c8 <main+0x168>

			case 'w' :	/* bw <phy_drv#> <sector> [<n>] - Write R/W buffer into disk */
				if (!xatoi(&ptr, &p1)) break;
    5d22:	ce 01       	movw	r24, r28
    5d24:	01 96       	adiw	r24, 0x01	; 1
    5d26:	be 01       	movw	r22, r28
    5d28:	6d 5f       	subi	r22, 0xFD	; 253
    5d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    5d2c:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5d30:	88 23       	and	r24, r24
    5d32:	09 f4       	brne	.+2      	; 0x5d36 <main+0x7d6>
    5d34:	c9 cc       	rjmp	.-1646   	; 0x56c8 <main+0x168>
				if (!xatoi(&ptr, &p2)) break;
    5d36:	ce 01       	movw	r24, r28
    5d38:	01 96       	adiw	r24, 0x01	; 1
    5d3a:	be 01       	movw	r22, r28
    5d3c:	69 5f       	subi	r22, 0xF9	; 249
    5d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    5d40:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5d44:	88 23       	and	r24, r24
    5d46:	09 f4       	brne	.+2      	; 0x5d4a <main+0x7ea>
    5d48:	bf cc       	rjmp	.-1666   	; 0x56c8 <main+0x168>
				if (!xatoi(&ptr, &p3)) p3 = 1;
    5d4a:	ce 01       	movw	r24, r28
    5d4c:	01 96       	adiw	r24, 0x01	; 1
    5d4e:	be 01       	movw	r22, r28
    5d50:	65 5f       	subi	r22, 0xF5	; 245
    5d52:	7f 4f       	sbci	r23, 0xFF	; 255
    5d54:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5d58:	88 23       	and	r24, r24
    5d5a:	41 f4       	brne	.+16     	; 0x5d6c <main+0x80c>
    5d5c:	81 e0       	ldi	r24, 0x01	; 1
    5d5e:	90 e0       	ldi	r25, 0x00	; 0
    5d60:	a0 e0       	ldi	r26, 0x00	; 0
    5d62:	b0 e0       	ldi	r27, 0x00	; 0
    5d64:	8b 87       	std	Y+11, r24	; 0x0b
    5d66:	9c 87       	std	Y+12, r25	; 0x0c
    5d68:	ad 87       	std	Y+13, r26	; 0x0d
    5d6a:	be 87       	std	Y+14, r27	; 0x0e
				xprintf(PSTR("rc=%u\n"), disk_write((BYTE)p1, Buff, p2, p3));
    5d6c:	2f 81       	ldd	r18, Y+7	; 0x07
    5d6e:	38 85       	ldd	r19, Y+8	; 0x08
    5d70:	49 85       	ldd	r20, Y+9	; 0x09
    5d72:	5a 85       	ldd	r21, Y+10	; 0x0a
    5d74:	8b 81       	ldd	r24, Y+3	; 0x03
    5d76:	6a e1       	ldi	r22, 0x1A	; 26
    5d78:	79 e0       	ldi	r23, 0x09	; 9
    5d7a:	0b 85       	ldd	r16, Y+11	; 0x0b
    5d7c:	0e 94 72 07 	call	0xee4	; 0xee4 <disk_write>
    5d80:	00 d0       	rcall	.+0      	; 0x5d82 <main+0x822>
    5d82:	00 d0       	rcall	.+0      	; 0x5d84 <main+0x824>
    5d84:	ed b7       	in	r30, 0x3d	; 61
    5d86:	fe b7       	in	r31, 0x3e	; 62
    5d88:	31 96       	adiw	r30, 0x01	; 1
    5d8a:	25 e4       	ldi	r18, 0x45	; 69
    5d8c:	32 e0       	ldi	r19, 0x02	; 2
    5d8e:	ad b7       	in	r26, 0x3d	; 61
    5d90:	be b7       	in	r27, 0x3e	; 62
    5d92:	12 96       	adiw	r26, 0x02	; 2
    5d94:	3c 93       	st	X, r19
    5d96:	2e 93       	st	-X, r18
    5d98:	11 97       	sbiw	r26, 0x01	; 1
    5d9a:	82 83       	std	Z+2, r24	; 0x02
    5d9c:	13 82       	std	Z+3, r1	; 0x03
    5d9e:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				break;
    5da2:	0f 90       	pop	r0
    5da4:	0f 90       	pop	r0
    5da6:	0f 90       	pop	r0
    5da8:	0f 90       	pop	r0
    5daa:	8e cc       	rjmp	.-1764   	; 0x56c8 <main+0x168>

			case 'f' :	/* bf <n> - Fill working buffer */
				if (!xatoi(&ptr, &p1)) break;
    5dac:	ce 01       	movw	r24, r28
    5dae:	01 96       	adiw	r24, 0x01	; 1
    5db0:	be 01       	movw	r22, r28
    5db2:	6d 5f       	subi	r22, 0xFD	; 253
    5db4:	7f 4f       	sbci	r23, 0xFF	; 255
    5db6:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5dba:	88 23       	and	r24, r24
    5dbc:	09 f4       	brne	.+2      	; 0x5dc0 <main+0x860>
    5dbe:	84 cc       	rjmp	.-1784   	; 0x56c8 <main+0x168>
				memset(Buff, (BYTE)p1, sizeof Buff);
    5dc0:	6b 81       	ldd	r22, Y+3	; 0x03
    5dc2:	8a e1       	ldi	r24, 0x1A	; 26
    5dc4:	99 e0       	ldi	r25, 0x09	; 9
    5dc6:	70 e0       	ldi	r23, 0x00	; 0
    5dc8:	40 e0       	ldi	r20, 0x00	; 0
    5dca:	54 e0       	ldi	r21, 0x04	; 4
    5dcc:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <memset>
				break;
    5dd0:	7b cc       	rjmp	.-1802   	; 0x56c8 <main+0x168>

			}
			break;

		case 'f' :
			switch (*ptr++) {
    5dd2:	d9 01       	movw	r26, r18
    5dd4:	11 96       	adiw	r26, 0x01	; 1
    5dd6:	ec 91       	ld	r30, X
    5dd8:	11 97       	sbiw	r26, 0x01	; 1
    5dda:	b9 01       	movw	r22, r18
    5ddc:	6e 5f       	subi	r22, 0xFE	; 254
    5dde:	7f 4f       	sbci	r23, 0xFF	; 255
    5de0:	7a 83       	std	Y+2, r23	; 0x02
    5de2:	69 83       	std	Y+1, r22	; 0x01
    5de4:	8e 2f       	mov	r24, r30
    5de6:	90 e0       	ldi	r25, 0x00	; 0
    5de8:	fc 01       	movw	r30, r24
    5dea:	e9 54       	subi	r30, 0x49	; 73
    5dec:	f0 40       	sbci	r31, 0x00	; 0
    5dee:	e0 33       	cpi	r30, 0x30	; 48
    5df0:	f1 05       	cpc	r31, r1
    5df2:	08 f0       	brcs	.+2      	; 0x5df6 <main+0x896>
    5df4:	69 cc       	rjmp	.-1838   	; 0x56c8 <main+0x168>
    5df6:	e2 5c       	subi	r30, 0xC2	; 194
    5df8:	ff 4f       	sbci	r31, 0xFF	; 255
    5dfa:	ee 0f       	add	r30, r30
    5dfc:	ff 1f       	adc	r31, r31
    5dfe:	05 90       	lpm	r0, Z+
    5e00:	f4 91       	lpm	r31, Z
    5e02:	e0 2d       	mov	r30, r0
    5e04:	09 94       	ijmp
				while (*ptr == ' ') ptr++;
				put_rc(f_utime(ptr, &Finfo));
				break;

			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
    5e06:	f9 01       	movw	r30, r18
    5e08:	82 81       	ldd	r24, Z+2	; 0x02
    5e0a:	80 32       	cpi	r24, 0x20	; 32
    5e0c:	09 f4       	brne	.+2      	; 0x5e10 <main+0x8b0>
    5e0e:	d2 c6       	rjmp	.+3492   	; 0x6bb4 <main+0x1654>
    5e10:	da c6       	rjmp	.+3508   	; 0x6bc6 <main+0x1666>
				while (*ptr2 == ' ') ptr2++;
				put_rc(f_rename(ptr, ptr2));
				break;

			case 'u' :	/* fu <name> - Unlink a file or dir */
				while (*ptr == ' ') ptr++;
    5e12:	d9 01       	movw	r26, r18
    5e14:	12 96       	adiw	r26, 0x02	; 2
    5e16:	8c 91       	ld	r24, X
    5e18:	12 97       	sbiw	r26, 0x02	; 2
    5e1a:	80 32       	cpi	r24, 0x20	; 32
    5e1c:	09 f4       	brne	.+2      	; 0x5e20 <main+0x8c0>
    5e1e:	bd c5       	rjmp	.+2938   	; 0x699a <main+0x143a>
    5e20:	c5 c5       	rjmp	.+2954   	; 0x69ac <main+0x144c>
				break;
			case 'I':
				put_rc(f_mount(0, &Fatfs[0]));
				break; 
			case 's' :	/* fs [<path>] - Show logical drive status */
				while (*ptr == ' ') ptr++;
    5e22:	f9 01       	movw	r30, r18
    5e24:	82 81       	ldd	r24, Z+2	; 0x02
    5e26:	80 32       	cpi	r24, 0x20	; 32
    5e28:	09 f4       	brne	.+2      	; 0x5e2c <main+0x8cc>
    5e2a:	44 c0       	rjmp	.+136    	; 0x5eb4 <main+0x954>
    5e2c:	4c c0       	rjmp	.+152    	; 0x5ec6 <main+0x966>
			case 'v' :	/* fv - Truncate file */
				put_rc(f_truncate(&File[0]));
				break;

			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
    5e2e:	d9 01       	movw	r26, r18
    5e30:	12 96       	adiw	r26, 0x02	; 2
    5e32:	8c 91       	ld	r24, X
    5e34:	12 97       	sbiw	r26, 0x02	; 2
    5e36:	80 32       	cpi	r24, 0x20	; 32
    5e38:	09 f4       	brne	.+2      	; 0x5e3c <main+0x8dc>
    5e3a:	86 c5       	rjmp	.+2828   	; 0x6948 <main+0x13e8>
    5e3c:	8e c5       	rjmp	.+2844   	; 0x695a <main+0x13fa>
						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
				);
				break;

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
    5e3e:	f9 01       	movw	r30, r18
    5e40:	82 81       	ldd	r24, Z+2	; 0x02
    5e42:	80 32       	cpi	r24, 0x20	; 32
    5e44:	09 f4       	brne	.+2      	; 0x5e48 <main+0x8e8>
    5e46:	4c c1       	rjmp	.+664    	; 0x60e0 <main+0xb80>
    5e48:	54 c1       	rjmp	.+680    	; 0x60f2 <main+0xb92>
				while (*ptr == ' ') ptr++;
				put_rc(f_unlink(ptr));
				break;

			case 'k' :	/* fk <name> - Create a directory */
				while (*ptr == ' ') ptr++;
    5e4a:	d9 01       	movw	r26, r18
    5e4c:	12 96       	adiw	r26, 0x02	; 2
    5e4e:	8c 91       	ld	r24, X
    5e50:	12 97       	sbiw	r26, 0x02	; 2
    5e52:	80 32       	cpi	r24, 0x20	; 32
    5e54:	09 f4       	brne	.+2      	; 0x5e58 <main+0x8f8>
    5e56:	b1 c5       	rjmp	.+2914   	; 0x69ba <main+0x145a>
    5e58:	b9 c5       	rjmp	.+2930   	; 0x69cc <main+0x146c>
				f_close(&File[0]);
				f_close(&File[1]);
				break;
#if _FS_RPATH
			case 'g' :	/* fg <path> - Change current directory */
				while (*ptr == ' ') ptr++;
    5e5a:	f9 01       	movw	r30, r18
    5e5c:	82 81       	ldd	r24, Z+2	; 0x02
    5e5e:	80 32       	cpi	r24, 0x20	; 32
    5e60:	09 f4       	brne	.+2      	; 0x5e64 <main+0x904>
    5e62:	c5 c7       	rjmp	.+3978   	; 0x6dee <main+0x188e>
    5e64:	cd c7       	rjmp	.+3994   	; 0x6e00 <main+0x18a0>

		case 'f' :
			switch (*ptr++) {

			case 'i' :	/* fi <log drv#> - Initialize logical drive */
				if (!xatoi(&ptr, &p1)) break;
    5e66:	ce 01       	movw	r24, r28
    5e68:	01 96       	adiw	r24, 0x01	; 1
    5e6a:	be 01       	movw	r22, r28
    5e6c:	6d 5f       	subi	r22, 0xFD	; 253
    5e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    5e70:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    5e74:	88 23       	and	r24, r24
    5e76:	09 f4       	brne	.+2      	; 0x5e7a <main+0x91a>
    5e78:	27 cc       	rjmp	.-1970   	; 0x56c8 <main+0x168>
				put_rc(f_mount((BYTE)p1, &Fatfs[p1]));
    5e7a:	0b 81       	ldd	r16, Y+3	; 0x03
    5e7c:	1c 81       	ldd	r17, Y+4	; 0x04
    5e7e:	2d 81       	ldd	r18, Y+5	; 0x05
    5e80:	3e 81       	ldd	r19, Y+6	; 0x06
    5e82:	82 e3       	ldi	r24, 0x32	; 50
    5e84:	92 e0       	ldi	r25, 0x02	; 2
    5e86:	08 9f       	mul	r16, r24
    5e88:	b0 01       	movw	r22, r0
    5e8a:	09 9f       	mul	r16, r25
    5e8c:	70 0d       	add	r23, r0
    5e8e:	18 9f       	mul	r17, r24
    5e90:	70 0d       	add	r23, r0
    5e92:	11 24       	eor	r1, r1
    5e94:	63 57       	subi	r22, 0x73	; 115
    5e96:	7d 4f       	sbci	r23, 0xFD	; 253
    5e98:	80 2f       	mov	r24, r16
    5e9a:	0e 94 0d 1a 	call	0x341a	; 0x341a <f_mount>
    5e9e:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    5ea2:	12 cc       	rjmp	.-2012   	; 0x56c8 <main+0x168>
			case 'I':
				put_rc(f_mount(0, &Fatfs[0]));
    5ea4:	80 e0       	ldi	r24, 0x00	; 0
    5ea6:	6d e8       	ldi	r22, 0x8D	; 141
    5ea8:	72 e0       	ldi	r23, 0x02	; 2
    5eaa:	0e 94 0d 1a 	call	0x341a	; 0x341a <f_mount>
    5eae:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break; 
    5eb2:	0a cc       	rjmp	.-2028   	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    5eb4:	f9 01       	movw	r30, r18
    5eb6:	33 96       	adiw	r30, 0x03	; 3
				break;
			case 'I':
				put_rc(f_mount(0, &Fatfs[0]));
				break; 
			case 's' :	/* fs [<path>] - Show logical drive status */
				while (*ptr == ' ') ptr++;
    5eb8:	6f 5f       	subi	r22, 0xFF	; 255
    5eba:	7f 4f       	sbci	r23, 0xFF	; 255
    5ebc:	7a 83       	std	Y+2, r23	; 0x02
    5ebe:	69 83       	std	Y+1, r22	; 0x01
    5ec0:	81 91       	ld	r24, Z+
    5ec2:	80 32       	cpi	r24, 0x20	; 32
    5ec4:	c9 f3       	breq	.-14     	; 0x5eb8 <main+0x958>
				res = f_getfree(ptr, (DWORD*)&p2, &fs);
    5ec6:	cb 01       	movw	r24, r22
    5ec8:	be 01       	movw	r22, r28
    5eca:	69 5f       	subi	r22, 0xF9	; 249
    5ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    5ece:	ae 01       	movw	r20, r28
    5ed0:	44 5e       	subi	r20, 0xE4	; 228
    5ed2:	5f 4f       	sbci	r21, 0xFF	; 255
    5ed4:	0e 94 c2 23 	call	0x4784	; 0x4784 <f_getfree>
				if (res) { put_rc(res); break; }
    5ed8:	88 23       	and	r24, r24
    5eda:	19 f0       	breq	.+6      	; 0x5ee2 <main+0x982>
    5edc:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    5ee0:	f3 cb       	rjmp	.-2074   	; 0x56c8 <main+0x168>
				xprintf(PSTR("FAT type = %u\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
							 "Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
							 "FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n..."),
						fs->fs_type, (DWORD)fs->csize * 512, fs->n_fats,
    5ee2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    5ee4:	3d 8d       	ldd	r19, Y+29	; 0x1d
				break; 
			case 's' :	/* fs [<path>] - Show logical drive status */
				while (*ptr == ' ') ptr++;
				res = f_getfree(ptr, (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("FAT type = %u\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
    5ee6:	4d b7       	in	r20, 0x3d	; 61
    5ee8:	5e b7       	in	r21, 0x3e	; 62
    5eea:	40 52       	subi	r20, 0x20	; 32
    5eec:	50 40       	sbci	r21, 0x00	; 0
    5eee:	0f b6       	in	r0, 0x3f	; 63
    5ef0:	f8 94       	cli
    5ef2:	5e bf       	out	0x3e, r21	; 62
    5ef4:	0f be       	out	0x3f, r0	; 63
    5ef6:	4d bf       	out	0x3d, r20	; 61
    5ef8:	ed b7       	in	r30, 0x3d	; 61
    5efa:	fe b7       	in	r31, 0x3e	; 62
    5efc:	31 96       	adiw	r30, 0x01	; 1
    5efe:	8c e4       	ldi	r24, 0x4C	; 76
    5f00:	92 e0       	ldi	r25, 0x02	; 2
    5f02:	ad b7       	in	r26, 0x3d	; 61
    5f04:	be b7       	in	r27, 0x3e	; 62
    5f06:	12 96       	adiw	r26, 0x02	; 2
    5f08:	9c 93       	st	X, r25
    5f0a:	8e 93       	st	-X, r24
    5f0c:	11 97       	sbiw	r26, 0x01	; 1
    5f0e:	d9 01       	movw	r26, r18
    5f10:	8c 91       	ld	r24, X
    5f12:	82 83       	std	Z+2, r24	; 0x02
    5f14:	13 82       	std	Z+3, r1	; 0x03
							 "Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
							 "FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n..."),
						fs->fs_type, (DWORD)fs->csize * 512, fs->n_fats,
    5f16:	12 96       	adiw	r26, 0x02	; 2
    5f18:	8c 91       	ld	r24, X
    5f1a:	90 e0       	ldi	r25, 0x00	; 0
    5f1c:	a0 e0       	ldi	r26, 0x00	; 0
    5f1e:	b0 e0       	ldi	r27, 0x00	; 0
				break; 
			case 's' :	/* fs [<path>] - Show logical drive status */
				while (*ptr == ' ') ptr++;
				res = f_getfree(ptr, (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("FAT type = %u\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
    5f20:	07 2e       	mov	r0, r23
    5f22:	79 e0       	ldi	r23, 0x09	; 9
    5f24:	88 0f       	add	r24, r24
    5f26:	99 1f       	adc	r25, r25
    5f28:	aa 1f       	adc	r26, r26
    5f2a:	bb 1f       	adc	r27, r27
    5f2c:	7a 95       	dec	r23
    5f2e:	d1 f7       	brne	.-12     	; 0x5f24 <main+0x9c4>
    5f30:	70 2d       	mov	r23, r0
    5f32:	84 83       	std	Z+4, r24	; 0x04
    5f34:	95 83       	std	Z+5, r25	; 0x05
    5f36:	a6 83       	std	Z+6, r26	; 0x06
    5f38:	b7 83       	std	Z+7, r27	; 0x07
    5f3a:	d9 01       	movw	r26, r18
    5f3c:	13 96       	adiw	r26, 0x03	; 3
    5f3e:	8c 91       	ld	r24, X
    5f40:	13 97       	sbiw	r26, 0x03	; 3
    5f42:	80 87       	std	Z+8, r24	; 0x08
    5f44:	11 86       	std	Z+9, r1	; 0x09
    5f46:	18 96       	adiw	r26, 0x08	; 8
    5f48:	8d 91       	ld	r24, X+
    5f4a:	9c 91       	ld	r25, X
    5f4c:	19 97       	sbiw	r26, 0x09	; 9
    5f4e:	93 87       	std	Z+11, r25	; 0x0b
    5f50:	82 87       	std	Z+10, r24	; 0x0a
    5f52:	5e 96       	adiw	r26, 0x1e	; 30
    5f54:	4d 91       	ld	r20, X+
    5f56:	5d 91       	ld	r21, X+
    5f58:	6d 91       	ld	r22, X+
    5f5a:	7c 91       	ld	r23, X
    5f5c:	91 97       	sbiw	r26, 0x21	; 33
    5f5e:	44 87       	std	Z+12, r20	; 0x0c
    5f60:	55 87       	std	Z+13, r21	; 0x0d
    5f62:	66 87       	std	Z+14, r22	; 0x0e
    5f64:	77 87       	std	Z+15, r23	; 0x0f
    5f66:	5a 96       	adiw	r26, 0x1a	; 26
    5f68:	4d 91       	ld	r20, X+
    5f6a:	5d 91       	ld	r21, X+
    5f6c:	6d 91       	ld	r22, X+
    5f6e:	7c 91       	ld	r23, X
    5f70:	5d 97       	sbiw	r26, 0x1d	; 29
    5f72:	db 01       	movw	r26, r22
    5f74:	ca 01       	movw	r24, r20
    5f76:	02 97       	sbiw	r24, 0x02	; 2
    5f78:	a1 09       	sbc	r26, r1
    5f7a:	b1 09       	sbc	r27, r1
    5f7c:	80 8b       	std	Z+16, r24	; 0x10
    5f7e:	91 8b       	std	Z+17, r25	; 0x11
    5f80:	a2 8b       	std	Z+18, r26	; 0x12
    5f82:	b3 8b       	std	Z+19, r27	; 0x13
    5f84:	d9 01       	movw	r26, r18
    5f86:	92 96       	adiw	r26, 0x22	; 34
    5f88:	4d 91       	ld	r20, X+
    5f8a:	5d 91       	ld	r21, X+
    5f8c:	6d 91       	ld	r22, X+
    5f8e:	7c 91       	ld	r23, X
    5f90:	95 97       	sbiw	r26, 0x25	; 37
    5f92:	44 8b       	std	Z+20, r20	; 0x14
    5f94:	55 8b       	std	Z+21, r21	; 0x15
    5f96:	66 8b       	std	Z+22, r22	; 0x16
    5f98:	77 8b       	std	Z+23, r23	; 0x17
    5f9a:	96 96       	adiw	r26, 0x26	; 38
    5f9c:	4d 91       	ld	r20, X+
    5f9e:	5d 91       	ld	r21, X+
    5fa0:	6d 91       	ld	r22, X+
    5fa2:	7c 91       	ld	r23, X
    5fa4:	99 97       	sbiw	r26, 0x29	; 41
    5fa6:	40 8f       	std	Z+24, r20	; 0x18
    5fa8:	51 8f       	std	Z+25, r21	; 0x19
    5faa:	62 8f       	std	Z+26, r22	; 0x1a
    5fac:	73 8f       	std	Z+27, r23	; 0x1b
    5fae:	9a 96       	adiw	r26, 0x2a	; 42
    5fb0:	4d 91       	ld	r20, X+
    5fb2:	5d 91       	ld	r21, X+
    5fb4:	6d 91       	ld	r22, X+
    5fb6:	7c 91       	ld	r23, X
    5fb8:	9d 97       	sbiw	r26, 0x2d	; 45
    5fba:	44 8f       	std	Z+28, r20	; 0x1c
    5fbc:	55 8f       	std	Z+29, r21	; 0x1d
    5fbe:	66 8f       	std	Z+30, r22	; 0x1e
    5fc0:	77 8f       	std	Z+31, r23	; 0x1f
    5fc2:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
							 "FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n..."),
						fs->fs_type, (DWORD)fs->csize * 512, fs->n_fats,
						fs->n_rootdir, fs->fsize, fs->n_fatent - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				AccSize = AccFiles = AccDirs = 0;
    5fc6:	10 92 81 0d 	sts	0x0D81, r1
    5fca:	10 92 80 0d 	sts	0x0D80, r1
    5fce:	10 92 83 0d 	sts	0x0D83, r1
    5fd2:	10 92 82 0d 	sts	0x0D82, r1
    5fd6:	10 92 16 09 	sts	0x0916, r1
    5fda:	10 92 17 09 	sts	0x0917, r1
    5fde:	10 92 18 09 	sts	0x0918, r1
    5fe2:	10 92 19 09 	sts	0x0919, r1
				strcpy((char*)Buff, ptr);
    5fe6:	ed b7       	in	r30, 0x3d	; 61
    5fe8:	fe b7       	in	r31, 0x3e	; 62
    5fea:	b0 96       	adiw	r30, 0x20	; 32
    5fec:	0f b6       	in	r0, 0x3f	; 63
    5fee:	f8 94       	cli
    5ff0:	fe bf       	out	0x3e, r31	; 62
    5ff2:	0f be       	out	0x3f, r0	; 63
    5ff4:	ed bf       	out	0x3d, r30	; 61
    5ff6:	0a e1       	ldi	r16, 0x1A	; 26
    5ff8:	19 e0       	ldi	r17, 0x09	; 9
    5ffa:	69 81       	ldd	r22, Y+1	; 0x01
    5ffc:	7a 81       	ldd	r23, Y+2	; 0x02
    5ffe:	c8 01       	movw	r24, r16
    6000:	0e 94 e6 3b 	call	0x77cc	; 0x77cc <strcpy>
				res = scan_files((char*)Buff);
    6004:	c8 01       	movw	r24, r16
    6006:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <scan_files>
				if (res) { put_rc(res); break; }
    600a:	88 23       	and	r24, r24
    600c:	19 f0       	breq	.+6      	; 0x6014 <main+0xab4>
    600e:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    6012:	5a cb       	rjmp	.-2380   	; 0x56c8 <main+0x168>
				xprintf(PSTR("\r%u files, %lu bytes.\n%u folders.\n"
							 "%lu KB total disk space.\n%lu KB available.\n"),
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
    6014:	2c 8d       	ldd	r18, Y+28	; 0x1c
    6016:	3d 8d       	ldd	r19, Y+29	; 0x1d
				);
				AccSize = AccFiles = AccDirs = 0;
				strcpy((char*)Buff, ptr);
				res = scan_files((char*)Buff);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("\r%u files, %lu bytes.\n%u folders.\n"
    6018:	d9 01       	movw	r26, r18
    601a:	12 96       	adiw	r26, 0x02	; 2
    601c:	cc 90       	ld	r12, X
    601e:	c6 94       	lsr	r12
    6020:	ed b7       	in	r30, 0x3d	; 61
    6022:	fe b7       	in	r31, 0x3e	; 62
    6024:	72 97       	sbiw	r30, 0x12	; 18
    6026:	0f b6       	in	r0, 0x3f	; 63
    6028:	f8 94       	cli
    602a:	fe bf       	out	0x3e, r31	; 62
    602c:	0f be       	out	0x3f, r0	; 63
    602e:	ed bf       	out	0x3d, r30	; 61
    6030:	0d b7       	in	r16, 0x3d	; 61
    6032:	1e b7       	in	r17, 0x3e	; 62
    6034:	0f 5f       	subi	r16, 0xFF	; 255
    6036:	1f 4f       	sbci	r17, 0xFF	; 255
    6038:	83 e1       	ldi	r24, 0x13	; 19
    603a:	93 e0       	ldi	r25, 0x03	; 3
    603c:	92 83       	std	Z+2, r25	; 0x02
    603e:	81 83       	std	Z+1, r24	; 0x01
    6040:	80 91 82 0d 	lds	r24, 0x0D82
    6044:	90 91 83 0d 	lds	r25, 0x0D83
    6048:	d8 01       	movw	r26, r16
    604a:	13 96       	adiw	r26, 0x03	; 3
    604c:	9c 93       	st	X, r25
    604e:	8e 93       	st	-X, r24
    6050:	12 97       	sbiw	r26, 0x02	; 2
    6052:	80 91 16 09 	lds	r24, 0x0916
    6056:	90 91 17 09 	lds	r25, 0x0917
    605a:	a0 91 18 09 	lds	r26, 0x0918
    605e:	b0 91 19 09 	lds	r27, 0x0919
    6062:	f8 01       	movw	r30, r16
    6064:	84 83       	std	Z+4, r24	; 0x04
    6066:	95 83       	std	Z+5, r25	; 0x05
    6068:	a6 83       	std	Z+6, r26	; 0x06
    606a:	b7 83       	std	Z+7, r27	; 0x07
    606c:	80 91 80 0d 	lds	r24, 0x0D80
    6070:	90 91 81 0d 	lds	r25, 0x0D81
    6074:	91 87       	std	Z+9, r25	; 0x09
    6076:	80 87       	std	Z+8, r24	; 0x08
    6078:	dd 24       	eor	r13, r13
    607a:	ee 24       	eor	r14, r14
    607c:	ff 24       	eor	r15, r15
							 "%lu KB total disk space.\n%lu KB available.\n"),
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
    607e:	f9 01       	movw	r30, r18
    6080:	82 8d       	ldd	r24, Z+26	; 0x1a
    6082:	93 8d       	ldd	r25, Z+27	; 0x1b
    6084:	a4 8d       	ldd	r26, Z+28	; 0x1c
    6086:	b5 8d       	ldd	r27, Z+29	; 0x1d
    6088:	9c 01       	movw	r18, r24
    608a:	ad 01       	movw	r20, r26
    608c:	22 50       	subi	r18, 0x02	; 2
    608e:	30 40       	sbci	r19, 0x00	; 0
    6090:	40 40       	sbci	r20, 0x00	; 0
    6092:	50 40       	sbci	r21, 0x00	; 0
				);
				AccSize = AccFiles = AccDirs = 0;
				strcpy((char*)Buff, ptr);
				res = scan_files((char*)Buff);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("\r%u files, %lu bytes.\n%u folders.\n"
    6094:	c7 01       	movw	r24, r14
    6096:	b6 01       	movw	r22, r12
    6098:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    609c:	dc 01       	movw	r26, r24
    609e:	cb 01       	movw	r24, r22
    60a0:	f8 01       	movw	r30, r16
    60a2:	82 87       	std	Z+10, r24	; 0x0a
    60a4:	93 87       	std	Z+11, r25	; 0x0b
    60a6:	a4 87       	std	Z+12, r26	; 0x0c
    60a8:	b5 87       	std	Z+13, r27	; 0x0d
    60aa:	2f 81       	ldd	r18, Y+7	; 0x07
    60ac:	38 85       	ldd	r19, Y+8	; 0x08
    60ae:	49 85       	ldd	r20, Y+9	; 0x09
    60b0:	5a 85       	ldd	r21, Y+10	; 0x0a
    60b2:	c7 01       	movw	r24, r14
    60b4:	b6 01       	movw	r22, r12
    60b6:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    60ba:	dc 01       	movw	r26, r24
    60bc:	cb 01       	movw	r24, r22
    60be:	f8 01       	movw	r30, r16
    60c0:	86 87       	std	Z+14, r24	; 0x0e
    60c2:	97 87       	std	Z+15, r25	; 0x0f
    60c4:	a0 8b       	std	Z+16, r26	; 0x10
    60c6:	b1 8b       	std	Z+17, r27	; 0x11
    60c8:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
							 "%lu KB total disk space.\n%lu KB available.\n"),
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
				);
				break;
    60cc:	2d b7       	in	r18, 0x3d	; 61
    60ce:	3e b7       	in	r19, 0x3e	; 62
    60d0:	2e 5e       	subi	r18, 0xEE	; 238
    60d2:	3f 4f       	sbci	r19, 0xFF	; 255
    60d4:	0f b6       	in	r0, 0x3f	; 63
    60d6:	f8 94       	cli
    60d8:	3e bf       	out	0x3e, r19	; 62
    60da:	0f be       	out	0x3f, r0	; 63
    60dc:	2d bf       	out	0x3d, r18	; 61
    60de:	f4 ca       	rjmp	.-2584   	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    60e0:	f9 01       	movw	r30, r18
    60e2:	33 96       	adiw	r30, 0x03	; 3
						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
				);
				break;

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
    60e4:	6f 5f       	subi	r22, 0xFF	; 255
    60e6:	7f 4f       	sbci	r23, 0xFF	; 255
    60e8:	7a 83       	std	Y+2, r23	; 0x02
    60ea:	69 83       	std	Y+1, r22	; 0x01
    60ec:	81 91       	ld	r24, Z+
    60ee:	80 32       	cpi	r24, 0x20	; 32
    60f0:	c9 f3       	breq	.-14     	; 0x60e4 <main+0xb84>
				res = f_opendir(&dir, ptr);
    60f2:	ce 01       	movw	r24, r28
    60f4:	4e 96       	adiw	r24, 0x1e	; 30
    60f6:	0e 94 bf 22 	call	0x457e	; 0x457e <f_opendir>
				if (res) { put_rc(res); break; }
    60fa:	88 23       	and	r24, r24
    60fc:	19 f0       	breq	.+6      	; 0x6104 <main+0xba4>
    60fe:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    6102:	e2 ca       	rjmp	.-2620   	; 0x56c8 <main+0x168>
				p1 = s1 = s2 = 0;
    6104:	1c 8a       	std	Y+20, r1	; 0x14
    6106:	1d 8a       	std	Y+21, r1	; 0x15
    6108:	1e 8a       	std	Y+22, r1	; 0x16
    610a:	1f 8a       	std	Y+23, r1	; 0x17
    610c:	18 8a       	std	Y+16, r1	; 0x10
    610e:	19 8a       	std	Y+17, r1	; 0x11
    6110:	1a 8a       	std	Y+18, r1	; 0x12
    6112:	1b 8a       	std	Y+19, r1	; 0x13
    6114:	1b 82       	std	Y+3, r1	; 0x03
    6116:	1c 82       	std	Y+4, r1	; 0x04
    6118:	1d 82       	std	Y+5, r1	; 0x05
    611a:	1e 82       	std	Y+6, r1	; 0x06
				for(;;) {
					res = f_readdir(&dir, &Finfo);
    611c:	0f 2e       	mov	r0, r31
    611e:	ff eb       	ldi	r31, 0xBF	; 191
    6120:	cf 2e       	mov	r12, r31
    6122:	f4 e0       	ldi	r31, 0x04	; 4
    6124:	df 2e       	mov	r13, r31
    6126:	f0 2d       	mov	r31, r0
								(Finfo.fattrib & AM_RDO) ? 'R' : '-',
								(Finfo.fattrib & AM_HID) ? 'H' : '-',
								(Finfo.fattrib & AM_SYS) ? 'S' : '-',
								(Finfo.fattrib & AM_ARC) ? 'A' : '-',
								(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
								(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
    6128:	aa 24       	eor	r10, r10
    612a:	bb 24       	eor	r11, r11
    612c:	68 94       	set
    612e:	a1 f8       	bld	r10, 1
    6130:	a4 0c       	add	r10, r4
    6132:	b5 1c       	adc	r11, r5
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    6134:	0f 2e       	mov	r0, r31
    6136:	f1 e6       	ldi	r31, 0x61	; 97
    6138:	2f 2e       	mov	r2, r31
    613a:	f3 e0       	ldi	r31, 0x03	; 3
    613c:	3f 2e       	mov	r3, r31
    613e:	f0 2d       	mov	r31, r0
				while (*ptr == ' ') ptr++;
				res = f_opendir(&dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
					res = f_readdir(&dir, &Finfo);
    6140:	ce 01       	movw	r24, r28
    6142:	4e 96       	adiw	r24, 0x1e	; 30
    6144:	b6 01       	movw	r22, r12
    6146:	0e 94 2d 23 	call	0x465a	; 0x465a <f_readdir>
					if ((res != FR_OK) || !Finfo.fname[0]) break;
    614a:	88 23       	and	r24, r24
    614c:	09 f0       	breq	.+2      	; 0x6150 <main+0xbf0>
    614e:	cc c0       	rjmp	.+408    	; 0x62e8 <main+0xd88>
    6150:	a8 ec       	ldi	r26, 0xC8	; 200
    6152:	b4 e0       	ldi	r27, 0x04	; 4
    6154:	8c 91       	ld	r24, X
    6156:	88 23       	and	r24, r24
    6158:	09 f4       	brne	.+2      	; 0x615c <main+0xbfc>
    615a:	c6 c0       	rjmp	.+396    	; 0x62e8 <main+0xd88>
					if (Finfo.fattrib & AM_DIR) {
    615c:	f3 01       	movw	r30, r6
    615e:	80 81       	ld	r24, Z
    6160:	84 ff       	sbrs	r24, 4
    6162:	0c c0       	rjmp	.+24     	; 0x617c <main+0xc1c>
						s2++;
    6164:	8c 89       	ldd	r24, Y+20	; 0x14
    6166:	9d 89       	ldd	r25, Y+21	; 0x15
    6168:	ae 89       	ldd	r26, Y+22	; 0x16
    616a:	bf 89       	ldd	r27, Y+23	; 0x17
    616c:	01 96       	adiw	r24, 0x01	; 1
    616e:	a1 1d       	adc	r26, r1
    6170:	b1 1d       	adc	r27, r1
    6172:	8c 8b       	std	Y+20, r24	; 0x14
    6174:	9d 8b       	std	Y+21, r25	; 0x15
    6176:	ae 8b       	std	Y+22, r26	; 0x16
    6178:	bf 8b       	std	Y+23, r27	; 0x17
    617a:	1c c0       	rjmp	.+56     	; 0x61b4 <main+0xc54>
					} else {
						s1++; p1 += Finfo.fsize;
    617c:	88 89       	ldd	r24, Y+16	; 0x10
    617e:	99 89       	ldd	r25, Y+17	; 0x11
    6180:	aa 89       	ldd	r26, Y+18	; 0x12
    6182:	bb 89       	ldd	r27, Y+19	; 0x13
    6184:	01 96       	adiw	r24, 0x01	; 1
    6186:	a1 1d       	adc	r26, r1
    6188:	b1 1d       	adc	r27, r1
    618a:	88 8b       	std	Y+16, r24	; 0x10
    618c:	99 8b       	std	Y+17, r25	; 0x11
    618e:	aa 8b       	std	Y+18, r26	; 0x12
    6190:	bb 8b       	std	Y+19, r27	; 0x13
    6192:	8b 81       	ldd	r24, Y+3	; 0x03
    6194:	9c 81       	ldd	r25, Y+4	; 0x04
    6196:	ad 81       	ldd	r26, Y+5	; 0x05
    6198:	be 81       	ldd	r27, Y+6	; 0x06
    619a:	f6 01       	movw	r30, r12
    619c:	40 81       	ld	r20, Z
    619e:	51 81       	ldd	r21, Z+1	; 0x01
    61a0:	62 81       	ldd	r22, Z+2	; 0x02
    61a2:	73 81       	ldd	r23, Z+3	; 0x03
    61a4:	84 0f       	add	r24, r20
    61a6:	95 1f       	adc	r25, r21
    61a8:	a6 1f       	adc	r26, r22
    61aa:	b7 1f       	adc	r27, r23
    61ac:	8b 83       	std	Y+3, r24	; 0x03
    61ae:	9c 83       	std	Y+4, r25	; 0x04
    61b0:	ad 83       	std	Y+5, r26	; 0x05
    61b2:	be 83       	std	Y+6, r27	; 0x06
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
								(Finfo.fattrib & AM_DIR) ? 'D' : '-',
    61b4:	d3 01       	movw	r26, r6
    61b6:	8c 91       	ld	r24, X
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    61b8:	84 ff       	sbrs	r24, 4
    61ba:	03 c0       	rjmp	.+6      	; 0x61c2 <main+0xc62>
    61bc:	44 e4       	ldi	r20, 0x44	; 68
    61be:	50 e0       	ldi	r21, 0x00	; 0
    61c0:	02 c0       	rjmp	.+4      	; 0x61c6 <main+0xc66>
    61c2:	4d e2       	ldi	r20, 0x2D	; 45
    61c4:	50 e0       	ldi	r21, 0x00	; 0
    61c6:	80 ff       	sbrs	r24, 0
    61c8:	03 c0       	rjmp	.+6      	; 0x61d0 <main+0xc70>
    61ca:	62 e5       	ldi	r22, 0x52	; 82
    61cc:	70 e0       	ldi	r23, 0x00	; 0
    61ce:	02 c0       	rjmp	.+4      	; 0x61d4 <main+0xc74>
    61d0:	6d e2       	ldi	r22, 0x2D	; 45
    61d2:	70 e0       	ldi	r23, 0x00	; 0
    61d4:	81 ff       	sbrs	r24, 1
    61d6:	05 c0       	rjmp	.+10     	; 0x61e2 <main+0xc82>
    61d8:	e8 e4       	ldi	r30, 0x48	; 72
    61da:	f0 e0       	ldi	r31, 0x00	; 0
    61dc:	fd af       	sts	0x7d, r31
    61de:	ec af       	sts	0x7c, r30
    61e0:	04 c0       	rjmp	.+8      	; 0x61ea <main+0xc8a>
    61e2:	2d e2       	ldi	r18, 0x2D	; 45
    61e4:	30 e0       	ldi	r19, 0x00	; 0
    61e6:	3d af       	sts	0x7d, r19
    61e8:	2c af       	sts	0x7c, r18
    61ea:	82 ff       	sbrs	r24, 2
    61ec:	06 c0       	rjmp	.+12     	; 0x61fa <main+0xc9a>
    61ee:	0f 2e       	mov	r0, r31
    61f0:	f3 e5       	ldi	r31, 0x53	; 83
    61f2:	ef 2e       	mov	r14, r31
    61f4:	ff 24       	eor	r15, r15
    61f6:	f0 2d       	mov	r31, r0
    61f8:	05 c0       	rjmp	.+10     	; 0x6204 <main+0xca4>
    61fa:	0f 2e       	mov	r0, r31
    61fc:	fd e2       	ldi	r31, 0x2D	; 45
    61fe:	ef 2e       	mov	r14, r31
    6200:	ff 24       	eor	r15, r15
    6202:	f0 2d       	mov	r31, r0
    6204:	85 ff       	sbrs	r24, 5
    6206:	03 c0       	rjmp	.+6      	; 0x620e <main+0xcae>
    6208:	81 e4       	ldi	r24, 0x41	; 65
    620a:	90 e0       	ldi	r25, 0x00	; 0
    620c:	02 c0       	rjmp	.+4      	; 0x6212 <main+0xcb2>
    620e:	8d e2       	ldi	r24, 0x2D	; 45
    6210:	90 e0       	ldi	r25, 0x00	; 0
								(Finfo.fattrib & AM_DIR) ? 'D' : '-',
								(Finfo.fattrib & AM_RDO) ? 'R' : '-',
								(Finfo.fattrib & AM_HID) ? 'H' : '-',
								(Finfo.fattrib & AM_SYS) ? 'S' : '-',
								(Finfo.fattrib & AM_ARC) ? 'A' : '-',
								(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
    6212:	d2 01       	movw	r26, r4
    6214:	2d 91       	ld	r18, X+
    6216:	3c 91       	ld	r19, X
								(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
    6218:	f5 01       	movw	r30, r10
    621a:	00 81       	ld	r16, Z
    621c:	11 81       	ldd	r17, Z+1	; 0x01
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    621e:	ad b7       	in	r26, 0x3d	; 61
    6220:	be b7       	in	r27, 0x3e	; 62
    6222:	5c 97       	sbiw	r26, 0x1c	; 28
    6224:	0f b6       	in	r0, 0x3f	; 63
    6226:	f8 94       	cli
    6228:	be bf       	out	0x3e, r27	; 62
    622a:	0f be       	out	0x3f, r0	; 63
    622c:	ad bf       	out	0x3d, r26	; 61
    622e:	ed b7       	in	r30, 0x3d	; 61
    6230:	fe b7       	in	r31, 0x3e	; 62
    6232:	31 96       	adiw	r30, 0x01	; 1
    6234:	12 96       	adiw	r26, 0x02	; 2
    6236:	3c 92       	st	X, r3
    6238:	2e 92       	st	-X, r2
    623a:	11 97       	sbiw	r26, 0x01	; 1
    623c:	53 83       	std	Z+3, r21	; 0x03
    623e:	42 83       	std	Z+2, r20	; 0x02
    6240:	75 83       	std	Z+5, r23	; 0x05
    6242:	64 83       	std	Z+4, r22	; 0x04
    6244:	4c ad       	sts	0x6c, r20
    6246:	5d ad       	sts	0x6d, r21
    6248:	57 83       	std	Z+7, r21	; 0x07
    624a:	46 83       	std	Z+6, r20	; 0x06
    624c:	f1 86       	std	Z+9, r15	; 0x09
    624e:	e0 86       	std	Z+8, r14	; 0x08
    6250:	93 87       	std	Z+11, r25	; 0x0b
    6252:	82 87       	std	Z+10, r24	; 0x0a
								(Finfo.fattrib & AM_DIR) ? 'D' : '-',
								(Finfo.fattrib & AM_RDO) ? 'R' : '-',
								(Finfo.fattrib & AM_HID) ? 'H' : '-',
								(Finfo.fattrib & AM_SYS) ? 'S' : '-',
								(Finfo.fattrib & AM_ARC) ? 'A' : '-',
								(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
    6254:	c9 01       	movw	r24, r18
    6256:	89 2f       	mov	r24, r25
    6258:	99 27       	eor	r25, r25
    625a:	86 95       	lsr	r24
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    625c:	84 54       	subi	r24, 0x44	; 68
    625e:	98 4f       	sbci	r25, 0xF8	; 248
    6260:	95 87       	std	Z+13, r25	; 0x0d
    6262:	84 87       	std	Z+12, r24	; 0x0c
								(Finfo.fattrib & AM_DIR) ? 'D' : '-',
								(Finfo.fattrib & AM_RDO) ? 'R' : '-',
								(Finfo.fattrib & AM_HID) ? 'H' : '-',
								(Finfo.fattrib & AM_SYS) ? 'S' : '-',
								(Finfo.fattrib & AM_ARC) ? 'A' : '-',
								(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
    6264:	c9 01       	movw	r24, r18
    6266:	96 95       	lsr	r25
    6268:	87 95       	ror	r24
    626a:	92 95       	swap	r25
    626c:	82 95       	swap	r24
    626e:	8f 70       	andi	r24, 0x0F	; 15
    6270:	89 27       	eor	r24, r25
    6272:	9f 70       	andi	r25, 0x0F	; 15
    6274:	89 27       	eor	r24, r25
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    6276:	8f 70       	andi	r24, 0x0F	; 15
    6278:	90 70       	andi	r25, 0x00	; 0
    627a:	97 87       	std	Z+15, r25	; 0x0f
    627c:	86 87       	std	Z+14, r24	; 0x0e
    627e:	c9 01       	movw	r24, r18
    6280:	8f 71       	andi	r24, 0x1F	; 31
    6282:	90 70       	andi	r25, 0x00	; 0
    6284:	91 8b       	std	Z+17, r25	; 0x11
    6286:	80 8b       	std	Z+16, r24	; 0x10
    6288:	81 2f       	mov	r24, r17
    628a:	86 95       	lsr	r24
    628c:	86 95       	lsr	r24
    628e:	86 95       	lsr	r24
    6290:	82 8b       	std	Z+18, r24	; 0x12
    6292:	13 8a       	std	Z+19, r1	; 0x13
								(Finfo.fattrib & AM_RDO) ? 'R' : '-',
								(Finfo.fattrib & AM_HID) ? 'H' : '-',
								(Finfo.fattrib & AM_SYS) ? 'S' : '-',
								(Finfo.fattrib & AM_ARC) ? 'A' : '-',
								(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
								(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
    6294:	c8 01       	movw	r24, r16
    6296:	96 95       	lsr	r25
    6298:	87 95       	ror	r24
    629a:	92 95       	swap	r25
    629c:	82 95       	swap	r24
    629e:	8f 70       	andi	r24, 0x0F	; 15
    62a0:	89 27       	eor	r24, r25
    62a2:	9f 70       	andi	r25, 0x0F	; 15
    62a4:	89 27       	eor	r24, r25
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
    62a6:	8f 73       	andi	r24, 0x3F	; 63
    62a8:	90 70       	andi	r25, 0x00	; 0
    62aa:	95 8b       	std	Z+21, r25	; 0x15
    62ac:	84 8b       	std	Z+20, r24	; 0x14
    62ae:	ac a9       	sts	0x4c, r26
    62b0:	bd a9       	sts	0x4d, r27
    62b2:	4d 91       	ld	r20, X+
    62b4:	5d 91       	ld	r21, X+
    62b6:	6d 91       	ld	r22, X+
    62b8:	7c 91       	ld	r23, X
    62ba:	46 8b       	std	Z+22, r20	; 0x16
    62bc:	57 8b       	std	Z+23, r21	; 0x17
    62be:	60 8f       	std	Z+24, r22	; 0x18
    62c0:	71 8f       	std	Z+25, r23	; 0x19
    62c2:	2e a9       	sts	0x4e, r18
    62c4:	3f a9       	sts	0x4f, r19
    62c6:	33 8f       	std	Z+27, r19	; 0x1b
    62c8:	22 8f       	std	Z+26, r18	; 0x1a
    62ca:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
#if _USE_LFN
					for (p2 = strlen(Finfo.fname); p2 < 14; p2++)
						xputc(' ');
					xprintf(PSTR("%s\n"), Lfname);
#else
					xputc('\n');
    62ce:	4d b7       	in	r20, 0x3d	; 61
    62d0:	5e b7       	in	r21, 0x3e	; 62
    62d2:	44 5e       	subi	r20, 0xE4	; 228
    62d4:	5f 4f       	sbci	r21, 0xFF	; 255
    62d6:	0f b6       	in	r0, 0x3f	; 63
    62d8:	f8 94       	cli
    62da:	5e bf       	out	0x3e, r21	; 62
    62dc:	0f be       	out	0x3f, r0	; 63
    62de:	4d bf       	out	0x3d, r20	; 61
    62e0:	8a e0       	ldi	r24, 0x0A	; 10
    62e2:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <xputc>
#endif
				}
    62e6:	2c cf       	rjmp	.-424    	; 0x6140 <main+0xbe0>
				xprintf(PSTR("%4u File(s),%10lu bytes total\n%4u Dir(s)"), s1, p1, s2);
    62e8:	8d b7       	in	r24, 0x3d	; 61
    62ea:	9e b7       	in	r25, 0x3e	; 62
    62ec:	0e 97       	sbiw	r24, 0x0e	; 14
    62ee:	0f b6       	in	r0, 0x3f	; 63
    62f0:	f8 94       	cli
    62f2:	9e bf       	out	0x3e, r25	; 62
    62f4:	0f be       	out	0x3f, r0	; 63
    62f6:	8d bf       	out	0x3d, r24	; 61
    62f8:	ed b7       	in	r30, 0x3d	; 61
    62fa:	fe b7       	in	r31, 0x3e	; 62
    62fc:	31 96       	adiw	r30, 0x01	; 1
    62fe:	8c e8       	ldi	r24, 0x8C	; 140
    6300:	93 e0       	ldi	r25, 0x03	; 3
    6302:	ad b7       	in	r26, 0x3d	; 61
    6304:	be b7       	in	r27, 0x3e	; 62
    6306:	12 96       	adiw	r26, 0x02	; 2
    6308:	9c 93       	st	X, r25
    630a:	8e 93       	st	-X, r24
    630c:	11 97       	sbiw	r26, 0x01	; 1
    630e:	88 89       	ldd	r24, Y+16	; 0x10
    6310:	99 89       	ldd	r25, Y+17	; 0x11
    6312:	aa 89       	ldd	r26, Y+18	; 0x12
    6314:	bb 89       	ldd	r27, Y+19	; 0x13
    6316:	82 83       	std	Z+2, r24	; 0x02
    6318:	93 83       	std	Z+3, r25	; 0x03
    631a:	a4 83       	std	Z+4, r26	; 0x04
    631c:	b5 83       	std	Z+5, r27	; 0x05
    631e:	8b 81       	ldd	r24, Y+3	; 0x03
    6320:	9c 81       	ldd	r25, Y+4	; 0x04
    6322:	ad 81       	ldd	r26, Y+5	; 0x05
    6324:	be 81       	ldd	r27, Y+6	; 0x06
    6326:	86 83       	std	Z+6, r24	; 0x06
    6328:	97 83       	std	Z+7, r25	; 0x07
    632a:	a0 87       	std	Z+8, r26	; 0x08
    632c:	b1 87       	std	Z+9, r27	; 0x09
    632e:	8c 89       	ldd	r24, Y+20	; 0x14
    6330:	9d 89       	ldd	r25, Y+21	; 0x15
    6332:	ae 89       	ldd	r26, Y+22	; 0x16
    6334:	bf 89       	ldd	r27, Y+23	; 0x17
    6336:	82 87       	std	Z+10, r24	; 0x0a
    6338:	93 87       	std	Z+11, r25	; 0x0b
    633a:	a4 87       	std	Z+12, r26	; 0x0c
    633c:	b5 87       	std	Z+13, r27	; 0x0d
    633e:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				if (f_getfree(ptr, (DWORD*)&p1, &fs) == FR_OK)
    6342:	ed b7       	in	r30, 0x3d	; 61
    6344:	fe b7       	in	r31, 0x3e	; 62
    6346:	3e 96       	adiw	r30, 0x0e	; 14
    6348:	0f b6       	in	r0, 0x3f	; 63
    634a:	f8 94       	cli
    634c:	fe bf       	out	0x3e, r31	; 62
    634e:	0f be       	out	0x3f, r0	; 63
    6350:	ed bf       	out	0x3d, r30	; 61
    6352:	89 81       	ldd	r24, Y+1	; 0x01
    6354:	9a 81       	ldd	r25, Y+2	; 0x02
    6356:	be 01       	movw	r22, r28
    6358:	6d 5f       	subi	r22, 0xFD	; 253
    635a:	7f 4f       	sbci	r23, 0xFF	; 255
    635c:	ae 01       	movw	r20, r28
    635e:	44 5e       	subi	r20, 0xE4	; 228
    6360:	5f 4f       	sbci	r21, 0xFF	; 255
    6362:	0e 94 c2 23 	call	0x4784	; 0x4784 <f_getfree>
    6366:	88 23       	and	r24, r24
    6368:	09 f0       	breq	.+2      	; 0x636c <main+0xe0c>
    636a:	ae c9       	rjmp	.-3236   	; 0x56c8 <main+0x168>
					xprintf(PSTR(", %10luK bytes free\n"), p1 * fs->csize / 2);
    636c:	00 d0       	rcall	.+0      	; 0x636e <main+0xe0e>
    636e:	00 d0       	rcall	.+0      	; 0x6370 <main+0xe10>
    6370:	00 d0       	rcall	.+0      	; 0x6372 <main+0xe12>
    6372:	85 eb       	ldi	r24, 0xB5	; 181
    6374:	93 e0       	ldi	r25, 0x03	; 3
    6376:	ad b7       	in	r26, 0x3d	; 61
    6378:	be b7       	in	r27, 0x3e	; 62
    637a:	12 96       	adiw	r26, 0x02	; 2
    637c:	9c 93       	st	X, r25
    637e:	8e 93       	st	-X, r24
    6380:	11 97       	sbiw	r26, 0x01	; 1
    6382:	ec 8d       	ldd	r30, Y+28	; 0x1c
    6384:	fd 8d       	ldd	r31, Y+29	; 0x1d
    6386:	62 81       	ldd	r22, Z+2	; 0x02
    6388:	70 e0       	ldi	r23, 0x00	; 0
    638a:	80 e0       	ldi	r24, 0x00	; 0
    638c:	90 e0       	ldi	r25, 0x00	; 0
    638e:	2b 81       	ldd	r18, Y+3	; 0x03
    6390:	3c 81       	ldd	r19, Y+4	; 0x04
    6392:	4d 81       	ldd	r20, Y+5	; 0x05
    6394:	5e 81       	ldd	r21, Y+6	; 0x06
    6396:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    639a:	22 e0       	ldi	r18, 0x02	; 2
    639c:	30 e0       	ldi	r19, 0x00	; 0
    639e:	40 e0       	ldi	r20, 0x00	; 0
    63a0:	50 e0       	ldi	r21, 0x00	; 0
    63a2:	0e 94 b9 3b 	call	0x7772	; 0x7772 <__divmodsi4>
    63a6:	ed b7       	in	r30, 0x3d	; 61
    63a8:	fe b7       	in	r31, 0x3e	; 62
    63aa:	23 83       	std	Z+3, r18	; 0x03
    63ac:	34 83       	std	Z+4, r19	; 0x04
    63ae:	45 83       	std	Z+5, r20	; 0x05
    63b0:	56 83       	std	Z+6, r21	; 0x06
    63b2:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    63b6:	2d b7       	in	r18, 0x3d	; 61
    63b8:	3e b7       	in	r19, 0x3e	; 62
    63ba:	2a 5f       	subi	r18, 0xFA	; 250
    63bc:	3f 4f       	sbci	r19, 0xFF	; 255
    63be:	0f b6       	in	r0, 0x3f	; 63
    63c0:	f8 94       	cli
    63c2:	3e bf       	out	0x3e, r19	; 62
    63c4:	0f be       	out	0x3f, r0	; 63
    63c6:	2d bf       	out	0x3d, r18	; 61
    63c8:	7f c9       	rjmp	.-3330   	; 0x56c8 <main+0x168>
				break;

			case 'o' :	/* fo <mode> <name> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
    63ca:	ce 01       	movw	r24, r28
    63cc:	01 96       	adiw	r24, 0x01	; 1
    63ce:	be 01       	movw	r22, r28
    63d0:	6d 5f       	subi	r22, 0xFD	; 253
    63d2:	7f 4f       	sbci	r23, 0xFF	; 255
    63d4:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    63d8:	88 23       	and	r24, r24
    63da:	09 f4       	brne	.+2      	; 0x63de <main+0xe7e>
    63dc:	75 c9       	rjmp	.-3350   	; 0x56c8 <main+0x168>
				while (*ptr == ' ') ptr++;
    63de:	69 81       	ldd	r22, Y+1	; 0x01
    63e0:	7a 81       	ldd	r23, Y+2	; 0x02
    63e2:	db 01       	movw	r26, r22
    63e4:	8c 91       	ld	r24, X
    63e6:	80 32       	cpi	r24, 0x20	; 32
    63e8:	49 f4       	brne	.+18     	; 0x63fc <main+0xe9c>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    63ea:	fb 01       	movw	r30, r22
    63ec:	31 96       	adiw	r30, 0x01	; 1
					xprintf(PSTR(", %10luK bytes free\n"), p1 * fs->csize / 2);
				break;

			case 'o' :	/* fo <mode> <name> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
				while (*ptr == ' ') ptr++;
    63ee:	6f 5f       	subi	r22, 0xFF	; 255
    63f0:	7f 4f       	sbci	r23, 0xFF	; 255
    63f2:	7a 83       	std	Y+2, r23	; 0x02
    63f4:	69 83       	std	Y+1, r22	; 0x01
    63f6:	81 91       	ld	r24, Z+
    63f8:	80 32       	cpi	r24, 0x20	; 32
    63fa:	c9 f3       	breq	.-14     	; 0x63ee <main+0xe8e>
				put_rc(f_open(&File[0], ptr, (BYTE)p1));
    63fc:	85 ed       	ldi	r24, 0xD5	; 213
    63fe:	94 e0       	ldi	r25, 0x04	; 4
    6400:	4b 81       	ldd	r20, Y+3	; 0x03
    6402:	0e 94 23 1a 	call	0x3446	; 0x3446 <f_open>
    6406:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    640a:	5e c9       	rjmp	.-3396   	; 0x56c8 <main+0x168>

			case 'c' :	/* fc - Close a file */
				put_rc(f_close(&File[0]));
    640c:	85 ed       	ldi	r24, 0xD5	; 213
    640e:	94 e0       	ldi	r25, 0x04	; 4
    6410:	0e 94 32 20 	call	0x4064	; 0x4064 <f_close>
    6414:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6418:	57 c9       	rjmp	.-3410   	; 0x56c8 <main+0x168>

			case 'e' :	/* fe - Seek file pointer */
				if (!xatoi(&ptr, &p1)) break;
    641a:	ce 01       	movw	r24, r28
    641c:	01 96       	adiw	r24, 0x01	; 1
    641e:	be 01       	movw	r22, r28
    6420:	6d 5f       	subi	r22, 0xFD	; 253
    6422:	7f 4f       	sbci	r23, 0xFF	; 255
    6424:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6428:	88 23       	and	r24, r24
    642a:	09 f4       	brne	.+2      	; 0x642e <main+0xece>
    642c:	4d c9       	rjmp	.-3430   	; 0x56c8 <main+0x168>
				res = f_lseek(&File[0], p1);
    642e:	4b 81       	ldd	r20, Y+3	; 0x03
    6430:	5c 81       	ldd	r21, Y+4	; 0x04
    6432:	6d 81       	ldd	r22, Y+5	; 0x05
    6434:	7e 81       	ldd	r23, Y+6	; 0x06
    6436:	85 ed       	ldi	r24, 0xD5	; 213
    6438:	94 e0       	ldi	r25, 0x04	; 4
    643a:	0e 94 9e 20 	call	0x413c	; 0x413c <f_lseek>
    643e:	08 2f       	mov	r16, r24
				put_rc(res);
    6440:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				if (res == FR_OK)
    6444:	00 23       	and	r16, r16
    6446:	09 f0       	breq	.+2      	; 0x644a <main+0xeea>
    6448:	3f c9       	rjmp	.-3458   	; 0x56c8 <main+0x168>
					xprintf(PSTR("fptr = %lu(0x%lX)\n"), File[0].fptr, File[0].fptr);
    644a:	80 91 db 04 	lds	r24, 0x04DB
    644e:	90 91 dc 04 	lds	r25, 0x04DC
    6452:	a0 91 dd 04 	lds	r26, 0x04DD
    6456:	b0 91 de 04 	lds	r27, 0x04DE
    645a:	ed b7       	in	r30, 0x3d	; 61
    645c:	fe b7       	in	r31, 0x3e	; 62
    645e:	3a 97       	sbiw	r30, 0x0a	; 10
    6460:	0f b6       	in	r0, 0x3f	; 63
    6462:	f8 94       	cli
    6464:	fe bf       	out	0x3e, r31	; 62
    6466:	0f be       	out	0x3f, r0	; 63
    6468:	ed bf       	out	0x3d, r30	; 61
    646a:	4d b7       	in	r20, 0x3d	; 61
    646c:	5e b7       	in	r21, 0x3e	; 62
    646e:	4f 5f       	subi	r20, 0xFF	; 255
    6470:	5f 4f       	sbci	r21, 0xFF	; 255
    6472:	2a ec       	ldi	r18, 0xCA	; 202
    6474:	33 e0       	ldi	r19, 0x03	; 3
    6476:	32 83       	std	Z+2, r19	; 0x02
    6478:	21 83       	std	Z+1, r18	; 0x01
    647a:	fa 01       	movw	r30, r20
    647c:	82 83       	std	Z+2, r24	; 0x02
    647e:	93 83       	std	Z+3, r25	; 0x03
    6480:	a4 83       	std	Z+4, r26	; 0x04
    6482:	b5 83       	std	Z+5, r27	; 0x05
    6484:	86 83       	std	Z+6, r24	; 0x06
    6486:	97 83       	std	Z+7, r25	; 0x07
    6488:	a0 87       	std	Z+8, r26	; 0x08
    648a:	b1 87       	std	Z+9, r27	; 0x09
    648c:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
    6490:	2d b7       	in	r18, 0x3d	; 61
    6492:	3e b7       	in	r19, 0x3e	; 62
    6494:	26 5f       	subi	r18, 0xF6	; 246
    6496:	3f 4f       	sbci	r19, 0xFF	; 255
    6498:	0f b6       	in	r0, 0x3f	; 63
    649a:	f8 94       	cli
    649c:	3e bf       	out	0x3e, r19	; 62
    649e:	0f be       	out	0x3f, r0	; 63
    64a0:	2d bf       	out	0x3d, r18	; 61
    64a2:	12 c9       	rjmp	.-3548   	; 0x56c8 <main+0x168>
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
    64a4:	ce 01       	movw	r24, r28
    64a6:	01 96       	adiw	r24, 0x01	; 1
    64a8:	be 01       	movw	r22, r28
    64aa:	6d 5f       	subi	r22, 0xFD	; 253
    64ac:	7f 4f       	sbci	r23, 0xFF	; 255
    64ae:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    64b2:	88 23       	and	r24, r24
    64b4:	09 f4       	brne	.+2      	; 0x64b8 <main+0xf58>
    64b6:	08 c9       	rjmp	.-3568   	; 0x56c8 <main+0x168>
				p2 = 0;
    64b8:	1f 82       	std	Y+7, r1	; 0x07
    64ba:	18 86       	std	Y+8, r1	; 0x08
    64bc:	19 86       	std	Y+9, r1	; 0x09
    64be:	1a 86       	std	Y+10, r1	; 0x0a
				cli(); Timer = 0; sei();
    64c0:	f8 94       	cli
    64c2:	10 92 84 0d 	sts	0x0D84, r1
    64c6:	10 92 85 0d 	sts	0x0D85, r1
    64ca:	10 92 86 0d 	sts	0x0D86, r1
    64ce:	10 92 87 0d 	sts	0x0D87, r1
    64d2:	78 94       	sei
				while (p1) {
					if (p1 >= sizeof Buff)	{ cnt = sizeof Buff; p1 -= sizeof Buff; }
    64d4:	cc 24       	eor	r12, r12
    64d6:	dd 24       	eor	r13, r13
    64d8:	76 01       	movw	r14, r12
    64da:	68 94       	set
    64dc:	d2 f8       	bld	r13, 2
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_read(&File[0], Buff, cnt, &s2);
    64de:	0f 2e       	mov	r0, r31
    64e0:	f5 ed       	ldi	r31, 0xD5	; 213
    64e2:	af 2e       	mov	r10, r31
    64e4:	f4 e0       	ldi	r31, 0x04	; 4
    64e6:	bf 2e       	mov	r11, r31
    64e8:	f0 2d       	mov	r31, r0
    64ea:	0f 2e       	mov	r0, r31
    64ec:	fa e1       	ldi	r31, 0x1A	; 26
    64ee:	2f 2e       	mov	r2, r31
    64f0:	f9 e0       	ldi	r31, 0x09	; 9
    64f2:	3f 2e       	mov	r3, r31
    64f4:	f0 2d       	mov	r31, r0

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				cli(); Timer = 0; sei();
				while (p1) {
    64f6:	48 c0       	rjmp	.+144    	; 0x6588 <main+0x1028>
					if (p1 >= sizeof Buff)	{ cnt = sizeof Buff; p1 -= sizeof Buff; }
    64f8:	80 30       	cpi	r24, 0x00	; 0
    64fa:	34 e0       	ldi	r19, 0x04	; 4
    64fc:	93 07       	cpc	r25, r19
    64fe:	30 e0       	ldi	r19, 0x00	; 0
    6500:	a3 07       	cpc	r26, r19
    6502:	30 e0       	ldi	r19, 0x00	; 0
    6504:	b3 07       	cpc	r27, r19
    6506:	6c f0       	brlt	.+26     	; 0x6522 <main+0xfc2>
    6508:	c8 8e       	std	Y+24, r12	; 0x18
    650a:	d9 8e       	std	Y+25, r13	; 0x19
    650c:	ea 8e       	std	Y+26, r14	; 0x1a
    650e:	fb 8e       	std	Y+27, r15	; 0x1b
    6510:	80 50       	subi	r24, 0x00	; 0
    6512:	94 40       	sbci	r25, 0x04	; 4
    6514:	a0 40       	sbci	r26, 0x00	; 0
    6516:	b0 40       	sbci	r27, 0x00	; 0
    6518:	8b 83       	std	Y+3, r24	; 0x03
    651a:	9c 83       	std	Y+4, r25	; 0x04
    651c:	ad 83       	std	Y+5, r26	; 0x05
    651e:	be 83       	std	Y+6, r27	; 0x06
    6520:	0a c0       	rjmp	.+20     	; 0x6536 <main+0xfd6>
					else 			{ cnt = (WORD)p1; p1 = 0; }
    6522:	a0 e0       	ldi	r26, 0x00	; 0
    6524:	b0 e0       	ldi	r27, 0x00	; 0
    6526:	88 8f       	std	Y+24, r24	; 0x18
    6528:	99 8f       	std	Y+25, r25	; 0x19
    652a:	aa 8f       	std	Y+26, r26	; 0x1a
    652c:	bb 8f       	std	Y+27, r27	; 0x1b
    652e:	1b 82       	std	Y+3, r1	; 0x03
    6530:	1c 82       	std	Y+4, r1	; 0x04
    6532:	1d 82       	std	Y+5, r1	; 0x05
    6534:	1e 82       	std	Y+6, r1	; 0x06
					res = f_read(&File[0], Buff, cnt, &s2);
    6536:	28 8d       	ldd	r18, Y+24	; 0x18
    6538:	39 8d       	ldd	r19, Y+25	; 0x19
    653a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    653c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    653e:	c5 01       	movw	r24, r10
    6540:	b1 01       	movw	r22, r2
    6542:	8e 01       	movw	r16, r28
    6544:	0c 5e       	subi	r16, 0xEC	; 236
    6546:	1f 4f       	sbci	r17, 0xFF	; 255
    6548:	0e 94 4f 1b 	call	0x369e	; 0x369e <f_read>
					if (res != FR_OK) { put_rc(res); break; }
    654c:	88 23       	and	r24, r24
    654e:	19 f0       	breq	.+6      	; 0x6556 <main+0xff6>
    6550:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    6554:	22 c0       	rjmp	.+68     	; 0x659a <main+0x103a>
					p2 += s2;
    6556:	4c 89       	ldd	r20, Y+20	; 0x14
    6558:	5d 89       	ldd	r21, Y+21	; 0x15
    655a:	6e 89       	ldd	r22, Y+22	; 0x16
    655c:	7f 89       	ldd	r23, Y+23	; 0x17
    655e:	8f 81       	ldd	r24, Y+7	; 0x07
    6560:	98 85       	ldd	r25, Y+8	; 0x08
    6562:	a9 85       	ldd	r26, Y+9	; 0x09
    6564:	ba 85       	ldd	r27, Y+10	; 0x0a
    6566:	84 0f       	add	r24, r20
    6568:	95 1f       	adc	r25, r21
    656a:	a6 1f       	adc	r26, r22
    656c:	b7 1f       	adc	r27, r23
    656e:	8f 83       	std	Y+7, r24	; 0x07
    6570:	98 87       	std	Y+8, r25	; 0x08
    6572:	a9 87       	std	Y+9, r26	; 0x09
    6574:	ba 87       	std	Y+10, r27	; 0x0a
					if (cnt != s2) break;
    6576:	88 8d       	ldd	r24, Y+24	; 0x18
    6578:	99 8d       	ldd	r25, Y+25	; 0x19
    657a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    657c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    657e:	48 17       	cp	r20, r24
    6580:	59 07       	cpc	r21, r25
    6582:	6a 07       	cpc	r22, r26
    6584:	7b 07       	cpc	r23, r27
    6586:	49 f4       	brne	.+18     	; 0x659a <main+0x103a>

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				cli(); Timer = 0; sei();
				while (p1) {
    6588:	8b 81       	ldd	r24, Y+3	; 0x03
    658a:	9c 81       	ldd	r25, Y+4	; 0x04
    658c:	ad 81       	ldd	r26, Y+5	; 0x05
    658e:	be 81       	ldd	r27, Y+6	; 0x06
    6590:	00 97       	sbiw	r24, 0x00	; 0
    6592:	a1 05       	cpc	r26, r1
    6594:	b1 05       	cpc	r27, r1
    6596:	09 f0       	breq	.+2      	; 0x659a <main+0x103a>
    6598:	af cf       	rjmp	.-162    	; 0x64f8 <main+0xf98>
					res = f_read(&File[0], Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				cli(); s2 = Timer; sei();
    659a:	f8 94       	cli
    659c:	80 91 84 0d 	lds	r24, 0x0D84
    65a0:	90 91 85 0d 	lds	r25, 0x0D85
    65a4:	a0 91 86 0d 	lds	r26, 0x0D86
    65a8:	b0 91 87 0d 	lds	r27, 0x0D87
    65ac:	8c 8b       	std	Y+20, r24	; 0x14
    65ae:	9d 8b       	std	Y+21, r25	; 0x15
    65b0:	ae 8b       	std	Y+22, r26	; 0x16
    65b2:	bf 8b       	std	Y+23, r27	; 0x17
    65b4:	78 94       	sei
				xprintf(PSTR("%lu bytes read with %lu bytes/sec.\n"), p2, s2 ? (p2 * 100 / s2) : 0);
    65b6:	8f 81       	ldd	r24, Y+7	; 0x07
    65b8:	98 85       	ldd	r25, Y+8	; 0x08
    65ba:	a9 85       	ldd	r26, Y+9	; 0x09
    65bc:	ba 85       	ldd	r27, Y+10	; 0x0a
    65be:	8c af       	sts	0x7c, r24
    65c0:	9d af       	sts	0x7d, r25
    65c2:	ae af       	sts	0x7e, r26
    65c4:	bf af       	sts	0x7f, r27
    65c6:	cc 88       	ldd	r12, Y+20	; 0x14
    65c8:	dd 88       	ldd	r13, Y+21	; 0x15
    65ca:	ee 88       	ldd	r14, Y+22	; 0x16
    65cc:	ff 88       	ldd	r15, Y+23	; 0x17
    65ce:	c1 14       	cp	r12, r1
    65d0:	d1 04       	cpc	r13, r1
    65d2:	e1 04       	cpc	r14, r1
    65d4:	f1 04       	cpc	r15, r1
    65d6:	79 f0       	breq	.+30     	; 0x65f6 <main+0x1096>
    65d8:	bc 01       	movw	r22, r24
    65da:	cd 01       	movw	r24, r26
    65dc:	24 e6       	ldi	r18, 0x64	; 100
    65de:	30 e0       	ldi	r19, 0x00	; 0
    65e0:	40 e0       	ldi	r20, 0x00	; 0
    65e2:	50 e0       	ldi	r21, 0x00	; 0
    65e4:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    65e8:	a7 01       	movw	r20, r14
    65ea:	96 01       	movw	r18, r12
    65ec:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>
    65f0:	89 01       	movw	r16, r18
    65f2:	9a 01       	movw	r18, r20
    65f4:	03 c0       	rjmp	.+6      	; 0x65fc <main+0x109c>
    65f6:	00 e0       	ldi	r16, 0x00	; 0
    65f8:	10 e0       	ldi	r17, 0x00	; 0
    65fa:	98 01       	movw	r18, r16
    65fc:	ad b7       	in	r26, 0x3d	; 61
    65fe:	be b7       	in	r27, 0x3e	; 62
    6600:	1a 97       	sbiw	r26, 0x0a	; 10
    6602:	0f b6       	in	r0, 0x3f	; 63
    6604:	f8 94       	cli
    6606:	be bf       	out	0x3e, r27	; 62
    6608:	0f be       	out	0x3f, r0	; 63
    660a:	ad bf       	out	0x3d, r26	; 61
    660c:	ed b7       	in	r30, 0x3d	; 61
    660e:	fe b7       	in	r31, 0x3e	; 62
    6610:	31 96       	adiw	r30, 0x01	; 1
    6612:	8d ed       	ldi	r24, 0xDD	; 221
    6614:	93 e0       	ldi	r25, 0x03	; 3
    6616:	12 96       	adiw	r26, 0x02	; 2
    6618:	9c 93       	st	X, r25
    661a:	8e 93       	st	-X, r24
    661c:	11 97       	sbiw	r26, 0x01	; 1
    661e:	8c ad       	sts	0x6c, r24
    6620:	9d ad       	sts	0x6d, r25
    6622:	ae ad       	sts	0x6e, r26
    6624:	bf ad       	sts	0x6f, r27
    6626:	82 83       	std	Z+2, r24	; 0x02
    6628:	93 83       	std	Z+3, r25	; 0x03
    662a:	a4 83       	std	Z+4, r26	; 0x04
    662c:	b5 83       	std	Z+5, r27	; 0x05
    662e:	06 83       	std	Z+6, r16	; 0x06
    6630:	17 83       	std	Z+7, r17	; 0x07
    6632:	20 87       	std	Z+8, r18	; 0x08
    6634:	31 87       	std	Z+9, r19	; 0x09
    6636:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				break;
    663a:	ad b7       	in	r26, 0x3d	; 61
    663c:	be b7       	in	r27, 0x3e	; 62
    663e:	1a 96       	adiw	r26, 0x0a	; 10
    6640:	0f b6       	in	r0, 0x3f	; 63
    6642:	f8 94       	cli
    6644:	be bf       	out	0x3e, r27	; 62
    6646:	0f be       	out	0x3f, r0	; 63
    6648:	ad bf       	out	0x3d, r26	; 61
    664a:	3e c8       	rjmp	.-3972   	; 0x56c8 <main+0x168>

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
    664c:	ce 01       	movw	r24, r28
    664e:	01 96       	adiw	r24, 0x01	; 1
    6650:	be 01       	movw	r22, r28
    6652:	6d 5f       	subi	r22, 0xFD	; 253
    6654:	7f 4f       	sbci	r23, 0xFF	; 255
    6656:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    665a:	88 23       	and	r24, r24
    665c:	09 f4       	brne	.+2      	; 0x6660 <main+0x1100>
    665e:	34 c8       	rjmp	.-3992   	; 0x56c8 <main+0x168>
				ofs = File[0].fptr;
    6660:	c0 90 db 04 	lds	r12, 0x04DB
    6664:	d0 90 dc 04 	lds	r13, 0x04DC
    6668:	e0 90 dd 04 	lds	r14, 0x04DD
    666c:	f0 90 de 04 	lds	r15, 0x04DE
				while (p1) {
    6670:	8b 81       	ldd	r24, Y+3	; 0x03
    6672:	9c 81       	ldd	r25, Y+4	; 0x04
    6674:	ad 81       	ldd	r26, Y+5	; 0x05
    6676:	be 81       	ldd	r27, Y+6	; 0x06
    6678:	00 97       	sbiw	r24, 0x00	; 0
    667a:	a1 05       	cpc	r26, r1
    667c:	b1 05       	cpc	r27, r1
    667e:	09 f4       	brne	.+2      	; 0x6682 <main+0x1122>
    6680:	23 c8       	rjmp	.-4026   	; 0x56c8 <main+0x168>
					if (p1 >= 16)	{ cnt = 16; p1 -= 16; }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_read(&File[0], Buff, cnt, &cnt);
    6682:	0f 2e       	mov	r0, r31
    6684:	f5 ed       	ldi	r31, 0xD5	; 213
    6686:	2f 2e       	mov	r2, r31
    6688:	f4 e0       	ldi	r31, 0x04	; 4
    668a:	3f 2e       	mov	r3, r31
    668c:	f0 2d       	mov	r31, r0
    668e:	0f 2e       	mov	r0, r31
    6690:	fa e1       	ldi	r31, 0x1A	; 26
    6692:	af 2e       	mov	r10, r31
    6694:	f9 e0       	ldi	r31, 0x09	; 9
    6696:	bf 2e       	mov	r11, r31
    6698:	f0 2d       	mov	r31, r0

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File[0].fptr;
				while (p1) {
					if (p1 >= 16)	{ cnt = 16; p1 -= 16; }
    669a:	80 31       	cpi	r24, 0x10	; 16
    669c:	91 05       	cpc	r25, r1
    669e:	a1 05       	cpc	r26, r1
    66a0:	b1 05       	cpc	r27, r1
    66a2:	84 f0       	brlt	.+32     	; 0x66c4 <main+0x1164>
    66a4:	20 e1       	ldi	r18, 0x10	; 16
    66a6:	30 e0       	ldi	r19, 0x00	; 0
    66a8:	40 e0       	ldi	r20, 0x00	; 0
    66aa:	50 e0       	ldi	r21, 0x00	; 0
    66ac:	28 8f       	std	Y+24, r18	; 0x18
    66ae:	39 8f       	std	Y+25, r19	; 0x19
    66b0:	4a 8f       	std	Y+26, r20	; 0x1a
    66b2:	5b 8f       	std	Y+27, r21	; 0x1b
    66b4:	40 97       	sbiw	r24, 0x10	; 16
    66b6:	a1 09       	sbc	r26, r1
    66b8:	b1 09       	sbc	r27, r1
    66ba:	8b 83       	std	Y+3, r24	; 0x03
    66bc:	9c 83       	std	Y+4, r25	; 0x04
    66be:	ad 83       	std	Y+5, r26	; 0x05
    66c0:	be 83       	std	Y+6, r27	; 0x06
    66c2:	0a c0       	rjmp	.+20     	; 0x66d8 <main+0x1178>
					else 			{ cnt = (WORD)p1; p1 = 0; }
    66c4:	a0 e0       	ldi	r26, 0x00	; 0
    66c6:	b0 e0       	ldi	r27, 0x00	; 0
    66c8:	88 8f       	std	Y+24, r24	; 0x18
    66ca:	99 8f       	std	Y+25, r25	; 0x19
    66cc:	aa 8f       	std	Y+26, r26	; 0x1a
    66ce:	bb 8f       	std	Y+27, r27	; 0x1b
    66d0:	1b 82       	std	Y+3, r1	; 0x03
    66d2:	1c 82       	std	Y+4, r1	; 0x04
    66d4:	1d 82       	std	Y+5, r1	; 0x05
    66d6:	1e 82       	std	Y+6, r1	; 0x06
					res = f_read(&File[0], Buff, cnt, &cnt);
    66d8:	28 8d       	ldd	r18, Y+24	; 0x18
    66da:	39 8d       	ldd	r19, Y+25	; 0x19
    66dc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    66de:	5b 8d       	ldd	r21, Y+27	; 0x1b
    66e0:	c1 01       	movw	r24, r2
    66e2:	b5 01       	movw	r22, r10
    66e4:	8e 01       	movw	r16, r28
    66e6:	08 5e       	subi	r16, 0xE8	; 232
    66e8:	1f 4f       	sbci	r17, 0xFF	; 255
    66ea:	0e 94 4f 1b 	call	0x369e	; 0x369e <f_read>
					if (res != FR_OK) { put_rc(res); break; }
    66ee:	88 23       	and	r24, r24
    66f0:	21 f0       	breq	.+8      	; 0x66fa <main+0x119a>
    66f2:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    66f6:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
					if (!cnt) break;
    66fa:	08 8d       	ldd	r16, Y+24	; 0x18
    66fc:	19 8d       	ldd	r17, Y+25	; 0x19
    66fe:	2a 8d       	ldd	r18, Y+26	; 0x1a
    6700:	3b 8d       	ldd	r19, Y+27	; 0x1b
    6702:	01 15       	cp	r16, r1
    6704:	11 05       	cpc	r17, r1
    6706:	21 05       	cpc	r18, r1
    6708:	31 05       	cpc	r19, r1
    670a:	11 f4       	brne	.+4      	; 0x6710 <main+0x11b0>
    670c:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
					put_dump(Buff, ofs, cnt);
    6710:	c5 01       	movw	r24, r10
    6712:	b7 01       	movw	r22, r14
    6714:	a6 01       	movw	r20, r12
    6716:	20 2f       	mov	r18, r16
    6718:	0e 94 67 29 	call	0x52ce	; 0x52ce <put_dump>
					ofs += 16;
    671c:	80 e1       	ldi	r24, 0x10	; 16
    671e:	90 e0       	ldi	r25, 0x00	; 0
    6720:	a0 e0       	ldi	r26, 0x00	; 0
    6722:	b0 e0       	ldi	r27, 0x00	; 0
    6724:	c8 0e       	add	r12, r24
    6726:	d9 1e       	adc	r13, r25
    6728:	ea 1e       	adc	r14, r26
    672a:	fb 1e       	adc	r15, r27
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File[0].fptr;
				while (p1) {
    672c:	8b 81       	ldd	r24, Y+3	; 0x03
    672e:	9c 81       	ldd	r25, Y+4	; 0x04
    6730:	ad 81       	ldd	r26, Y+5	; 0x05
    6732:	be 81       	ldd	r27, Y+6	; 0x06
    6734:	00 97       	sbiw	r24, 0x00	; 0
    6736:	a1 05       	cpc	r26, r1
    6738:	b1 05       	cpc	r27, r1
    673a:	09 f0       	breq	.+2      	; 0x673e <main+0x11de>
    673c:	ae cf       	rjmp	.-164    	; 0x669a <main+0x113a>
    673e:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
					ofs += 16;
				}
				break;

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
    6742:	ce 01       	movw	r24, r28
    6744:	01 96       	adiw	r24, 0x01	; 1
    6746:	be 01       	movw	r22, r28
    6748:	6d 5f       	subi	r22, 0xFD	; 253
    674a:	7f 4f       	sbci	r23, 0xFF	; 255
    674c:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6750:	88 23       	and	r24, r24
    6752:	11 f4       	brne	.+4      	; 0x6758 <main+0x11f8>
    6754:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    6758:	ce 01       	movw	r24, r28
    675a:	01 96       	adiw	r24, 0x01	; 1
    675c:	be 01       	movw	r22, r28
    675e:	69 5f       	subi	r22, 0xF9	; 249
    6760:	7f 4f       	sbci	r23, 0xFF	; 255
    6762:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6766:	88 23       	and	r24, r24
    6768:	11 f4       	brne	.+4      	; 0x676e <main+0x120e>
    676a:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				memset(Buff, (BYTE)p2, sizeof Buff);
    676e:	6f 81       	ldd	r22, Y+7	; 0x07
    6770:	8a e1       	ldi	r24, 0x1A	; 26
    6772:	99 e0       	ldi	r25, 0x09	; 9
    6774:	70 e0       	ldi	r23, 0x00	; 0
    6776:	40 e0       	ldi	r20, 0x00	; 0
    6778:	54 e0       	ldi	r21, 0x04	; 4
    677a:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <memset>
				p2 = 0;
    677e:	1f 82       	std	Y+7, r1	; 0x07
    6780:	18 86       	std	Y+8, r1	; 0x08
    6782:	19 86       	std	Y+9, r1	; 0x09
    6784:	1a 86       	std	Y+10, r1	; 0x0a
				cli(); Timer = 0; sei();
    6786:	f8 94       	cli
    6788:	10 92 84 0d 	sts	0x0D84, r1
    678c:	10 92 85 0d 	sts	0x0D85, r1
    6790:	10 92 86 0d 	sts	0x0D86, r1
    6794:	10 92 87 0d 	sts	0x0D87, r1
    6798:	78 94       	sei
				while (p1) {
					if (p1 >= sizeof Buff)	{ cnt = sizeof Buff; p1 -= sizeof Buff; }
    679a:	cc 24       	eor	r12, r12
    679c:	dd 24       	eor	r13, r13
    679e:	76 01       	movw	r14, r12
    67a0:	68 94       	set
    67a2:	d2 f8       	bld	r13, 2
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_write(&File[0], Buff, cnt, &s2);
    67a4:	0f 2e       	mov	r0, r31
    67a6:	f5 ed       	ldi	r31, 0xD5	; 213
    67a8:	af 2e       	mov	r10, r31
    67aa:	f4 e0       	ldi	r31, 0x04	; 4
    67ac:	bf 2e       	mov	r11, r31
    67ae:	f0 2d       	mov	r31, r0
    67b0:	0f 2e       	mov	r0, r31
    67b2:	fa e1       	ldi	r31, 0x1A	; 26
    67b4:	2f 2e       	mov	r2, r31
    67b6:	f9 e0       	ldi	r31, 0x09	; 9
    67b8:	3f 2e       	mov	r3, r31
    67ba:	f0 2d       	mov	r31, r0
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, sizeof Buff);
				p2 = 0;
				cli(); Timer = 0; sei();
				while (p1) {
    67bc:	48 c0       	rjmp	.+144    	; 0x684e <main+0x12ee>
					if (p1 >= sizeof Buff)	{ cnt = sizeof Buff; p1 -= sizeof Buff; }
    67be:	80 30       	cpi	r24, 0x00	; 0
    67c0:	e4 e0       	ldi	r30, 0x04	; 4
    67c2:	9e 07       	cpc	r25, r30
    67c4:	e0 e0       	ldi	r30, 0x00	; 0
    67c6:	ae 07       	cpc	r26, r30
    67c8:	e0 e0       	ldi	r30, 0x00	; 0
    67ca:	be 07       	cpc	r27, r30
    67cc:	6c f0       	brlt	.+26     	; 0x67e8 <main+0x1288>
    67ce:	c8 8e       	std	Y+24, r12	; 0x18
    67d0:	d9 8e       	std	Y+25, r13	; 0x19
    67d2:	ea 8e       	std	Y+26, r14	; 0x1a
    67d4:	fb 8e       	std	Y+27, r15	; 0x1b
    67d6:	80 50       	subi	r24, 0x00	; 0
    67d8:	94 40       	sbci	r25, 0x04	; 4
    67da:	a0 40       	sbci	r26, 0x00	; 0
    67dc:	b0 40       	sbci	r27, 0x00	; 0
    67de:	8b 83       	std	Y+3, r24	; 0x03
    67e0:	9c 83       	std	Y+4, r25	; 0x04
    67e2:	ad 83       	std	Y+5, r26	; 0x05
    67e4:	be 83       	std	Y+6, r27	; 0x06
    67e6:	0a c0       	rjmp	.+20     	; 0x67fc <main+0x129c>
					else 			{ cnt = (WORD)p1; p1 = 0; }
    67e8:	a0 e0       	ldi	r26, 0x00	; 0
    67ea:	b0 e0       	ldi	r27, 0x00	; 0
    67ec:	88 8f       	std	Y+24, r24	; 0x18
    67ee:	99 8f       	std	Y+25, r25	; 0x19
    67f0:	aa 8f       	std	Y+26, r26	; 0x1a
    67f2:	bb 8f       	std	Y+27, r27	; 0x1b
    67f4:	1b 82       	std	Y+3, r1	; 0x03
    67f6:	1c 82       	std	Y+4, r1	; 0x04
    67f8:	1d 82       	std	Y+5, r1	; 0x05
    67fa:	1e 82       	std	Y+6, r1	; 0x06
					res = f_write(&File[0], Buff, cnt, &s2);
    67fc:	28 8d       	ldd	r18, Y+24	; 0x18
    67fe:	39 8d       	ldd	r19, Y+25	; 0x19
    6800:	4a 8d       	ldd	r20, Y+26	; 0x1a
    6802:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6804:	c5 01       	movw	r24, r10
    6806:	b1 01       	movw	r22, r2
    6808:	8e 01       	movw	r16, r28
    680a:	0c 5e       	subi	r16, 0xEC	; 236
    680c:	1f 4f       	sbci	r17, 0xFF	; 255
    680e:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
					if (res != FR_OK) { put_rc(res); break; }
    6812:	88 23       	and	r24, r24
    6814:	19 f0       	breq	.+6      	; 0x681c <main+0x12bc>
    6816:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    681a:	22 c0       	rjmp	.+68     	; 0x6860 <main+0x1300>
					p2 += s2;
    681c:	4c 89       	ldd	r20, Y+20	; 0x14
    681e:	5d 89       	ldd	r21, Y+21	; 0x15
    6820:	6e 89       	ldd	r22, Y+22	; 0x16
    6822:	7f 89       	ldd	r23, Y+23	; 0x17
    6824:	8f 81       	ldd	r24, Y+7	; 0x07
    6826:	98 85       	ldd	r25, Y+8	; 0x08
    6828:	a9 85       	ldd	r26, Y+9	; 0x09
    682a:	ba 85       	ldd	r27, Y+10	; 0x0a
    682c:	84 0f       	add	r24, r20
    682e:	95 1f       	adc	r25, r21
    6830:	a6 1f       	adc	r26, r22
    6832:	b7 1f       	adc	r27, r23
    6834:	8f 83       	std	Y+7, r24	; 0x07
    6836:	98 87       	std	Y+8, r25	; 0x08
    6838:	a9 87       	std	Y+9, r26	; 0x09
    683a:	ba 87       	std	Y+10, r27	; 0x0a
					if (cnt != s2) break;
    683c:	88 8d       	ldd	r24, Y+24	; 0x18
    683e:	99 8d       	ldd	r25, Y+25	; 0x19
    6840:	aa 8d       	ldd	r26, Y+26	; 0x1a
    6842:	bb 8d       	ldd	r27, Y+27	; 0x1b
    6844:	48 17       	cp	r20, r24
    6846:	59 07       	cpc	r21, r25
    6848:	6a 07       	cpc	r22, r26
    684a:	7b 07       	cpc	r23, r27
    684c:	49 f4       	brne	.+18     	; 0x6860 <main+0x1300>
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, sizeof Buff);
				p2 = 0;
				cli(); Timer = 0; sei();
				while (p1) {
    684e:	8b 81       	ldd	r24, Y+3	; 0x03
    6850:	9c 81       	ldd	r25, Y+4	; 0x04
    6852:	ad 81       	ldd	r26, Y+5	; 0x05
    6854:	be 81       	ldd	r27, Y+6	; 0x06
    6856:	00 97       	sbiw	r24, 0x00	; 0
    6858:	a1 05       	cpc	r26, r1
    685a:	b1 05       	cpc	r27, r1
    685c:	09 f0       	breq	.+2      	; 0x6860 <main+0x1300>
    685e:	af cf       	rjmp	.-162    	; 0x67be <main+0x125e>
					res = f_write(&File[0], Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				cli(); s2 = Timer; sei();
    6860:	f8 94       	cli
    6862:	80 91 84 0d 	lds	r24, 0x0D84
    6866:	90 91 85 0d 	lds	r25, 0x0D85
    686a:	a0 91 86 0d 	lds	r26, 0x0D86
    686e:	b0 91 87 0d 	lds	r27, 0x0D87
    6872:	8c 8b       	std	Y+20, r24	; 0x14
    6874:	9d 8b       	std	Y+21, r25	; 0x15
    6876:	ae 8b       	std	Y+22, r26	; 0x16
    6878:	bf 8b       	std	Y+23, r27	; 0x17
    687a:	78 94       	sei
				xprintf(PSTR("%lu bytes written with %lu bytes/sec.\n"), p2, s2 ? (p2 * 100 / s2) : 0);
    687c:	2f 81       	ldd	r18, Y+7	; 0x07
    687e:	38 85       	ldd	r19, Y+8	; 0x08
    6880:	49 85       	ldd	r20, Y+9	; 0x09
    6882:	5a 85       	ldd	r21, Y+10	; 0x0a
    6884:	2c af       	sts	0x7c, r18
    6886:	3d af       	sts	0x7d, r19
    6888:	4e af       	sts	0x7e, r20
    688a:	5f af       	sts	0x7f, r21
    688c:	cc 88       	ldd	r12, Y+20	; 0x14
    688e:	dd 88       	ldd	r13, Y+21	; 0x15
    6890:	ee 88       	ldd	r14, Y+22	; 0x16
    6892:	ff 88       	ldd	r15, Y+23	; 0x17
    6894:	c1 14       	cp	r12, r1
    6896:	d1 04       	cpc	r13, r1
    6898:	e1 04       	cpc	r14, r1
    689a:	f1 04       	cpc	r15, r1
    689c:	79 f0       	breq	.+30     	; 0x68bc <main+0x135c>
    689e:	ca 01       	movw	r24, r20
    68a0:	b9 01       	movw	r22, r18
    68a2:	24 e6       	ldi	r18, 0x64	; 100
    68a4:	30 e0       	ldi	r19, 0x00	; 0
    68a6:	40 e0       	ldi	r20, 0x00	; 0
    68a8:	50 e0       	ldi	r21, 0x00	; 0
    68aa:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    68ae:	a7 01       	movw	r20, r14
    68b0:	96 01       	movw	r18, r12
    68b2:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>
    68b6:	89 01       	movw	r16, r18
    68b8:	9a 01       	movw	r18, r20
    68ba:	03 c0       	rjmp	.+6      	; 0x68c2 <main+0x1362>
    68bc:	00 e0       	ldi	r16, 0x00	; 0
    68be:	10 e0       	ldi	r17, 0x00	; 0
    68c0:	98 01       	movw	r18, r16
    68c2:	4d b7       	in	r20, 0x3d	; 61
    68c4:	5e b7       	in	r21, 0x3e	; 62
    68c6:	4a 50       	subi	r20, 0x0A	; 10
    68c8:	50 40       	sbci	r21, 0x00	; 0
    68ca:	0f b6       	in	r0, 0x3f	; 63
    68cc:	f8 94       	cli
    68ce:	5e bf       	out	0x3e, r21	; 62
    68d0:	0f be       	out	0x3f, r0	; 63
    68d2:	4d bf       	out	0x3d, r20	; 61
    68d4:	ed b7       	in	r30, 0x3d	; 61
    68d6:	fe b7       	in	r31, 0x3e	; 62
    68d8:	31 96       	adiw	r30, 0x01	; 1
    68da:	81 e0       	ldi	r24, 0x01	; 1
    68dc:	94 e0       	ldi	r25, 0x04	; 4
    68de:	ad b7       	in	r26, 0x3d	; 61
    68e0:	be b7       	in	r27, 0x3e	; 62
    68e2:	12 96       	adiw	r26, 0x02	; 2
    68e4:	9c 93       	st	X, r25
    68e6:	8e 93       	st	-X, r24
    68e8:	11 97       	sbiw	r26, 0x01	; 1
    68ea:	8c ad       	sts	0x6c, r24
    68ec:	9d ad       	sts	0x6d, r25
    68ee:	ae ad       	sts	0x6e, r26
    68f0:	bf ad       	sts	0x6f, r27
    68f2:	82 83       	std	Z+2, r24	; 0x02
    68f4:	93 83       	std	Z+3, r25	; 0x03
    68f6:	a4 83       	std	Z+4, r26	; 0x04
    68f8:	b5 83       	std	Z+5, r27	; 0x05
    68fa:	06 83       	std	Z+6, r16	; 0x06
    68fc:	17 83       	std	Z+7, r17	; 0x07
    68fe:	20 87       	std	Z+8, r18	; 0x08
    6900:	31 87       	std	Z+9, r19	; 0x09
    6902:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				break;
    6906:	ad b7       	in	r26, 0x3d	; 61
    6908:	be b7       	in	r27, 0x3e	; 62
    690a:	1a 96       	adiw	r26, 0x0a	; 10
    690c:	0f b6       	in	r0, 0x3f	; 63
    690e:	f8 94       	cli
    6910:	be bf       	out	0x3e, r27	; 62
    6912:	0f be       	out	0x3f, r0	; 63
    6914:	ad bf       	out	0x3d, r26	; 61
    6916:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
			case 'W':							
				f_write(&File[0], "Data Written!\n", 13, &s1);
    691a:	85 ed       	ldi	r24, 0xD5	; 213
    691c:	94 e0       	ldi	r25, 0x04	; 4
    691e:	6a e9       	ldi	r22, 0x9A	; 154
    6920:	71 e0       	ldi	r23, 0x01	; 1
    6922:	2d e0       	ldi	r18, 0x0D	; 13
    6924:	30 e0       	ldi	r19, 0x00	; 0
    6926:	40 e0       	ldi	r20, 0x00	; 0
    6928:	50 e0       	ldi	r21, 0x00	; 0
    692a:	8e 01       	movw	r16, r28
    692c:	00 5f       	subi	r16, 0xF0	; 240
    692e:	1f 4f       	sbci	r17, 0xFF	; 255
    6930:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
				break;
    6934:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				
			case 'v' :	/* fv - Truncate file */
				put_rc(f_truncate(&File[0]));
    6938:	85 ed       	ldi	r24, 0xD5	; 213
    693a:	94 e0       	ldi	r25, 0x04	; 4
    693c:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <f_truncate>
    6940:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6944:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6948:	f9 01       	movw	r30, r18
    694a:	33 96       	adiw	r30, 0x03	; 3
			case 'v' :	/* fv - Truncate file */
				put_rc(f_truncate(&File[0]));
				break;

			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
    694c:	6f 5f       	subi	r22, 0xFF	; 255
    694e:	7f 4f       	sbci	r23, 0xFF	; 255
    6950:	7a 83       	std	Y+2, r23	; 0x02
    6952:	69 83       	std	Y+1, r22	; 0x01
    6954:	81 91       	ld	r24, Z+
    6956:	80 32       	cpi	r24, 0x20	; 32
    6958:	c9 f3       	breq	.-14     	; 0x694c <main+0x13ec>
				ptr2 = strchr(ptr, ' ');
    695a:	cb 01       	movw	r24, r22
    695c:	60 e2       	ldi	r22, 0x20	; 32
    695e:	70 e0       	ldi	r23, 0x00	; 0
    6960:	0e 94 db 3b 	call	0x77b6	; 0x77b6 <strchr>
				if (!ptr2) break;
    6964:	00 97       	sbiw	r24, 0x00	; 0
    6966:	11 f4       	brne	.+4      	; 0x696c <main+0x140c>
    6968:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				*ptr2++ = 0;
    696c:	fc 01       	movw	r30, r24
    696e:	11 92       	st	Z+, r1
				while (*ptr2 == ' ') ptr2++;
    6970:	dc 01       	movw	r26, r24
    6972:	11 96       	adiw	r26, 0x01	; 1
    6974:	2c 91       	ld	r18, X
    6976:	11 97       	sbiw	r26, 0x01	; 1
    6978:	20 32       	cpi	r18, 0x20	; 32
    697a:	31 f4       	brne	.+12     	; 0x6988 <main+0x1428>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    697c:	02 96       	adiw	r24, 0x02	; 2
			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
    697e:	fc 01       	movw	r30, r24
    6980:	01 96       	adiw	r24, 0x01	; 1
    6982:	20 81       	ld	r18, Z
    6984:	20 32       	cpi	r18, 0x20	; 32
    6986:	d9 f3       	breq	.-10     	; 0x697e <main+0x141e>
				put_rc(f_rename(ptr, ptr2));
    6988:	89 81       	ldd	r24, Y+1	; 0x01
    698a:	9a 81       	ldd	r25, Y+2	; 0x02
    698c:	bf 01       	movw	r22, r30
    698e:	0e 94 3f 28 	call	0x507e	; 0x507e <f_rename>
    6992:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6996:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    699a:	f9 01       	movw	r30, r18
    699c:	33 96       	adiw	r30, 0x03	; 3
				while (*ptr2 == ' ') ptr2++;
				put_rc(f_rename(ptr, ptr2));
				break;

			case 'u' :	/* fu <name> - Unlink a file or dir */
				while (*ptr == ' ') ptr++;
    699e:	6f 5f       	subi	r22, 0xFF	; 255
    69a0:	7f 4f       	sbci	r23, 0xFF	; 255
    69a2:	7a 83       	std	Y+2, r23	; 0x02
    69a4:	69 83       	std	Y+1, r22	; 0x01
    69a6:	81 91       	ld	r24, Z+
    69a8:	80 32       	cpi	r24, 0x20	; 32
    69aa:	c9 f3       	breq	.-14     	; 0x699e <main+0x143e>
				put_rc(f_unlink(ptr));
    69ac:	cb 01       	movw	r24, r22
    69ae:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <f_unlink>
    69b2:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    69b6:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    69ba:	f9 01       	movw	r30, r18
    69bc:	33 96       	adiw	r30, 0x03	; 3
				while (*ptr == ' ') ptr++;
				put_rc(f_unlink(ptr));
				break;

			case 'k' :	/* fk <name> - Create a directory */
				while (*ptr == ' ') ptr++;
    69be:	6f 5f       	subi	r22, 0xFF	; 255
    69c0:	7f 4f       	sbci	r23, 0xFF	; 255
    69c2:	7a 83       	std	Y+2, r23	; 0x02
    69c4:	69 83       	std	Y+1, r22	; 0x01
    69c6:	81 91       	ld	r24, Z+
    69c8:	80 32       	cpi	r24, 0x20	; 32
    69ca:	c9 f3       	breq	.-14     	; 0x69be <main+0x145e>
				put_rc(f_mkdir(ptr));
    69cc:	cb 01       	movw	r24, r22
    69ce:	0e 94 42 26 	call	0x4c84	; 0x4c84 <f_mkdir>
    69d2:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    69d6:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

			case 'a' :	/* fa <atrr> <mask> <name> - Change file/dir attribute */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
    69da:	ce 01       	movw	r24, r28
    69dc:	01 96       	adiw	r24, 0x01	; 1
    69de:	be 01       	movw	r22, r28
    69e0:	6d 5f       	subi	r22, 0xFD	; 253
    69e2:	7f 4f       	sbci	r23, 0xFF	; 255
    69e4:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    69e8:	88 23       	and	r24, r24
    69ea:	11 f4       	brne	.+4      	; 0x69f0 <main+0x1490>
    69ec:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    69f0:	ce 01       	movw	r24, r28
    69f2:	01 96       	adiw	r24, 0x01	; 1
    69f4:	be 01       	movw	r22, r28
    69f6:	69 5f       	subi	r22, 0xF9	; 249
    69f8:	7f 4f       	sbci	r23, 0xFF	; 255
    69fa:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    69fe:	88 23       	and	r24, r24
    6a00:	11 f4       	brne	.+4      	; 0x6a06 <main+0x14a6>
    6a02:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				while (*ptr == ' ') ptr++;
    6a06:	89 81       	ldd	r24, Y+1	; 0x01
    6a08:	9a 81       	ldd	r25, Y+2	; 0x02
    6a0a:	fc 01       	movw	r30, r24
    6a0c:	20 81       	ld	r18, Z
    6a0e:	20 32       	cpi	r18, 0x20	; 32
    6a10:	39 f4       	brne	.+14     	; 0x6a20 <main+0x14c0>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6a12:	31 96       	adiw	r30, 0x01	; 1
				put_rc(f_mkdir(ptr));
				break;

			case 'a' :	/* fa <atrr> <mask> <name> - Change file/dir attribute */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				while (*ptr == ' ') ptr++;
    6a14:	01 96       	adiw	r24, 0x01	; 1
    6a16:	9a 83       	std	Y+2, r25	; 0x02
    6a18:	89 83       	std	Y+1, r24	; 0x01
    6a1a:	21 91       	ld	r18, Z+
    6a1c:	20 32       	cpi	r18, 0x20	; 32
    6a1e:	d1 f3       	breq	.-12     	; 0x6a14 <main+0x14b4>
				put_rc(f_chmod(ptr, p1, p2));
    6a20:	6b 81       	ldd	r22, Y+3	; 0x03
    6a22:	4f 81       	ldd	r20, Y+7	; 0x07
    6a24:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <f_chmod>
    6a28:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6a2c:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
    6a30:	ce 01       	movw	r24, r28
    6a32:	01 96       	adiw	r24, 0x01	; 1
    6a34:	be 01       	movw	r22, r28
    6a36:	6d 5f       	subi	r22, 0xFD	; 253
    6a38:	7f 4f       	sbci	r23, 0xFF	; 255
    6a3a:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6a3e:	88 23       	and	r24, r24
    6a40:	11 f4       	brne	.+4      	; 0x6a46 <main+0x14e6>
    6a42:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    6a46:	ce 01       	movw	r24, r28
    6a48:	01 96       	adiw	r24, 0x01	; 1
    6a4a:	be 01       	movw	r22, r28
    6a4c:	69 5f       	subi	r22, 0xF9	; 249
    6a4e:	7f 4f       	sbci	r23, 0xFF	; 255
    6a50:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6a54:	88 23       	and	r24, r24
    6a56:	11 f4       	brne	.+4      	; 0x6a5c <main+0x14fc>
    6a58:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    6a5c:	ce 01       	movw	r24, r28
    6a5e:	01 96       	adiw	r24, 0x01	; 1
    6a60:	be 01       	movw	r22, r28
    6a62:	65 5f       	subi	r22, 0xF5	; 245
    6a64:	7f 4f       	sbci	r23, 0xFF	; 255
    6a66:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6a6a:	88 23       	and	r24, r24
    6a6c:	11 f4       	brne	.+4      	; 0x6a72 <main+0x1512>
    6a6e:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
    6a72:	8b 81       	ldd	r24, Y+3	; 0x03
    6a74:	9c 81       	ldd	r25, Y+4	; 0x04
    6a76:	ad 81       	ldd	r26, Y+5	; 0x05
    6a78:	be 81       	ldd	r27, Y+6	; 0x06
    6a7a:	8c 5b       	subi	r24, 0xBC	; 188
    6a7c:	97 40       	sbci	r25, 0x07	; 7
    6a7e:	a0 40       	sbci	r26, 0x00	; 0
    6a80:	b0 40       	sbci	r27, 0x00	; 0
    6a82:	ac 01       	movw	r20, r24
    6a84:	bd 01       	movw	r22, r26
    6a86:	03 2e       	mov	r0, r19
    6a88:	39 e0       	ldi	r19, 0x09	; 9
    6a8a:	44 0f       	add	r20, r20
    6a8c:	55 1f       	adc	r21, r21
    6a8e:	66 1f       	adc	r22, r22
    6a90:	77 1f       	adc	r23, r23
    6a92:	3a 95       	dec	r19
    6a94:	d1 f7       	brne	.-12     	; 0x6a8a <main+0x152a>
    6a96:	30 2d       	mov	r19, r0
    6a98:	8f 81       	ldd	r24, Y+7	; 0x07
    6a9a:	98 85       	ldd	r25, Y+8	; 0x08
    6a9c:	a9 85       	ldd	r26, Y+9	; 0x09
    6a9e:	ba 85       	ldd	r27, Y+10	; 0x0a
    6aa0:	8f 70       	andi	r24, 0x0F	; 15
    6aa2:	90 70       	andi	r25, 0x00	; 0
    6aa4:	a0 70       	andi	r26, 0x00	; 0
    6aa6:	b0 70       	andi	r27, 0x00	; 0
    6aa8:	88 0f       	add	r24, r24
    6aaa:	99 1f       	adc	r25, r25
    6aac:	aa 1f       	adc	r26, r26
    6aae:	bb 1f       	adc	r27, r27
    6ab0:	88 0f       	add	r24, r24
    6ab2:	99 1f       	adc	r25, r25
    6ab4:	aa 1f       	adc	r26, r26
    6ab6:	bb 1f       	adc	r27, r27
    6ab8:	88 0f       	add	r24, r24
    6aba:	99 1f       	adc	r25, r25
    6abc:	aa 1f       	adc	r26, r26
    6abe:	bb 1f       	adc	r27, r27
    6ac0:	88 0f       	add	r24, r24
    6ac2:	99 1f       	adc	r25, r25
    6ac4:	aa 1f       	adc	r26, r26
    6ac6:	bb 1f       	adc	r27, r27
    6ac8:	88 0f       	add	r24, r24
    6aca:	99 1f       	adc	r25, r25
    6acc:	aa 1f       	adc	r26, r26
    6ace:	bb 1f       	adc	r27, r27
    6ad0:	48 2b       	or	r20, r24
    6ad2:	59 2b       	or	r21, r25
    6ad4:	8b 85       	ldd	r24, Y+11	; 0x0b
    6ad6:	9c 85       	ldd	r25, Y+12	; 0x0c
    6ad8:	8f 71       	andi	r24, 0x1F	; 31
    6ada:	90 70       	andi	r25, 0x00	; 0
    6adc:	84 2b       	or	r24, r20
    6ade:	95 2b       	or	r25, r21
    6ae0:	d2 01       	movw	r26, r4
    6ae2:	8d 93       	st	X+, r24
    6ae4:	9c 93       	st	X, r25
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
    6ae6:	ce 01       	movw	r24, r28
    6ae8:	01 96       	adiw	r24, 0x01	; 1
    6aea:	be 01       	movw	r22, r28
    6aec:	6d 5f       	subi	r22, 0xFD	; 253
    6aee:	7f 4f       	sbci	r23, 0xFF	; 255
    6af0:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6af4:	88 23       	and	r24, r24
    6af6:	11 f4       	brne	.+4      	; 0x6afc <main+0x159c>
    6af8:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    6afc:	ce 01       	movw	r24, r28
    6afe:	01 96       	adiw	r24, 0x01	; 1
    6b00:	be 01       	movw	r22, r28
    6b02:	69 5f       	subi	r22, 0xF9	; 249
    6b04:	7f 4f       	sbci	r23, 0xFF	; 255
    6b06:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6b0a:	88 23       	and	r24, r24
    6b0c:	11 f4       	brne	.+4      	; 0x6b12 <main+0x15b2>
    6b0e:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
    6b12:	ce 01       	movw	r24, r28
    6b14:	01 96       	adiw	r24, 0x01	; 1
    6b16:	be 01       	movw	r22, r28
    6b18:	65 5f       	subi	r22, 0xF5	; 245
    6b1a:	7f 4f       	sbci	r23, 0xFF	; 255
    6b1c:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6b20:	88 23       	and	r24, r24
    6b22:	11 f4       	brne	.+4      	; 0x6b28 <main+0x15c8>
    6b24:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				Finfo.ftime = ((p1 & 31) << 11) | ((p2 & 63) << 5) | ((p3 >> 1) & 31);
    6b28:	8f 81       	ldd	r24, Y+7	; 0x07
    6b2a:	98 85       	ldd	r25, Y+8	; 0x08
    6b2c:	a9 85       	ldd	r26, Y+9	; 0x09
    6b2e:	ba 85       	ldd	r27, Y+10	; 0x0a
    6b30:	8f 73       	andi	r24, 0x3F	; 63
    6b32:	90 70       	andi	r25, 0x00	; 0
    6b34:	a0 70       	andi	r26, 0x00	; 0
    6b36:	b0 70       	andi	r27, 0x00	; 0
    6b38:	ac 01       	movw	r20, r24
    6b3a:	bd 01       	movw	r22, r26
    6b3c:	68 94       	set
    6b3e:	14 f8       	bld	r1, 4
    6b40:	44 0f       	add	r20, r20
    6b42:	55 1f       	adc	r21, r21
    6b44:	66 1f       	adc	r22, r22
    6b46:	77 1f       	adc	r23, r23
    6b48:	16 94       	lsr	r1
    6b4a:	d1 f7       	brne	.-12     	; 0x6b40 <main+0x15e0>
    6b4c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b4e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b50:	ad 85       	ldd	r26, Y+13	; 0x0d
    6b52:	be 85       	ldd	r27, Y+14	; 0x0e
    6b54:	b5 95       	asr	r27
    6b56:	a7 95       	ror	r26
    6b58:	97 95       	ror	r25
    6b5a:	87 95       	ror	r24
    6b5c:	8f 71       	andi	r24, 0x1F	; 31
    6b5e:	90 70       	andi	r25, 0x00	; 0
    6b60:	48 2b       	or	r20, r24
    6b62:	59 2b       	or	r21, r25
    6b64:	8b 81       	ldd	r24, Y+3	; 0x03
    6b66:	9c 81       	ldd	r25, Y+4	; 0x04
    6b68:	ad 81       	ldd	r26, Y+5	; 0x05
    6b6a:	be 81       	ldd	r27, Y+6	; 0x06
    6b6c:	07 2e       	mov	r0, r23
    6b6e:	7b e0       	ldi	r23, 0x0B	; 11
    6b70:	88 0f       	add	r24, r24
    6b72:	99 1f       	adc	r25, r25
    6b74:	aa 1f       	adc	r26, r26
    6b76:	bb 1f       	adc	r27, r27
    6b78:	7a 95       	dec	r23
    6b7a:	d1 f7       	brne	.-12     	; 0x6b70 <main+0x1610>
    6b7c:	70 2d       	mov	r23, r0
    6b7e:	84 2b       	or	r24, r20
    6b80:	95 2b       	or	r25, r21
    6b82:	90 93 c6 04 	sts	0x04C6, r25
    6b86:	80 93 c5 04 	sts	0x04C5, r24
				while (*ptr == ' ') ptr++;
    6b8a:	89 81       	ldd	r24, Y+1	; 0x01
    6b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    6b8e:	fc 01       	movw	r30, r24
    6b90:	20 81       	ld	r18, Z
    6b92:	20 32       	cpi	r18, 0x20	; 32
    6b94:	39 f4       	brne	.+14     	; 0x6ba4 <main+0x1644>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6b96:	31 96       	adiw	r30, 0x01	; 1
			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.ftime = ((p1 & 31) << 11) | ((p2 & 63) << 5) | ((p3 >> 1) & 31);
				while (*ptr == ' ') ptr++;
    6b98:	01 96       	adiw	r24, 0x01	; 1
    6b9a:	9a 83       	std	Y+2, r25	; 0x02
    6b9c:	89 83       	std	Y+1, r24	; 0x01
    6b9e:	21 91       	ld	r18, Z+
    6ba0:	20 32       	cpi	r18, 0x20	; 32
    6ba2:	d1 f3       	breq	.-12     	; 0x6b98 <main+0x1638>
				put_rc(f_utime(ptr, &Finfo));
    6ba4:	6f eb       	ldi	r22, 0xBF	; 191
    6ba6:	74 e0       	ldi	r23, 0x04	; 4
    6ba8:	0e 94 ea 27 	call	0x4fd4	; 0x4fd4 <f_utime>
    6bac:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6bb0:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6bb4:	f9 01       	movw	r30, r18
    6bb6:	33 96       	adiw	r30, 0x03	; 3
				while (*ptr == ' ') ptr++;
				put_rc(f_utime(ptr, &Finfo));
				break;

			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
    6bb8:	6f 5f       	subi	r22, 0xFF	; 255
    6bba:	7f 4f       	sbci	r23, 0xFF	; 255
    6bbc:	7a 83       	std	Y+2, r23	; 0x02
    6bbe:	69 83       	std	Y+1, r22	; 0x01
    6bc0:	81 91       	ld	r24, Z+
    6bc2:	80 32       	cpi	r24, 0x20	; 32
    6bc4:	c9 f3       	breq	.-14     	; 0x6bb8 <main+0x1658>
				ptr2 = strchr(ptr, ' ');
    6bc6:	cb 01       	movw	r24, r22
    6bc8:	60 e2       	ldi	r22, 0x20	; 32
    6bca:	70 e0       	ldi	r23, 0x00	; 0
    6bcc:	0e 94 db 3b 	call	0x77b6	; 0x77b6 <strchr>
				if (!ptr2) break;
    6bd0:	00 97       	sbiw	r24, 0x00	; 0
    6bd2:	11 f4       	brne	.+4      	; 0x6bd8 <main+0x1678>
    6bd4:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				*ptr2++ = 0;
    6bd8:	dc 01       	movw	r26, r24
    6bda:	1d 92       	st	X+, r1
    6bdc:	8d 01       	movw	r16, r26
				while (*ptr2 == ' ') ptr2++;
    6bde:	fc 01       	movw	r30, r24
    6be0:	21 81       	ldd	r18, Z+1	; 0x01
    6be2:	20 32       	cpi	r18, 0x20	; 32
    6be4:	39 f4       	brne	.+14     	; 0x6bf4 <main+0x1694>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6be6:	02 96       	adiw	r24, 0x02	; 2
			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
    6be8:	fc 01       	movw	r30, r24
    6bea:	01 96       	adiw	r24, 0x01	; 1
    6bec:	20 81       	ld	r18, Z
    6bee:	20 32       	cpi	r18, 0x20	; 32
    6bf0:	d9 f3       	breq	.-10     	; 0x6be8 <main+0x1688>
    6bf2:	8f 01       	movw	r16, r30
				xprintf(PSTR("Opening \"%s\""), ptr);
    6bf4:	00 d0       	rcall	.+0      	; 0x6bf6 <main+0x1696>
    6bf6:	00 d0       	rcall	.+0      	; 0x6bf8 <main+0x1698>
    6bf8:	88 e2       	ldi	r24, 0x28	; 40
    6bfa:	94 e0       	ldi	r25, 0x04	; 4
    6bfc:	ad b7       	in	r26, 0x3d	; 61
    6bfe:	be b7       	in	r27, 0x3e	; 62
    6c00:	12 96       	adiw	r26, 0x02	; 2
    6c02:	9c 93       	st	X, r25
    6c04:	8e 93       	st	-X, r24
    6c06:	11 97       	sbiw	r26, 0x01	; 1
    6c08:	89 81       	ldd	r24, Y+1	; 0x01
    6c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    6c0c:	14 96       	adiw	r26, 0x04	; 4
    6c0e:	9c 93       	st	X, r25
    6c10:	8e 93       	st	-X, r24
    6c12:	13 97       	sbiw	r26, 0x03	; 3
    6c14:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				res = f_open(&File[0], ptr, FA_OPEN_EXISTING | FA_READ);
    6c18:	0f 90       	pop	r0
    6c1a:	0f 90       	pop	r0
    6c1c:	0f 90       	pop	r0
    6c1e:	0f 90       	pop	r0
    6c20:	69 81       	ldd	r22, Y+1	; 0x01
    6c22:	7a 81       	ldd	r23, Y+2	; 0x02
    6c24:	85 ed       	ldi	r24, 0xD5	; 213
    6c26:	94 e0       	ldi	r25, 0x04	; 4
    6c28:	41 e0       	ldi	r20, 0x01	; 1
    6c2a:	0e 94 23 1a 	call	0x3446	; 0x3446 <f_open>
				if (res) {
    6c2e:	88 23       	and	r24, r24
    6c30:	21 f0       	breq	.+8      	; 0x6c3a <main+0x16da>
					put_rc(res);
    6c32:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
					break;
    6c36:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				}
				xprintf(PSTR("\nCreating \"%s\""), ptr2);
    6c3a:	00 d0       	rcall	.+0      	; 0x6c3c <main+0x16dc>
    6c3c:	00 d0       	rcall	.+0      	; 0x6c3e <main+0x16de>
    6c3e:	85 e3       	ldi	r24, 0x35	; 53
    6c40:	94 e0       	ldi	r25, 0x04	; 4
    6c42:	ed b7       	in	r30, 0x3d	; 61
    6c44:	fe b7       	in	r31, 0x3e	; 62
    6c46:	92 83       	std	Z+2, r25	; 0x02
    6c48:	81 83       	std	Z+1, r24	; 0x01
    6c4a:	14 83       	std	Z+4, r17	; 0x04
    6c4c:	03 83       	std	Z+3, r16	; 0x03
    6c4e:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				res = f_open(&File[1], ptr2, FA_CREATE_ALWAYS | FA_WRITE);
    6c52:	0f 90       	pop	r0
    6c54:	0f 90       	pop	r0
    6c56:	0f 90       	pop	r0
    6c58:	0f 90       	pop	r0
    6c5a:	85 ef       	ldi	r24, 0xF5	; 245
    6c5c:	96 e0       	ldi	r25, 0x06	; 6
    6c5e:	b8 01       	movw	r22, r16
    6c60:	4a e0       	ldi	r20, 0x0A	; 10
    6c62:	0e 94 23 1a 	call	0x3446	; 0x3446 <f_open>
				if (res) {
    6c66:	88 23       	and	r24, r24
    6c68:	41 f0       	breq	.+16     	; 0x6c7a <main+0x171a>
					put_rc(res);
    6c6a:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
					f_close(&File[0]);
    6c6e:	85 ed       	ldi	r24, 0xD5	; 213
    6c70:	94 e0       	ldi	r25, 0x04	; 4
    6c72:	0e 94 32 20 	call	0x4064	; 0x4064 <f_close>
					break;
    6c76:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				}
				xprintf(PSTR("\nCopying..."));
    6c7a:	00 d0       	rcall	.+0      	; 0x6c7c <main+0x171c>
    6c7c:	84 e4       	ldi	r24, 0x44	; 68
    6c7e:	94 e0       	ldi	r25, 0x04	; 4
    6c80:	ad b7       	in	r26, 0x3d	; 61
    6c82:	be b7       	in	r27, 0x3e	; 62
    6c84:	12 96       	adiw	r26, 0x02	; 2
    6c86:	9c 93       	st	X, r25
    6c88:	8e 93       	st	-X, r24
    6c8a:	11 97       	sbiw	r26, 0x01	; 1
    6c8c:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				cli(); Timer = 0; sei();
    6c90:	f8 94       	cli
    6c92:	10 92 84 0d 	sts	0x0D84, r1
    6c96:	10 92 85 0d 	sts	0x0D85, r1
    6c9a:	10 92 86 0d 	sts	0x0D86, r1
    6c9e:	10 92 87 0d 	sts	0x0D87, r1
    6ca2:	78 94       	sei
				p1 = 0;
    6ca4:	1b 82       	std	Y+3, r1	; 0x03
    6ca6:	1c 82       	std	Y+4, r1	; 0x04
    6ca8:	1d 82       	std	Y+5, r1	; 0x05
    6caa:	1e 82       	std	Y+6, r1	; 0x06
    6cac:	0f 90       	pop	r0
    6cae:	0f 90       	pop	r0
				for (;;) {
					res = f_read(&File[0], Buff, sizeof Buff, &s1);
    6cb0:	0f 2e       	mov	r0, r31
    6cb2:	f5 ed       	ldi	r31, 0xD5	; 213
    6cb4:	cf 2e       	mov	r12, r31
    6cb6:	f4 e0       	ldi	r31, 0x04	; 4
    6cb8:	df 2e       	mov	r13, r31
    6cba:	f0 2d       	mov	r31, r0
    6cbc:	0f 2e       	mov	r0, r31
    6cbe:	fa e1       	ldi	r31, 0x1A	; 26
    6cc0:	ef 2e       	mov	r14, r31
    6cc2:	f9 e0       	ldi	r31, 0x09	; 9
    6cc4:	ff 2e       	mov	r15, r31
    6cc6:	f0 2d       	mov	r31, r0
					if (res || s1 == 0) break;   /* error or eof */
					res = f_write(&File[1], Buff, s1, &s2);
    6cc8:	0f 2e       	mov	r0, r31
    6cca:	f5 ef       	ldi	r31, 0xF5	; 245
    6ccc:	af 2e       	mov	r10, r31
    6cce:	f6 e0       	ldi	r31, 0x06	; 6
    6cd0:	bf 2e       	mov	r11, r31
    6cd2:	f0 2d       	mov	r31, r0
				}
				xprintf(PSTR("\nCopying..."));
				cli(); Timer = 0; sei();
				p1 = 0;
				for (;;) {
					res = f_read(&File[0], Buff, sizeof Buff, &s1);
    6cd4:	c6 01       	movw	r24, r12
    6cd6:	b7 01       	movw	r22, r14
    6cd8:	20 e0       	ldi	r18, 0x00	; 0
    6cda:	34 e0       	ldi	r19, 0x04	; 4
    6cdc:	40 e0       	ldi	r20, 0x00	; 0
    6cde:	50 e0       	ldi	r21, 0x00	; 0
    6ce0:	8e 01       	movw	r16, r28
    6ce2:	00 5f       	subi	r16, 0xF0	; 240
    6ce4:	1f 4f       	sbci	r17, 0xFF	; 255
    6ce6:	0e 94 4f 1b 	call	0x369e	; 0x369e <f_read>
    6cea:	28 2f       	mov	r18, r24
					if (res || s1 == 0) break;   /* error or eof */
    6cec:	88 23       	and	r24, r24
    6cee:	69 f5       	brne	.+90     	; 0x6d4a <main+0x17ea>
    6cf0:	28 89       	ldd	r18, Y+16	; 0x10
    6cf2:	39 89       	ldd	r19, Y+17	; 0x11
    6cf4:	4a 89       	ldd	r20, Y+18	; 0x12
    6cf6:	5b 89       	ldd	r21, Y+19	; 0x13
    6cf8:	21 15       	cp	r18, r1
    6cfa:	31 05       	cpc	r19, r1
    6cfc:	41 05       	cpc	r20, r1
    6cfe:	51 05       	cpc	r21, r1
    6d00:	39 f1       	breq	.+78     	; 0x6d50 <main+0x17f0>
					res = f_write(&File[1], Buff, s1, &s2);
    6d02:	c5 01       	movw	r24, r10
    6d04:	b7 01       	movw	r22, r14
    6d06:	8e 01       	movw	r16, r28
    6d08:	0c 5e       	subi	r16, 0xEC	; 236
    6d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    6d0c:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
    6d10:	28 2f       	mov	r18, r24
					p1 += s2;
    6d12:	4c 89       	ldd	r20, Y+20	; 0x14
    6d14:	5d 89       	ldd	r21, Y+21	; 0x15
    6d16:	6e 89       	ldd	r22, Y+22	; 0x16
    6d18:	7f 89       	ldd	r23, Y+23	; 0x17
    6d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    6d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    6d1e:	ad 81       	ldd	r26, Y+5	; 0x05
    6d20:	be 81       	ldd	r27, Y+6	; 0x06
    6d22:	84 0f       	add	r24, r20
    6d24:	95 1f       	adc	r25, r21
    6d26:	a6 1f       	adc	r26, r22
    6d28:	b7 1f       	adc	r27, r23
    6d2a:	8b 83       	std	Y+3, r24	; 0x03
    6d2c:	9c 83       	std	Y+4, r25	; 0x04
    6d2e:	ad 83       	std	Y+5, r26	; 0x05
    6d30:	be 83       	std	Y+6, r27	; 0x06
					if (res || s2 < s1) break;   /* error or disk full */
    6d32:	22 23       	and	r18, r18
    6d34:	51 f4       	brne	.+20     	; 0x6d4a <main+0x17ea>
    6d36:	88 89       	ldd	r24, Y+16	; 0x10
    6d38:	99 89       	ldd	r25, Y+17	; 0x11
    6d3a:	aa 89       	ldd	r26, Y+18	; 0x12
    6d3c:	bb 89       	ldd	r27, Y+19	; 0x13
    6d3e:	48 17       	cp	r20, r24
    6d40:	59 07       	cpc	r21, r25
    6d42:	6a 07       	cpc	r22, r26
    6d44:	7b 07       	cpc	r23, r27
    6d46:	30 f6       	brcc	.-116    	; 0x6cd4 <main+0x1774>
    6d48:	03 c0       	rjmp	.+6      	; 0x6d50 <main+0x17f0>
				}
				if (res) put_rc(res);
    6d4a:	82 2f       	mov	r24, r18
    6d4c:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				cli(); s2 = Timer; sei();
    6d50:	f8 94       	cli
    6d52:	80 91 84 0d 	lds	r24, 0x0D84
    6d56:	90 91 85 0d 	lds	r25, 0x0D85
    6d5a:	a0 91 86 0d 	lds	r26, 0x0D86
    6d5e:	b0 91 87 0d 	lds	r27, 0x0D87
    6d62:	8c 8b       	std	Y+20, r24	; 0x14
    6d64:	9d 8b       	std	Y+21, r25	; 0x15
    6d66:	ae 8b       	std	Y+22, r26	; 0x16
    6d68:	bf 8b       	std	Y+23, r27	; 0x17
    6d6a:	78 94       	sei
				xprintf(PSTR("\n%lu bytes copied with %lu bytes/sec.\n"), p1, p1 * 100 / s2);
    6d6c:	6b 81       	ldd	r22, Y+3	; 0x03
    6d6e:	7c 81       	ldd	r23, Y+4	; 0x04
    6d70:	8d 81       	ldd	r24, Y+5	; 0x05
    6d72:	9e 81       	ldd	r25, Y+6	; 0x06
    6d74:	ed b7       	in	r30, 0x3d	; 61
    6d76:	fe b7       	in	r31, 0x3e	; 62
    6d78:	3a 97       	sbiw	r30, 0x0a	; 10
    6d7a:	0f b6       	in	r0, 0x3f	; 63
    6d7c:	f8 94       	cli
    6d7e:	fe bf       	out	0x3e, r31	; 62
    6d80:	0f be       	out	0x3f, r0	; 63
    6d82:	ed bf       	out	0x3d, r30	; 61
    6d84:	0d b7       	in	r16, 0x3d	; 61
    6d86:	1e b7       	in	r17, 0x3e	; 62
    6d88:	0f 5f       	subi	r16, 0xFF	; 255
    6d8a:	1f 4f       	sbci	r17, 0xFF	; 255
    6d8c:	20 e5       	ldi	r18, 0x50	; 80
    6d8e:	34 e0       	ldi	r19, 0x04	; 4
    6d90:	32 83       	std	Z+2, r19	; 0x02
    6d92:	21 83       	std	Z+1, r18	; 0x01
    6d94:	d8 01       	movw	r26, r16
    6d96:	12 96       	adiw	r26, 0x02	; 2
    6d98:	6d 93       	st	X+, r22
    6d9a:	7d 93       	st	X+, r23
    6d9c:	8d 93       	st	X+, r24
    6d9e:	9c 93       	st	X, r25
    6da0:	15 97       	sbiw	r26, 0x05	; 5
    6da2:	24 e6       	ldi	r18, 0x64	; 100
    6da4:	30 e0       	ldi	r19, 0x00	; 0
    6da6:	40 e0       	ldi	r20, 0x00	; 0
    6da8:	50 e0       	ldi	r21, 0x00	; 0
    6daa:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__mulsi3>
    6dae:	2c 89       	ldd	r18, Y+20	; 0x14
    6db0:	3d 89       	ldd	r19, Y+21	; 0x15
    6db2:	4e 89       	ldd	r20, Y+22	; 0x16
    6db4:	5f 89       	ldd	r21, Y+23	; 0x17
    6db6:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodsi4>
    6dba:	f8 01       	movw	r30, r16
    6dbc:	26 83       	std	Z+6, r18	; 0x06
    6dbe:	37 83       	std	Z+7, r19	; 0x07
    6dc0:	40 87       	std	Z+8, r20	; 0x08
    6dc2:	51 87       	std	Z+9, r21	; 0x09
    6dc4:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				f_close(&File[0]);
    6dc8:	2d b7       	in	r18, 0x3d	; 61
    6dca:	3e b7       	in	r19, 0x3e	; 62
    6dcc:	26 5f       	subi	r18, 0xF6	; 246
    6dce:	3f 4f       	sbci	r19, 0xFF	; 255
    6dd0:	0f b6       	in	r0, 0x3f	; 63
    6dd2:	f8 94       	cli
    6dd4:	3e bf       	out	0x3e, r19	; 62
    6dd6:	0f be       	out	0x3f, r0	; 63
    6dd8:	2d bf       	out	0x3d, r18	; 61
    6dda:	85 ed       	ldi	r24, 0xD5	; 213
    6ddc:	94 e0       	ldi	r25, 0x04	; 4
    6dde:	0e 94 32 20 	call	0x4064	; 0x4064 <f_close>
				f_close(&File[1]);
    6de2:	85 ef       	ldi	r24, 0xF5	; 245
    6de4:	96 e0       	ldi	r25, 0x06	; 6
    6de6:	0e 94 32 20 	call	0x4064	; 0x4064 <f_close>
				break;
    6dea:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
    6dee:	f9 01       	movw	r30, r18
    6df0:	33 96       	adiw	r30, 0x03	; 3
				f_close(&File[0]);
				f_close(&File[1]);
				break;
#if _FS_RPATH
			case 'g' :	/* fg <path> - Change current directory */
				while (*ptr == ' ') ptr++;
    6df2:	6f 5f       	subi	r22, 0xFF	; 255
    6df4:	7f 4f       	sbci	r23, 0xFF	; 255
    6df6:	7a 83       	std	Y+2, r23	; 0x02
    6df8:	69 83       	std	Y+1, r22	; 0x01
    6dfa:	81 91       	ld	r24, Z+
    6dfc:	80 32       	cpi	r24, 0x20	; 32
    6dfe:	c9 f3       	breq	.-14     	; 0x6df2 <main+0x1892>
				put_rc(f_chdir(ptr));
    6e00:	cb 01       	movw	r24, r22
    6e02:	0e 94 45 20 	call	0x408a	; 0x408a <f_chdir>
    6e06:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
				break;
    6e0a:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

			case 'j' :	/* fj <drive#> - Change current drive */
				if (xatoi(&ptr, &p1)) {
    6e0e:	ce 01       	movw	r24, r28
    6e10:	01 96       	adiw	r24, 0x01	; 1
    6e12:	be 01       	movw	r22, r28
    6e14:	6d 5f       	subi	r22, 0xFD	; 253
    6e16:	7f 4f       	sbci	r23, 0xFF	; 255
    6e18:	0e 94 1d 3b 	call	0x763a	; 0x763a <xatoi>
    6e1c:	88 23       	and	r24, r24
    6e1e:	11 f4       	brne	.+4      	; 0x6e24 <main+0x18c4>
    6e20:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
					put_rc(f_chdrive((BYTE)p1));
    6e24:	8b 81       	ldd	r24, Y+3	; 0x03
    6e26:	0e 94 3e 20 	call	0x407c	; 0x407c <f_chdrive>
    6e2a:	0e 94 2d 29 	call	0x525a	; 0x525a <put_rc>
    6e2e:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
			break;
			//End of FatFS Commands
			
			//Other Commands
			case 'p'://Write BMP File
				WriteBMPHeader();
    6e32:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <WriteBMPHeader>
				WriteDIBHeader();
    6e36:	0e 94 06 05 	call	0xa0c	; 0xa0c <WriteDIBHeader>
				LoadImageToBuffer();
    6e3a:	0e 94 ed 37 	call	0x6fda	; 0x6fda <LoadImageToBuffer>
				while(1 != GetImageIfAvailiable(BMPHEADERSIZE + DIBHEADERSIZE));
    6e3e:	8a e8       	ldi	r24, 0x8A	; 138
    6e40:	90 e0       	ldi	r25, 0x00	; 0
    6e42:	0e 94 35 38 	call	0x706a	; 0x706a <GetImageIfAvailiable>
    6e46:	81 30       	cpi	r24, 0x01	; 1
    6e48:	d1 f7       	brne	.-12     	; 0x6e3e <main+0x18de>
    6e4a:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>
				break;
// 			case 'P':
// 				StoreToEEPROM();
// 				break;
		case '?' :	/* Show Command List */
			xputs(PSTR(
    6e4e:	87 e7       	ldi	r24, 0x77	; 119
    6e50:	94 e0       	ldi	r25, 0x04	; 4
    6e52:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <xputs>
				" fm <ld#> <rule> <cluster size> - Create file system\n"
				"[Misc commands]\n"
				" p - Store a Bitmap Photo to open File\n"
				"\n")
			);
			break;
    6e56:	0c 94 64 2b 	jmp	0x56c8	; 0x56c8 <main+0x168>

00006e5a <__vector_1>:
	
};
#endif
//ISR for controlling WEN.
ISR(INT0_vect)
{
    6e5a:	1f 92       	push	r1
    6e5c:	0f 92       	push	r0
    6e5e:	0f b6       	in	r0, 0x3f	; 63
    6e60:	0f 92       	push	r0
    6e62:	11 24       	eor	r1, r1
    6e64:	8f 93       	push	r24
    6e66:	9f 93       	push	r25
	//xprintf(PSTR("ISR Entered"));
	if (VSYNC_Count==1)//start a frame read
    6e68:	80 91 1a 0d 	lds	r24, 0x0D1A
    6e6c:	90 91 1b 0d 	lds	r25, 0x0D1B
    6e70:	81 30       	cpi	r24, 0x01	; 1
    6e72:	91 05       	cpc	r25, r1
    6e74:	59 f4       	brne	.+22     	; 0x6e8c <__vector_1+0x32>
	{
		/*xprintf(PSTR("WEN Set\n"));*/
		FIFO_WEN_SET;
    6e76:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_Count++;
    6e78:	80 91 1a 0d 	lds	r24, 0x0D1A
    6e7c:	90 91 1b 0d 	lds	r25, 0x0D1B
    6e80:	01 96       	adiw	r24, 0x01	; 1
    6e82:	90 93 1b 0d 	sts	0x0D1B, r25
    6e86:	80 93 1a 0d 	sts	0x0D1A, r24
    6e8a:	0d c0       	rjmp	.+26     	; 0x6ea6 <__vector_1+0x4c>
	}
	else if (VSYNC_Count==2)//end a frame read
    6e8c:	80 91 1a 0d 	lds	r24, 0x0D1A
    6e90:	90 91 1b 0d 	lds	r25, 0x0D1B
    6e94:	82 30       	cpi	r24, 0x02	; 2
    6e96:	91 05       	cpc	r25, r1
    6e98:	11 f4       	brne	.+4      	; 0x6e9e <__vector_1+0x44>
	{
		FIFO_WEN_CLR;
    6e9a:	5e 98       	cbi	0x0b, 6	; 11
    6e9c:	04 c0       	rjmp	.+8      	; 0x6ea6 <__vector_1+0x4c>
		/*xprintf(PSTR("WEN Clear\n"));*/
	}
	else
	{
		VSYNC_Count = 0;//wait for a read to be started
    6e9e:	10 92 1b 0d 	sts	0x0D1B, r1
    6ea2:	10 92 1a 0d 	sts	0x0D1A, r1
	}
}
    6ea6:	9f 91       	pop	r25
    6ea8:	8f 91       	pop	r24
    6eaa:	0f 90       	pop	r0
    6eac:	0f be       	out	0x3f, r0	; 63
    6eae:	0f 90       	pop	r0
    6eb0:	1f 90       	pop	r1
    6eb2:	18 95       	reti

00006eb4 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
    6eb4:	cf 93       	push	r28
    6eb6:	df 93       	push	r29
    6eb8:	00 d0       	rcall	.+0      	; 0x6eba <wrOV7670Reg+0x6>
    6eba:	00 d0       	rcall	.+0      	; 0x6ebc <wrOV7670Reg+0x8>
    6ebc:	cd b7       	in	r28, 0x3d	; 61
    6ebe:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    6ec0:	92 e4       	ldi	r25, 0x42	; 66
    6ec2:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
    6ec4:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
    6ec6:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
    6ec8:	ce 01       	movw	r24, r28
    6eca:	01 96       	adiw	r24, 0x01	; 1
    6ecc:	63 e0       	ldi	r22, 0x03	; 3
    6ece:	0e 94 2b 39 	call	0x7256	; 0x7256 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    6ed2:	0e 94 20 39 	call	0x7240	; 0x7240 <TWI_Transceiver_Busy>
    6ed6:	88 23       	and	r24, r24
    6ed8:	e1 f7       	brne	.-8      	; 0x6ed2 <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
    6eda:	80 91 84 02 	lds	r24, 0x0284
}
    6ede:	81 70       	andi	r24, 0x01	; 1
    6ee0:	0f 90       	pop	r0
    6ee2:	0f 90       	pop	r0
    6ee4:	0f 90       	pop	r0
    6ee6:	0f 90       	pop	r0
    6ee8:	df 91       	pop	r29
    6eea:	cf 91       	pop	r28
    6eec:	08 95       	ret

00006eee <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
    6eee:	0f 93       	push	r16
    6ef0:	1f 93       	push	r17
    6ef2:	cf 93       	push	r28
    6ef4:	df 93       	push	r29
    6ef6:	00 d0       	rcall	.+0      	; 0x6ef8 <rdOV7670Reg+0xa>
    6ef8:	00 d0       	rcall	.+0      	; 0x6efa <rdOV7670Reg+0xc>
    6efa:	cd b7       	in	r28, 0x3d	; 61
    6efc:	de b7       	in	r29, 0x3e	; 62
    6efe:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    6f00:	92 e4       	ldi	r25, 0x42	; 66
    6f02:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
    6f04:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    6f06:	ce 01       	movw	r24, r28
    6f08:	01 96       	adiw	r24, 0x01	; 1
    6f0a:	62 e0       	ldi	r22, 0x02	; 2
    6f0c:	0e 94 2b 39 	call	0x7256	; 0x7256 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    6f10:	83 e4       	ldi	r24, 0x43	; 67
    6f12:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
    6f14:	ce 01       	movw	r24, r28
    6f16:	01 96       	adiw	r24, 0x01	; 1
    6f18:	62 e0       	ldi	r22, 0x02	; 2
    6f1a:	0e 94 2b 39 	call	0x7256	; 0x7256 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    6f1e:	ce 01       	movw	r24, r28
    6f20:	01 96       	adiw	r24, 0x01	; 1
    6f22:	62 e0       	ldi	r22, 0x02	; 2
    6f24:	0e 94 61 39 	call	0x72c2	; 0x72c2 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
    6f28:	8a 81       	ldd	r24, Y+2	; 0x02
    6f2a:	f8 01       	movw	r30, r16
    6f2c:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
    6f2e:	80 91 84 02 	lds	r24, 0x0284
}
    6f32:	81 70       	andi	r24, 0x01	; 1
    6f34:	0f 90       	pop	r0
    6f36:	0f 90       	pop	r0
    6f38:	0f 90       	pop	r0
    6f3a:	0f 90       	pop	r0
    6f3c:	df 91       	pop	r29
    6f3e:	cf 91       	pop	r28
    6f40:	1f 91       	pop	r17
    6f42:	0f 91       	pop	r16
    6f44:	08 95       	ret

00006f46 <OV7670_init>:

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
{
    6f46:	0f 93       	push	r16
    6f48:	1f 93       	push	r17
    6f4a:	cf 93       	push	r28
    6f4c:	df 93       	push	r29
	
	VSYNC_Count = 0;
    6f4e:	10 92 1b 0d 	sts	0x0D1B, r1
    6f52:	10 92 1a 0d 	sts	0x0D1A, r1
	unsigned char temp;
	
	unsigned int i=0;
	
	// initial the int0 interrupt for WEN
	DDRD &= ~(1<<OV7670_VSYNC);		//set OV7670_SYNC as input for INT0
    6f56:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<OV7670_VSYNC);		//Enable OV7670_SYNC pull-up resistor
    6f58:	5a 9a       	sbi	0x0b, 2	; 11
	
	EIMSK = 1<<INT0;				//Enable INT0
    6f5a:	81 e0       	ldi	r24, 0x01	; 1
    6f5c:	8d bb       	out	0x1d, r24	; 29
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
    6f5e:	82 e0       	ldi	r24, 0x02	; 2
    6f60:	80 93 69 00 	sts	0x0069, r24
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
    6f64:	82 e1       	ldi	r24, 0x12	; 18
    6f66:	60 e8       	ldi	r22, 0x80	; 128
    6f68:	0e 94 5a 37 	call	0x6eb4	; 0x6eb4 <wrOV7670Reg>
    6f6c:	88 23       	and	r24, r24
    6f6e:	31 f1       	breq	.+76     	; 0x6fbc <OV7670_init+0x76>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    6f70:	8f e2       	ldi	r24, 0x2F	; 47
    6f72:	95 e7       	ldi	r25, 0x75	; 117
    6f74:	01 97       	sbiw	r24, 0x01	; 1
    6f76:	f1 f7       	brne	.-4      	; 0x6f74 <OV7670_init+0x2e>
    6f78:	00 c0       	rjmp	.+0      	; 0x6f7a <OV7670_init+0x34>
    6f7a:	00 00       	nop
			return 0;
		}
		_delay_ms(1);
	}
#elif SETTINGS == EEPROM
	eeprom_read_block(&Buff, Settings_Addr_EEPROM, (SETTINGS_LENGTH * 2));//load default settings into buffer from eeprom
    6f7c:	ca e1       	ldi	r28, 0x1A	; 26
    6f7e:	d9 e0       	ldi	r29, 0x09	; 9
    6f80:	ce 01       	movw	r24, r28
    6f82:	6a e0       	ldi	r22, 0x0A	; 10
    6f84:	70 e0       	ldi	r23, 0x00	; 0
    6f86:	4e e4       	ldi	r20, 0x4E	; 78
    6f88:	51 e0       	ldi	r21, 0x01	; 1
    6f8a:	0e 94 ed 3b 	call	0x77da	; 0x77da <__eerd_block_m644p>
    6f8e:	21 96       	adiw	r28, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
    6f90:	09 e6       	ldi	r16, 0x69	; 105
    6f92:	1a e0       	ldi	r17, 0x0A	; 10
    6f94:	fe 01       	movw	r30, r28
    6f96:	31 97       	sbiw	r30, 0x01	; 1
	}
#elif SETTINGS == EEPROM
	eeprom_read_block(&Buff, Settings_Addr_EEPROM, (SETTINGS_LENGTH * 2));//load default settings into buffer from eeprom
	for(i = 0; i < SETTINGS_LENGTH * 2; /*Intentionally left blank*/)
	{
		if( 0==wrOV7670Reg(Buff[i++], Buff[i++]))
    6f98:	80 81       	ld	r24, Z
    6f9a:	68 81       	ld	r22, Y
    6f9c:	0e 94 5a 37 	call	0x6eb4	; 0x6eb4 <wrOV7670Reg>
    6fa0:	88 23       	and	r24, r24
    6fa2:	71 f0       	breq	.+28     	; 0x6fc0 <OV7670_init+0x7a>
    6fa4:	87 eb       	ldi	r24, 0xB7	; 183
    6fa6:	9b e0       	ldi	r25, 0x0B	; 11
    6fa8:	01 97       	sbiw	r24, 0x01	; 1
    6faa:	f1 f7       	brne	.-4      	; 0x6fa8 <OV7670_init+0x62>
    6fac:	00 c0       	rjmp	.+0      	; 0x6fae <OV7670_init+0x68>
    6fae:	00 00       	nop
    6fb0:	22 96       	adiw	r28, 0x02	; 2
		}
		_delay_ms(1);
	}
#elif SETTINGS == EEPROM
	eeprom_read_block(&Buff, Settings_Addr_EEPROM, (SETTINGS_LENGTH * 2));//load default settings into buffer from eeprom
	for(i = 0; i < SETTINGS_LENGTH * 2; /*Intentionally left blank*/)
    6fb2:	c0 17       	cp	r28, r16
    6fb4:	d1 07       	cpc	r29, r17
    6fb6:	71 f7       	brne	.-36     	; 0x6f94 <OV7670_init+0x4e>
			return 0;
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
    6fb8:	81 e0       	ldi	r24, 0x01	; 1
    6fba:	03 c0       	rjmp	.+6      	; 0x6fc2 <OV7670_init+0x7c>
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
	{
		return 0;
    6fbc:	80 e0       	ldi	r24, 0x00	; 0
    6fbe:	01 c0       	rjmp	.+2      	; 0x6fc2 <OV7670_init+0x7c>
	eeprom_read_block(&Buff, Settings_Addr_EEPROM, (SETTINGS_LENGTH * 2));//load default settings into buffer from eeprom
	for(i = 0; i < SETTINGS_LENGTH * 2; /*Intentionally left blank*/)
	{
		if( 0==wrOV7670Reg(Buff[i++], Buff[i++]))
		{
			return 0;
    6fc0:	80 e0       	ldi	r24, 0x00	; 0
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
}
    6fc2:	df 91       	pop	r29
    6fc4:	cf 91       	pop	r28
    6fc6:	1f 91       	pop	r17
    6fc8:	0f 91       	pop	r16
    6fca:	08 95       	ret

00006fcc <FIFO_Reset>:

//Resets both pointers
void FIFO_Reset() 
{
	FIFO_WRST_CLR;
    6fcc:	5b 98       	cbi	0x0b, 3	; 11
	FIFO_nRRST_CLR;
    6fce:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_SET;
    6fd0:	5c 9a       	sbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;
    6fd2:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
    6fd4:	5f 9a       	sbi	0x0b, 7	; 11
	FIFO_WRST_SET;
    6fd6:	5b 9a       	sbi	0x0b, 3	; 11
}
    6fd8:	08 95       	ret

00006fda <LoadImageToBuffer>:
}


void LoadImageToBuffer( void )
{
	while(VSYNC_Count != 0); //wait for any frame to be written to complete
    6fda:	80 91 1a 0d 	lds	r24, 0x0D1A
    6fde:	90 91 1b 0d 	lds	r25, 0x0D1B
    6fe2:	00 97       	sbiw	r24, 0x00	; 0
    6fe4:	d1 f7       	brne	.-12     	; 0x6fda <LoadImageToBuffer>
	FIFO_WRST_CLR;//Reset the write pointer
    6fe6:	5b 98       	cbi	0x0b, 3	; 11
    6fe8:	87 eb       	ldi	r24, 0xB7	; 183
    6fea:	9b e0       	ldi	r25, 0x0B	; 11
    6fec:	01 97       	sbiw	r24, 0x01	; 1
    6fee:	f1 f7       	brne	.-4      	; 0x6fec <LoadImageToBuffer+0x12>
    6ff0:	00 c0       	rjmp	.+0      	; 0x6ff2 <LoadImageToBuffer+0x18>
    6ff2:	00 00       	nop
	_delay_ms(1);//wait a few clock cycles of the internal oscillator
	FIFO_WRST_SET;
    6ff4:	5b 9a       	sbi	0x0b, 3	; 11
    6ff6:	87 eb       	ldi	r24, 0xB7	; 183
    6ff8:	9b e0       	ldi	r25, 0x0B	; 11
    6ffa:	01 97       	sbiw	r24, 0x01	; 1
    6ffc:	f1 f7       	brne	.-4      	; 0x6ffa <LoadImageToBuffer+0x20>
    6ffe:	00 c0       	rjmp	.+0      	; 0x7000 <LoadImageToBuffer+0x26>
    7000:	00 00       	nop
	_delay_ms(1);
	VSYNC_Count = 1;
    7002:	81 e0       	ldi	r24, 0x01	; 1
    7004:	90 e0       	ldi	r25, 0x00	; 0
    7006:	90 93 1b 0d 	sts	0x0D1B, r25
    700a:	80 93 1a 0d 	sts	0x0D1A, r24
}
    700e:	08 95       	ret

00007010 <FIFO_init>:

//Initial FIFO
unsigned char FIFO_init(void)
{
	
	DDRD |=(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK)|(1 << FIFO_WRST) | (1 << FIFO_nOE);
    7010:	8a b1       	in	r24, 0x0a	; 10
    7012:	88 6f       	ori	r24, 0xF8	; 248
    7014:	8a b9       	out	0x0a, r24	; 10
	FIFO_WRST_CLR;
    7016:	5b 98       	cbi	0x0b, 3	; 11
	
	FIFO_RCLK_CLR;
    7018:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nOE_CLR;
    701a:	5d 98       	cbi	0x0b, 5	; 11
	FIFO_nRRST_SET;
    701c:	5f 9a       	sbi	0x0b, 7	; 11
	FIFO_WEN_CLR;
    701e:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7020:	88 e2       	ldi	r24, 0x28	; 40
    7022:	8a 95       	dec	r24
    7024:	f1 f7       	brne	.-4      	; 0x7022 <FIFO_init+0x12>
	_delay_us(10);
	FIFO_RCLK_SET;
    7026:	5c 9a       	sbi	0x0b, 4	; 11
    7028:	88 e2       	ldi	r24, 0x28	; 40
    702a:	8a 95       	dec	r24
    702c:	f1 f7       	brne	.-4      	; 0x702a <FIFO_init+0x1a>
	_delay_us(10);
	FIFO_RCLK_CLR;
    702e:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_CLR;
    7030:	5f 98       	cbi	0x0b, 7	; 11
    7032:	88 e2       	ldi	r24, 0x28	; 40
    7034:	8a 95       	dec	r24
    7036:	f1 f7       	brne	.-4      	; 0x7034 <FIFO_init+0x24>
	_delay_us(10);
	FIFO_RCLK_SET;
    7038:	5c 9a       	sbi	0x0b, 4	; 11
    703a:	88 e2       	ldi	r24, 0x28	; 40
    703c:	8a 95       	dec	r24
    703e:	f1 f7       	brne	.-4      	; 0x703c <FIFO_init+0x2c>
	_delay_us(10);
	FIFO_RCLK_CLR;
    7040:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
    7042:	5f 9a       	sbi	0x0b, 7	; 11
    7044:	88 e2       	ldi	r24, 0x28	; 40
    7046:	8a 95       	dec	r24
    7048:	f1 f7       	brne	.-4      	; 0x7046 <FIFO_init+0x36>
	_delay_us(10);
	FIFO_WRST_SET;
    704a:	5b 9a       	sbi	0x0b, 3	; 11
	return 0x01; //okay
}
    704c:	81 e0       	ldi	r24, 0x01	; 1
    704e:	08 95       	ret

00007050 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(void)
{
	uint16_t data = 0;
	
	FIFO_AVR_DPRT=0;
    7050:	11 b8       	out	0x01, r1	; 1
	
	FIFO_RCLK_SET;
    7052:	5c 9a       	sbi	0x0b, 4	; 11
	data = FIFO_AVR_PINP;
    7054:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    7056:	5c 98       	cbi	0x0b, 4	; 11

	data <<= 8;
    7058:	38 2f       	mov	r19, r24
    705a:	20 e0       	ldi	r18, 0x00	; 0
	
	FIFO_RCLK_SET;
    705c:	5c 9a       	sbi	0x0b, 4	; 11
	data |= FIFO_AVR_PINP;
    705e:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    7060:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;

	data <<= 8;
	
	FIFO_RCLK_SET;
	data |= FIFO_AVR_PINP;
    7062:	90 e0       	ldi	r25, 0x00	; 0
    7064:	82 2b       	or	r24, r18
    7066:	93 2b       	or	r25, r19
	//	FIFO_RCLK_CLR;
	//	FIFO_RCLK_SET;
	//	FIFO_RCLK_CLR;
	
	return(data);
}
    7068:	08 95       	ret

0000706a <GetImageIfAvailiable>:
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    706a:	2f 92       	push	r2
    706c:	3f 92       	push	r3
    706e:	4f 92       	push	r4
    7070:	5f 92       	push	r5
    7072:	6f 92       	push	r6
    7074:	7f 92       	push	r7
    7076:	8f 92       	push	r8
    7078:	9f 92       	push	r9
    707a:	af 92       	push	r10
    707c:	bf 92       	push	r11
    707e:	cf 92       	push	r12
    7080:	df 92       	push	r13
    7082:	ef 92       	push	r14
    7084:	ff 92       	push	r15
    7086:	0f 93       	push	r16
    7088:	1f 93       	push	r17
    708a:	cf 93       	push	r28
    708c:	df 93       	push	r29
    708e:	00 d0       	rcall	.+0      	; 0x7090 <GetImageIfAvailiable+0x26>
    7090:	00 d0       	rcall	.+0      	; 0x7092 <GetImageIfAvailiable+0x28>
    7092:	cd b7       	in	r28, 0x3d	; 61
    7094:	de b7       	in	r29, 0x3e	; 62
	if (VSYNC_Count == 2)//if one full frame has elapsed.
    7096:	20 91 1a 0d 	lds	r18, 0x0D1A
    709a:	30 91 1b 0d 	lds	r19, 0x0D1B
    709e:	22 30       	cpi	r18, 0x02	; 2
    70a0:	31 05       	cpc	r19, r1
    70a2:	09 f0       	breq	.+2      	; 0x70a6 <GetImageIfAvailiable+0x3c>
    70a4:	ab c0       	rjmp	.+342    	; 0x71fc <GetImageIfAvailiable+0x192>
		uint32_t p;
		unsigned long int pointer;
		FRESULT fr;
		int i,j, ptr;
		uint16_t Temp;
		FIFO_nRRST_CLR; //Reset Read Pointer
    70a6:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_RCLK_SET;
    70a8:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
    70aa:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
    70ac:	5f 9a       	sbi	0x0b, 7	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    70ae:	a7 eb       	ldi	r26, 0xB7	; 183
    70b0:	bb e0       	ldi	r27, 0x0B	; 11
    70b2:	11 97       	sbiw	r26, 0x01	; 1
    70b4:	f1 f7       	brne	.-4      	; 0x70b2 <GetImageIfAvailiable+0x48>
    70b6:	00 c0       	rjmp	.+0      	; 0x70b8 <GetImageIfAvailiable+0x4e>
    70b8:	00 00       	nop
	FIFO_nRRST_SET;
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
    70ba:	2c 01       	movw	r4, r24
    70bc:	66 24       	eor	r6, r6
    70be:	57 fc       	sbrc	r5, 7
    70c0:	60 94       	com	r6
    70c2:	76 2c       	mov	r7, r6
    70c4:	0f 2e       	mov	r0, r31
    70c6:	f0 e0       	ldi	r31, 0x00	; 0
    70c8:	8f 2e       	mov	r8, r31
    70ca:	f8 e5       	ldi	r31, 0x58	; 88
    70cc:	9f 2e       	mov	r9, r31
    70ce:	f2 e0       	ldi	r31, 0x02	; 2
    70d0:	af 2e       	mov	r10, r31
    70d2:	f0 e0       	ldi	r31, 0x00	; 0
    70d4:	bf 2e       	mov	r11, r31
    70d6:	f0 2d       	mov	r31, r0
    70d8:	84 0c       	add	r8, r4
    70da:	95 1c       	adc	r9, r5
    70dc:	a6 1c       	adc	r10, r6
    70de:	b7 1c       	adc	r11, r7
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
    70e0:	0f 2e       	mov	r0, r31
    70e2:	fb e1       	ldi	r31, 0x1B	; 27
    70e4:	2f 2e       	mov	r2, r31
    70e6:	f9 e0       	ldi	r31, 0x09	; 9
    70e8:	3f 2e       	mov	r3, r31
    70ea:	f0 2d       	mov	r31, r0
	FIFO_nRRST_SET;
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
    70ec:	0f 2e       	mov	r0, r31
    70ee:	fb e9       	ldi	r31, 0x9B	; 155
    70f0:	ef 2e       	mov	r14, r31
    70f2:	fb e0       	ldi	r31, 0x0B	; 11
    70f4:	ff 2e       	mov	r15, r31
    70f6:	f0 2d       	mov	r31, r0
			}
			//i = (WIDTH % 4) + WIDTH * 2;//include some padding of any value if necessary NOT TESTED!
			
			pointer = (uint32_t)j * (uint32_t)WIDTH * (uint32_t)2 + offset;
			
			f_lseek(&File[0], pointer);
    70f8:	0f 2e       	mov	r0, r31
    70fa:	f5 ed       	ldi	r31, 0xD5	; 213
    70fc:	cf 2e       	mov	r12, r31
    70fe:	f4 e0       	ldi	r31, 0x04	; 4
    7100:	df 2e       	mov	r13, r31
    7102:	f0 2d       	mov	r31, r0
    7104:	49 c0       	rjmp	.+146    	; 0x7198 <GetImageIfAvailiable+0x12e>
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
    7106:	0e 94 28 38 	call	0x7050	; 0x7050 <FIFO_TO_AVR>
	FIFO_nRRST_SET;
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
    710a:	f8 01       	movw	r30, r16
    710c:	31 97       	sbiw	r30, 0x01	; 1
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
 				
 				Buff[ptr++] = (uint8_t)Temp >> 8;
    710e:	10 82       	st	Z, r1
				Buff[ptr++] = (uint8_t)Temp;
    7110:	f8 01       	movw	r30, r16
    7112:	80 83       	st	Z, r24
    7114:	0e 5f       	subi	r16, 0xFE	; 254
    7116:	1f 4f       	sbci	r17, 0xFF	; 255
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
    7118:	0e 15       	cp	r16, r14
    711a:	1f 05       	cpc	r17, r15
    711c:	a1 f7       	brne	.-24     	; 0x7106 <GetImageIfAvailiable+0x9c>
			}
			//i = (WIDTH % 4) + WIDTH * 2;//include some padding of any value if necessary NOT TESTED!
			
			pointer = (uint32_t)j * (uint32_t)WIDTH * (uint32_t)2 + offset;
			
			f_lseek(&File[0], pointer);
    711e:	c6 01       	movw	r24, r12
    7120:	b5 01       	movw	r22, r10
    7122:	a4 01       	movw	r20, r8
    7124:	0e 94 9e 20 	call	0x413c	; 0x413c <f_lseek>
			fr = f_write(&File[0], Buff, WIDTH * 2, &p);
    7128:	c6 01       	movw	r24, r12
    712a:	6a e1       	ldi	r22, 0x1A	; 26
    712c:	79 e0       	ldi	r23, 0x09	; 9
    712e:	20 e8       	ldi	r18, 0x80	; 128
    7130:	32 e0       	ldi	r19, 0x02	; 2
    7132:	40 e0       	ldi	r20, 0x00	; 0
    7134:	50 e0       	ldi	r21, 0x00	; 0
    7136:	8e 01       	movw	r16, r28
    7138:	0f 5f       	subi	r16, 0xFF	; 255
    713a:	1f 4f       	sbci	r17, 0xFF	; 255
    713c:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_write>
			if (fr != FR_OK)
    7140:	88 23       	and	r24, r24
    7142:	e9 f0       	breq	.+58     	; 0x717e <GetImageIfAvailiable+0x114>
			{
				xprintf(PSTR("File Write Fail : %d"), fr);
    7144:	00 d0       	rcall	.+0      	; 0x7146 <GetImageIfAvailiable+0xdc>
    7146:	00 d0       	rcall	.+0      	; 0x7148 <GetImageIfAvailiable+0xde>
    7148:	ed b7       	in	r30, 0x3d	; 61
    714a:	fe b7       	in	r31, 0x3e	; 62
    714c:	31 96       	adiw	r30, 0x01	; 1
    714e:	22 e5       	ldi	r18, 0x52	; 82
    7150:	39 e0       	ldi	r19, 0x09	; 9
    7152:	ad b7       	in	r26, 0x3d	; 61
    7154:	be b7       	in	r27, 0x3e	; 62
    7156:	12 96       	adiw	r26, 0x02	; 2
    7158:	3c 93       	st	X, r19
    715a:	2e 93       	st	-X, r18
    715c:	11 97       	sbiw	r26, 0x01	; 1
    715e:	82 83       	std	Z+2, r24	; 0x02
    7160:	13 82       	std	Z+3, r1	; 0x03
    7162:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
				VSYNC_Count = 0; 
    7166:	10 92 1b 0d 	sts	0x0D1B, r1
    716a:	10 92 1a 0d 	sts	0x0D1A, r1
				FIFO_Reset();
    716e:	0f 90       	pop	r0
    7170:	0f 90       	pop	r0
    7172:	0f 90       	pop	r0
    7174:	0f 90       	pop	r0
    7176:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <FIFO_Reset>
				return 1;
    717a:	81 e0       	ldi	r24, 0x01	; 1
    717c:	40 c0       	rjmp	.+128    	; 0x71fe <GetImageIfAvailiable+0x194>
    717e:	80 e8       	ldi	r24, 0x80	; 128
    7180:	9d ef       	ldi	r25, 0xFD	; 253
    7182:	af ef       	ldi	r26, 0xFF	; 255
    7184:	bf ef       	ldi	r27, 0xFF	; 255
    7186:	88 0e       	add	r8, r24
    7188:	99 1e       	adc	r9, r25
    718a:	aa 1e       	adc	r10, r26
    718c:	bb 1e       	adc	r11, r27
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
    718e:	48 14       	cp	r4, r8
    7190:	59 04       	cpc	r5, r9
    7192:	6a 04       	cpc	r6, r10
    7194:	7b 04       	cpc	r7, r11
    7196:	11 f0       	breq	.+4      	; 0x719c <GetImageIfAvailiable+0x132>
    7198:	81 01       	movw	r16, r2
    719a:	b5 cf       	rjmp	.-150    	; 0x7106 <GetImageIfAvailiable+0x9c>
			}
			//xprintf(PSTR("%d:Write File Result %d, pointer location %u\n"), j, f_write(&File[0], Buff, WIDTH * 2, &p), pointer);
		}
		/*f_close(&File);*/
		/*FIFO_Reset();*/
		FIFO_nRRST_CLR; //Reset Read Pointer	
    719c:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_RCLK_SET;
    719e:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
    71a0:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
    71a2:	5f 9a       	sbi	0x0b, 7	; 11
		VSYNC_Count = 0; //No image present in buffer
    71a4:	10 92 1b 0d 	sts	0x0D1B, r1
    71a8:	10 92 1a 0d 	sts	0x0D1A, r1
		xprintf(PSTR("Success!\n"));
    71ac:	00 d0       	rcall	.+0      	; 0x71ae <GetImageIfAvailiable+0x144>
    71ae:	87 e6       	ldi	r24, 0x67	; 103
    71b0:	99 e0       	ldi	r25, 0x09	; 9
    71b2:	ad b7       	in	r26, 0x3d	; 61
    71b4:	be b7       	in	r27, 0x3e	; 62
    71b6:	12 96       	adiw	r26, 0x02	; 2
    71b8:	9c 93       	st	X, r25
    71ba:	8e 93       	st	-X, r24
    71bc:	11 97       	sbiw	r26, 0x01	; 1
    71be:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
		xprintf(PSTR("Closing File: %d\n"), f_close(&File[0]));
    71c2:	0f 90       	pop	r0
    71c4:	0f 90       	pop	r0
    71c6:	85 ed       	ldi	r24, 0xD5	; 213
    71c8:	94 e0       	ldi	r25, 0x04	; 4
    71ca:	0e 94 32 20 	call	0x4064	; 0x4064 <f_close>
    71ce:	00 d0       	rcall	.+0      	; 0x71d0 <GetImageIfAvailiable+0x166>
    71d0:	00 d0       	rcall	.+0      	; 0x71d2 <GetImageIfAvailiable+0x168>
    71d2:	ed b7       	in	r30, 0x3d	; 61
    71d4:	fe b7       	in	r31, 0x3e	; 62
    71d6:	31 96       	adiw	r30, 0x01	; 1
    71d8:	21 e7       	ldi	r18, 0x71	; 113
    71da:	39 e0       	ldi	r19, 0x09	; 9
    71dc:	ad b7       	in	r26, 0x3d	; 61
    71de:	be b7       	in	r27, 0x3e	; 62
    71e0:	12 96       	adiw	r26, 0x02	; 2
    71e2:	3c 93       	st	X, r19
    71e4:	2e 93       	st	-X, r18
    71e6:	11 97       	sbiw	r26, 0x01	; 1
    71e8:	82 83       	std	Z+2, r24	; 0x02
    71ea:	13 82       	std	Z+3, r1	; 0x03
    71ec:	0e 94 14 3b 	call	0x7628	; 0x7628 <xprintf>
		return 1; //Success!
    71f0:	0f 90       	pop	r0
    71f2:	0f 90       	pop	r0
    71f4:	0f 90       	pop	r0
    71f6:	0f 90       	pop	r0
    71f8:	81 e0       	ldi	r24, 0x01	; 1
    71fa:	01 c0       	rjmp	.+2      	; 0x71fe <GetImageIfAvailiable+0x194>
	}
	else
	{
		return 0;// No image available
    71fc:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    71fe:	0f 90       	pop	r0
    7200:	0f 90       	pop	r0
    7202:	0f 90       	pop	r0
    7204:	0f 90       	pop	r0
    7206:	df 91       	pop	r29
    7208:	cf 91       	pop	r28
    720a:	1f 91       	pop	r17
    720c:	0f 91       	pop	r16
    720e:	ff 90       	pop	r15
    7210:	ef 90       	pop	r14
    7212:	df 90       	pop	r13
    7214:	cf 90       	pop	r12
    7216:	bf 90       	pop	r11
    7218:	af 90       	pop	r10
    721a:	9f 90       	pop	r9
    721c:	8f 90       	pop	r8
    721e:	7f 90       	pop	r7
    7220:	6f 90       	pop	r6
    7222:	5f 90       	pop	r5
    7224:	4f 90       	pop	r4
    7226:	3f 90       	pop	r3
    7228:	2f 90       	pop	r2
    722a:	08 95       	ret

0000722c <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    722c:	84 e3       	ldi	r24, 0x34	; 52
    722e:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    7232:	8f ef       	ldi	r24, 0xFF	; 255
    7234:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    7238:	84 e0       	ldi	r24, 0x04	; 4
    723a:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    723e:	08 95       	ret

00007240 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    7240:	80 91 bc 00 	lds	r24, 0x00BC
}
    7244:	81 70       	andi	r24, 0x01	; 1
    7246:	08 95       	ret

00007248 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    7248:	0e 94 20 39 	call	0x7240	; 0x7240 <TWI_Transceiver_Busy>
    724c:	88 23       	and	r24, r24
    724e:	e1 f7       	brne	.-8      	; 0x7248 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    7250:	80 91 7a 02 	lds	r24, 0x027A
    7254:	08 95       	ret

00007256 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    7256:	0f 93       	push	r16
    7258:	1f 93       	push	r17
    725a:	cf 93       	push	r28
    725c:	8c 01       	movw	r16, r24
    725e:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    7260:	0e 94 20 39 	call	0x7240	; 0x7240 <TWI_Transceiver_Busy>
    7264:	88 23       	and	r24, r24
    7266:	e1 f7       	brne	.-8      	; 0x7260 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    7268:	c0 93 85 02 	sts	0x0285, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    726c:	f8 01       	movw	r30, r16
    726e:	80 81       	ld	r24, Z
    7270:	80 93 86 02 	sts	0x0286, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    7274:	80 fd       	sbrc	r24, 0
    7276:	0c c0       	rjmp	.+24     	; 0x7290 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    7278:	c2 30       	cpi	r28, 0x02	; 2
    727a:	50 f0       	brcs	.+20     	; 0x7290 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    727c:	d8 01       	movw	r26, r16
    727e:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    7280:	e7 e8       	ldi	r30, 0x87	; 135
    7282:	f2 e0       	ldi	r31, 0x02	; 2
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    7284:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    7286:	9d 91       	ld	r25, X+
    7288:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    728a:	8f 5f       	subi	r24, 0xFF	; 255
    728c:	8c 17       	cp	r24, r28
    728e:	d9 f7       	brne	.-10     	; 0x7286 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    7290:	10 92 84 02 	sts	0x0284, r1
  TWI_state         = TWI_NO_STATE ;
    7294:	88 ef       	ldi	r24, 0xF8	; 248
    7296:	80 93 7a 02 	sts	0x027A, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    729a:	85 ea       	ldi	r24, 0xA5	; 165
    729c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    72a0:	cf 91       	pop	r28
    72a2:	1f 91       	pop	r17
    72a4:	0f 91       	pop	r16
    72a6:	08 95       	ret

000072a8 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    72a8:	0e 94 20 39 	call	0x7240	; 0x7240 <TWI_Transceiver_Busy>
    72ac:	88 23       	and	r24, r24
    72ae:	e1 f7       	brne	.-8      	; 0x72a8 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    72b0:	10 92 84 02 	sts	0x0284, r1
  TWI_state         = TWI_NO_STATE ;
    72b4:	88 ef       	ldi	r24, 0xF8	; 248
    72b6:	80 93 7a 02 	sts	0x027A, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    72ba:	85 ea       	ldi	r24, 0xA5	; 165
    72bc:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    72c0:	08 95       	ret

000072c2 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    72c2:	1f 93       	push	r17
    72c4:	cf 93       	push	r28
    72c6:	df 93       	push	r29
    72c8:	d8 2f       	mov	r29, r24
    72ca:	19 2f       	mov	r17, r25
    72cc:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    72ce:	0e 94 20 39 	call	0x7240	; 0x7240 <TWI_Transceiver_Busy>
    72d2:	88 23       	and	r24, r24
    72d4:	e1 f7       	brne	.-8      	; 0x72ce <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    72d6:	80 91 84 02 	lds	r24, 0x0284
    72da:	80 ff       	sbrs	r24, 0
    72dc:	0d c0       	rjmp	.+26     	; 0x72f8 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    72de:	cc 23       	and	r28, r28
    72e0:	59 f0       	breq	.+22     	; 0x72f8 <TWI_Get_Data_From_Transceiver+0x36>
    72e2:	a6 e8       	ldi	r26, 0x86	; 134
    72e4:	b2 e0       	ldi	r27, 0x02	; 2
    72e6:	9d 2f       	mov	r25, r29
    72e8:	ed 2f       	mov	r30, r29
    72ea:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    72ec:	8d 91       	ld	r24, X+
    72ee:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    72f0:	8e 2f       	mov	r24, r30
    72f2:	89 1b       	sub	r24, r25
    72f4:	8c 17       	cp	r24, r28
    72f6:	d0 f3       	brcs	.-12     	; 0x72ec <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    72f8:	80 91 84 02 	lds	r24, 0x0284
}
    72fc:	81 70       	andi	r24, 0x01	; 1
    72fe:	df 91       	pop	r29
    7300:	cf 91       	pop	r28
    7302:	1f 91       	pop	r17
    7304:	08 95       	ret

00007306 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    7306:	1f 92       	push	r1
    7308:	0f 92       	push	r0
    730a:	0f b6       	in	r0, 0x3f	; 63
    730c:	0f 92       	push	r0
    730e:	11 24       	eor	r1, r1
    7310:	2f 93       	push	r18
    7312:	3f 93       	push	r19
    7314:	8f 93       	push	r24
    7316:	9f 93       	push	r25
    7318:	ef 93       	push	r30
    731a:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    731c:	80 91 b9 00 	lds	r24, 0x00B9
    7320:	88 32       	cpi	r24, 0x28	; 40
    7322:	d1 f0       	breq	.+52     	; 0x7358 <__vector_26+0x52>
    7324:	89 32       	cpi	r24, 0x29	; 41
    7326:	40 f4       	brcc	.+16     	; 0x7338 <__vector_26+0x32>
    7328:	80 31       	cpi	r24, 0x10	; 16
    732a:	a1 f0       	breq	.+40     	; 0x7354 <__vector_26+0x4e>
    732c:	88 31       	cpi	r24, 0x18	; 24
    732e:	a1 f0       	breq	.+40     	; 0x7358 <__vector_26+0x52>
    7330:	88 30       	cpi	r24, 0x08	; 8
    7332:	09 f0       	breq	.+2      	; 0x7336 <__vector_26+0x30>
    7334:	61 c0       	rjmp	.+194    	; 0x73f8 <__vector_26+0xf2>
    7336:	0e c0       	rjmp	.+28     	; 0x7354 <__vector_26+0x4e>
    7338:	80 34       	cpi	r24, 0x40	; 64
    733a:	b9 f1       	breq	.+110    	; 0x73aa <__vector_26+0xa4>
    733c:	81 34       	cpi	r24, 0x41	; 65
    733e:	20 f4       	brcc	.+8      	; 0x7348 <__vector_26+0x42>
    7340:	88 33       	cpi	r24, 0x38	; 56
    7342:	09 f0       	breq	.+2      	; 0x7346 <__vector_26+0x40>
    7344:	59 c0       	rjmp	.+178    	; 0x73f8 <__vector_26+0xf2>
    7346:	54 c0       	rjmp	.+168    	; 0x73f0 <__vector_26+0xea>
    7348:	80 35       	cpi	r24, 0x50	; 80
    734a:	19 f1       	breq	.+70     	; 0x7392 <__vector_26+0x8c>
    734c:	88 35       	cpi	r24, 0x58	; 88
    734e:	09 f0       	breq	.+2      	; 0x7352 <__vector_26+0x4c>
    7350:	53 c0       	rjmp	.+166    	; 0x73f8 <__vector_26+0xf2>
    7352:	3d c0       	rjmp	.+122    	; 0x73ce <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    7354:	10 92 8a 02 	sts	0x028A, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    7358:	80 91 8a 02 	lds	r24, 0x028A
    735c:	90 91 85 02 	lds	r25, 0x0285
    7360:	89 17       	cp	r24, r25
    7362:	70 f4       	brcc	.+28     	; 0x7380 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    7364:	e8 2f       	mov	r30, r24
    7366:	f0 e0       	ldi	r31, 0x00	; 0
    7368:	ea 57       	subi	r30, 0x7A	; 122
    736a:	fd 4f       	sbci	r31, 0xFD	; 253
    736c:	90 81       	ld	r25, Z
    736e:	90 93 bb 00 	sts	0x00BB, r25
    7372:	8f 5f       	subi	r24, 0xFF	; 255
    7374:	80 93 8a 02 	sts	0x028A, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    7378:	85 e8       	ldi	r24, 0x85	; 133
    737a:	80 93 bc 00 	sts	0x00BC, r24
    737e:	43 c0       	rjmp	.+134    	; 0x7406 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    7380:	80 91 84 02 	lds	r24, 0x0284
    7384:	81 60       	ori	r24, 0x01	; 1
    7386:	80 93 84 02 	sts	0x0284, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    738a:	84 e9       	ldi	r24, 0x94	; 148
    738c:	80 93 bc 00 	sts	0x00BC, r24
    7390:	3a c0       	rjmp	.+116    	; 0x7406 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    7392:	80 91 8a 02 	lds	r24, 0x028A
    7396:	90 91 bb 00 	lds	r25, 0x00BB
    739a:	e8 2f       	mov	r30, r24
    739c:	f0 e0       	ldi	r31, 0x00	; 0
    739e:	ea 57       	subi	r30, 0x7A	; 122
    73a0:	fd 4f       	sbci	r31, 0xFD	; 253
    73a2:	90 83       	st	Z, r25
    73a4:	8f 5f       	subi	r24, 0xFF	; 255
    73a6:	80 93 8a 02 	sts	0x028A, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    73aa:	20 91 8a 02 	lds	r18, 0x028A
    73ae:	30 e0       	ldi	r19, 0x00	; 0
    73b0:	80 91 85 02 	lds	r24, 0x0285
    73b4:	90 e0       	ldi	r25, 0x00	; 0
    73b6:	01 97       	sbiw	r24, 0x01	; 1
    73b8:	28 17       	cp	r18, r24
    73ba:	39 07       	cpc	r19, r25
    73bc:	24 f4       	brge	.+8      	; 0x73c6 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    73be:	85 ec       	ldi	r24, 0xC5	; 197
    73c0:	80 93 bc 00 	sts	0x00BC, r24
    73c4:	20 c0       	rjmp	.+64     	; 0x7406 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    73c6:	85 e8       	ldi	r24, 0x85	; 133
    73c8:	80 93 bc 00 	sts	0x00BC, r24
    73cc:	1c c0       	rjmp	.+56     	; 0x7406 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    73ce:	80 91 bb 00 	lds	r24, 0x00BB
    73d2:	e0 91 8a 02 	lds	r30, 0x028A
    73d6:	f0 e0       	ldi	r31, 0x00	; 0
    73d8:	ea 57       	subi	r30, 0x7A	; 122
    73da:	fd 4f       	sbci	r31, 0xFD	; 253
    73dc:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    73de:	80 91 84 02 	lds	r24, 0x0284
    73e2:	81 60       	ori	r24, 0x01	; 1
    73e4:	80 93 84 02 	sts	0x0284, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    73e8:	84 e9       	ldi	r24, 0x94	; 148
    73ea:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    73ee:	0b c0       	rjmp	.+22     	; 0x7406 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    73f0:	85 ea       	ldi	r24, 0xA5	; 165
    73f2:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    73f6:	07 c0       	rjmp	.+14     	; 0x7406 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    73f8:	80 91 b9 00 	lds	r24, 0x00B9
    73fc:	80 93 7a 02 	sts	0x027A, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    7400:	84 e0       	ldi	r24, 0x04	; 4
    7402:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    7406:	ff 91       	pop	r31
    7408:	ef 91       	pop	r30
    740a:	9f 91       	pop	r25
    740c:	8f 91       	pop	r24
    740e:	3f 91       	pop	r19
    7410:	2f 91       	pop	r18
    7412:	0f 90       	pop	r0
    7414:	0f be       	out	0x3f, r0	; 63
    7416:	0f 90       	pop	r0
    7418:	1f 90       	pop	r1
    741a:	18 95       	reti

0000741c <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    741c:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    7420:	8c e0       	ldi	r24, 0x0C	; 12
    7422:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    7426:	88 e1       	ldi	r24, 0x18	; 24
    7428:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    742c:	86 e0       	ldi	r24, 0x06	; 6
    742e:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    7432:	08 95       	ret

00007434 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    7434:	e0 ec       	ldi	r30, 0xC0	; 192
    7436:	f0 e0       	ldi	r31, 0x00	; 0
    7438:	90 81       	ld	r25, Z
    743a:	95 ff       	sbrs	r25, 5
    743c:	fd cf       	rjmp	.-6      	; 0x7438 <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    743e:	80 93 c6 00 	sts	0x00C6, r24
}
    7442:	08 95       	ret

00007444 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    7444:	e0 ec       	ldi	r30, 0xC0	; 192
    7446:	f0 e0       	ldi	r31, 0x00	; 0
    7448:	80 81       	ld	r24, Z
    744a:	88 23       	and	r24, r24
    744c:	ec f7       	brge	.-6      	; 0x7448 <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	return UDR0;
    744e:	80 91 c6 00 	lds	r24, 0x00C6
}
    7452:	08 95       	ret

00007454 <Usart_printf>:
int Usart_printf(char var, FILE *stream) {
    7454:	cf 93       	push	r28
    7456:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    7458:	8a 30       	cpi	r24, 0x0A	; 10
    745a:	19 f4       	brne	.+6      	; 0x7462 <Usart_printf+0xe>
    745c:	8d e0       	ldi	r24, 0x0D	; 13
    745e:	0e 94 1a 3a 	call	0x7434	; 0x7434 <Usart_SendChar>
    Usart_SendChar(var);
    7462:	8c 2f       	mov	r24, r28
    7464:	0e 94 1a 3a 	call	0x7434	; 0x7434 <Usart_SendChar>
    return 0;
}
    7468:	80 e0       	ldi	r24, 0x00	; 0
    746a:	90 e0       	ldi	r25, 0x00	; 0
    746c:	cf 91       	pop	r28
    746e:	08 95       	ret

00007470 <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    7470:	ef 92       	push	r14
    7472:	ff 92       	push	r15
    7474:	0f 93       	push	r16
    7476:	1f 93       	push	r17
    7478:	cf 93       	push	r28
    747a:	df 93       	push	r29
    747c:	7c 01       	movw	r14, r24
	char c;
	int i = 0;
    747e:	c0 e0       	ldi	r28, 0x00	; 0
    7480:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    7482:	8b 01       	movw	r16, r22
    7484:	01 50       	subi	r16, 0x01	; 1
    7486:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    7488:	0e 94 22 3a 	call	0x7444	; 0x7444 <Usart_Receive>
		if (c == '\r') break;
    748c:	8d 30       	cpi	r24, 0x0D	; 13
    748e:	a9 f0       	breq	.+42     	; 0x74ba <Usart_get_line+0x4a>
		if ((c == '\b') && i) {
    7490:	88 30       	cpi	r24, 0x08	; 8
    7492:	31 f4       	brne	.+12     	; 0x74a0 <Usart_get_line+0x30>
    7494:	20 97       	sbiw	r28, 0x00	; 0
    7496:	c1 f3       	breq	.-16     	; 0x7488 <Usart_get_line+0x18>
			i--;
    7498:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    749a:	0e 94 1a 3a 	call	0x7434	; 0x7434 <Usart_SendChar>
			continue;
    749e:	f4 cf       	rjmp	.-24     	; 0x7488 <Usart_get_line+0x18>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    74a0:	80 32       	cpi	r24, 0x20	; 32
    74a2:	90 f3       	brcs	.-28     	; 0x7488 <Usart_get_line+0x18>
    74a4:	c0 17       	cp	r28, r16
    74a6:	d1 07       	cpc	r29, r17
    74a8:	7c f7       	brge	.-34     	; 0x7488 <Usart_get_line+0x18>
			buff[i++] = c;
    74aa:	f7 01       	movw	r30, r14
    74ac:	ec 0f       	add	r30, r28
    74ae:	fd 1f       	adc	r31, r29
    74b0:	80 83       	st	Z, r24
    74b2:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    74b4:	0e 94 1a 3a 	call	0x7434	; 0x7434 <Usart_SendChar>
    74b8:	e7 cf       	rjmp	.-50     	; 0x7488 <Usart_get_line+0x18>
		}
	}
	buff[i] = 0;
    74ba:	ce 0d       	add	r28, r14
    74bc:	df 1d       	adc	r29, r15
    74be:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    74c0:	8a e0       	ldi	r24, 0x0A	; 10
    74c2:	0e 94 1a 3a 	call	0x7434	; 0x7434 <Usart_SendChar>
    74c6:	df 91       	pop	r29
    74c8:	cf 91       	pop	r28
    74ca:	1f 91       	pop	r17
    74cc:	0f 91       	pop	r16
    74ce:	ff 90       	pop	r15
    74d0:	ef 90       	pop	r14
    74d2:	08 95       	ret

000074d4 <xputc>:

.func xputc
.global xputc
xputc:
#if CR_CRLF
	cpi	r24, 10		;LF --> CRLF
    74d4:	8a 30       	cpi	r24, 0x0A	; 10
	brne	1f		;
    74d6:	19 f4       	brne	.+6      	; 0x74de <xputc+0xa>
	ldi	r24, 13		;
    74d8:	8d e0       	ldi	r24, 0x0D	; 13
	rcall	1f		;
    74da:	01 d0       	rcall	.+2      	; 0x74de <xputc+0xa>
	ldi	r24, 10		;/
    74dc:	8a e0       	ldi	r24, 0x0A	; 10
1:
#endif
	push	ZH
    74de:	ff 93       	push	r31
	push	ZL
    74e0:	ef 93       	push	r30
	lds	ZL, xfunc_out+0	;Pointer to the registered output function.
    74e2:	e0 91 8b 02 	lds	r30, 0x028B
	lds	ZH, xfunc_out+1	;/
    74e6:	f0 91 8c 02 	lds	r31, 0x028C
	sbiw	ZL, 0		;Skip if null
    74ea:	30 97       	sbiw	r30, 0x00	; 0
	breq	2f		;/
    74ec:	09 f0       	breq	.+2      	; 0x74f0 <xputc+0x1c>
	icall
    74ee:	09 95       	icall
2:	pop	ZL
    74f0:	ef 91       	pop	r30
	pop	ZH
    74f2:	ff 91       	pop	r31
	ret
    74f4:	08 95       	ret

000074f6 <xputs>:
;			);

.func xputs
.global xputs
xputs:
	_MOVW	ZH,ZL, r25,r24	; Z = pointer to rom string
    74f6:	fc 01       	movw	r30, r24
1:	_LPMI	r24
    74f8:	85 91       	lpm	r24, Z+
	cpi	r24, 0
    74fa:	80 30       	cpi	r24, 0x00	; 0
	breq	2f
    74fc:	11 f0       	breq	.+4      	; 0x7502 <xputs+0xc>
	rcall	xputc
    74fe:	ea df       	rcall	.-44     	; 0x74d4 <xputc>
	rjmp	1b
    7500:	fb cf       	rjmp	.-10     	; 0x74f8 <xputs+0x2>
2:	ret
    7502:	08 95       	ret

00007504 <xitoa>:

.func xitoa
.global xitoa
xitoa:
				;r25:r22 = value, r20 = base, r18 = digits
	clr	r31		;r31 = stack level
    7504:	ff 27       	eor	r31, r31
	ldi	r30, ' '	;r30 = sign
    7506:	e0 e2       	ldi	r30, 0x20	; 32
	ldi	r19, ' '	;r19 = filler
    7508:	30 e2       	ldi	r19, 0x20	; 32
	sbrs	r20, 7		;When base indicates signd format and the value
    750a:	47 ff       	sbrs	r20, 7
	rjmp	0f		;is minus, add a '-'.
    750c:	0c c0       	rjmp	.+24     	; 0x7526 <xitoa+0x22>
	neg	r20		;
    750e:	41 95       	neg	r20
	sbrs	r25, 7		;
    7510:	97 ff       	sbrs	r25, 7
	rjmp	0f		;
    7512:	09 c0       	rjmp	.+18     	; 0x7526 <xitoa+0x22>
	ldi	r30, '-'	;
    7514:	ed e2       	ldi	r30, 0x2D	; 45
	com	r22		;
    7516:	60 95       	com	r22
	com	r23		;
    7518:	70 95       	com	r23
	com	r24		;
    751a:	80 95       	com	r24
	com	r25		;
    751c:	90 95       	com	r25
	adc	r22, r1		;
    751e:	61 1d       	adc	r22, r1
	adc	r23, r1		;
    7520:	71 1d       	adc	r23, r1
	adc	r24, r1		;
    7522:	81 1d       	adc	r24, r1
	adc	r25, r1		;/
    7524:	91 1d       	adc	r25, r1
0:	sbrs	r18, 7		;When digits indicates zero filled,
    7526:	27 ff       	sbrs	r18, 7
	rjmp	1f		;filler is '0'.
    7528:	02 c0       	rjmp	.+4      	; 0x752e <xitoa+0x2a>
	neg	r18		;
    752a:	21 95       	neg	r18
	ldi	r19, '0'	;/
    752c:	30 e3       	ldi	r19, 0x30	; 48
				;----- string conversion loop
1:	ldi	r21, 32		;r26 = r25:r22 % r20
    752e:	50 e2       	ldi	r21, 0x20	; 32
	clr	r26		;r25:r22 /= r20
    7530:	aa 27       	eor	r26, r26
2:	lsl	r22		;
    7532:	66 0f       	add	r22, r22
	rol	r23		;
    7534:	77 1f       	adc	r23, r23
	rol	r24		;
    7536:	88 1f       	adc	r24, r24
	rol	r25		;
    7538:	99 1f       	adc	r25, r25
	rol	r26		;
    753a:	aa 1f       	adc	r26, r26
	cp	r26, r20	;
    753c:	a4 17       	cp	r26, r20
	brcs	3f		;
    753e:	10 f0       	brcs	.+4      	; 0x7544 <xitoa+0x40>
	sub	r26, r20	;
    7540:	a4 1b       	sub	r26, r20
	inc	r22		;
    7542:	63 95       	inc	r22
3:	dec	r21		;
    7544:	5a 95       	dec	r21
	brne	2b		;/
    7546:	a9 f7       	brne	.-22     	; 0x7532 <xitoa+0x2e>
	cpi	r26, 10		;r26 is a numeral digit '0'-'F'
    7548:	aa 30       	cpi	r26, 0x0A	; 10
	brcs	4f		;
    754a:	08 f0       	brcs	.+2      	; 0x754e <xitoa+0x4a>
	subi	r26, -7		;
    754c:	a9 5f       	subi	r26, 0xF9	; 249
4:	subi	r26, -'0'	;/
    754e:	a0 5d       	subi	r26, 0xD0	; 208
	push	r26		;Stack it
    7550:	af 93       	push	r26
	inc	r31		;/
    7552:	f3 95       	inc	r31
	cp	r22, r1		;Repeat until r25:r22 gets zero
    7554:	61 15       	cp	r22, r1
	cpc	r23, r1		;
    7556:	71 05       	cpc	r23, r1
	cpc	r24, r1		;
    7558:	81 05       	cpc	r24, r1
	cpc	r25, r1		;
    755a:	91 05       	cpc	r25, r1
	brne	1b		;/
    755c:	41 f7       	brne	.-48     	; 0x752e <xitoa+0x2a>

	cpi	r30, '-'	;Minus sign if needed
    755e:	ed 32       	cpi	r30, 0x2D	; 45
	brne	5f		;
    7560:	11 f4       	brne	.+4      	; 0x7566 <xitoa+0x62>
	push	r30		;
    7562:	ef 93       	push	r30
	inc	r31		;/
    7564:	f3 95       	inc	r31
5:	cp	r31, r18	;Filler
    7566:	f2 17       	cp	r31, r18
	brcc	6f		;
    7568:	18 f4       	brcc	.+6      	; 0x7570 <xitoa+0x6c>
	push	r19		;
    756a:	3f 93       	push	r19
	inc	r31		;
    756c:	f3 95       	inc	r31
	rjmp	5b		;/
    756e:	fb cf       	rjmp	.-10     	; 0x7566 <xitoa+0x62>

6:	pop	r24		;Flush stacked digits and exit
    7570:	8f 91       	pop	r24
	rcall	xputc		;
    7572:	b0 df       	rcall	.-160    	; 0x74d4 <xputc>
	dec	r31		;
    7574:	fa 95       	dec	r31
	brne	6b		;/
    7576:	e1 f7       	brne	.-8      	; 0x7570 <xitoa+0x6c>

	ret
    7578:	08 95       	ret

0000757a <xvprintf>:

#if USE_XPRINTF

.func xvprintf
xvprintf:
	ld	ZL, Y+		;Z = pointer to format string
    757a:	e9 91       	ld	r30, Y+
	ld	ZH, Y+		;/
    757c:	f9 91       	ld	r31, Y+

0:	_LPMI	r24		;Get a format char
    757e:	85 91       	lpm	r24, Z+
	cpi	r24, 0		;End of format string?
    7580:	80 30       	cpi	r24, 0x00	; 0
	breq	90f		;/
    7582:	21 f0       	breq	.+8      	; 0x758c <xvprintf+0x12>
	cpi	r24, '%'	;Is format?
    7584:	85 32       	cpi	r24, 0x25	; 37
	breq	20f		;/
    7586:	19 f0       	breq	.+6      	; 0x758e <xvprintf+0x14>
1:	rcall	xputc		;Put a normal character
    7588:	a5 df       	rcall	.-182    	; 0x74d4 <xputc>
	rjmp	0b		;/
    758a:	f9 cf       	rjmp	.-14     	; 0x757e <xvprintf+0x4>
90:	ret
    758c:	08 95       	ret

20:	ldi	r18, 0		;r18: digits
    758e:	20 e0       	ldi	r18, 0x00	; 0
	clt			;T: filler
    7590:	e8 94       	clt
	_LPMI	r21		;Get flags
    7592:	55 91       	lpm	r21, Z+
	cpi	r21, '%'	;Is a %?
    7594:	55 32       	cpi	r21, 0x25	; 37
	breq	1b		;/
    7596:	c1 f3       	breq	.-16     	; 0x7588 <xvprintf+0xe>
	cpi	r21, '0'	;Zero filled?
    7598:	50 33       	cpi	r21, 0x30	; 48
	brne	23f		;
    759a:	11 f4       	brne	.+4      	; 0x75a0 <xvprintf+0x26>
	set			;/
    759c:	68 94       	set
22:	_LPMI	r21		;Get width
    759e:	55 91       	lpm	r21, Z+
23:	cpi	r21, '9'+1	;
    75a0:	5a 33       	cpi	r21, 0x3A	; 58
	brcc	24f		;
    75a2:	48 f4       	brcc	.+18     	; 0x75b6 <xvprintf+0x3c>
	subi	r21, '0'	;
    75a4:	50 53       	subi	r21, 0x30	; 48
	brcs	90b		;
    75a6:	90 f3       	brcs	.-28     	; 0x758c <xvprintf+0x12>
	lsl	r18		;
    75a8:	22 0f       	add	r18, r18
	mov	r0, r18		;
    75aa:	02 2e       	mov	r0, r18
	lsl	r18		;
    75ac:	22 0f       	add	r18, r18
	lsl	r18		;
    75ae:	22 0f       	add	r18, r18
	add	r18, r0		;
    75b0:	20 0d       	add	r18, r0
	add	r18, r21	;
    75b2:	25 0f       	add	r18, r21
	rjmp	22b		;/
    75b4:	f4 cf       	rjmp	.-24     	; 0x759e <xvprintf+0x24>

24:	brtc	25f		;get value (low word)
    75b6:	0e f4       	brtc	.+2      	; 0x75ba <xvprintf+0x40>
	neg	r18		;
    75b8:	21 95       	neg	r18
25:	ld	r24, Y+		;
    75ba:	89 91       	ld	r24, Y+
	ld	r25, Y+		;/
    75bc:	99 91       	ld	r25, Y+
	cpi	r21, 'c'	;Is type character?
    75be:	53 36       	cpi	r21, 0x63	; 99
	breq	1b		;/
    75c0:	19 f3       	breq	.-58     	; 0x7588 <xvprintf+0xe>
	cpi	r21, 's'	;Is type RAM string?
    75c2:	53 37       	cpi	r21, 0x73	; 115
	breq	50f		;/
    75c4:	29 f1       	breq	.+74     	; 0x7610 <xvprintf+0x96>
	cpi	r21, 'S'	;Is type ROM string?
    75c6:	53 35       	cpi	r21, 0x53	; 83
	breq	60f		;/
    75c8:	59 f1       	breq	.+86     	; 0x7620 <xvprintf+0xa6>
	_MOVW	r23,r22,r25,r24	;r25:r22 = value
    75ca:	bc 01       	movw	r22, r24
	clr	r24		;
    75cc:	88 27       	eor	r24, r24
	clr	r25		;
    75ce:	99 27       	eor	r25, r25
	clt			;/
    75d0:	e8 94       	clt
	cpi	r21, 'l'	;Is long int?
    75d2:	5c 36       	cpi	r21, 0x6C	; 108
	brne	26f		;
    75d4:	21 f4       	brne	.+8      	; 0x75de <xvprintf+0x64>
	ld	r24, Y+		;get value (high word)
    75d6:	89 91       	ld	r24, Y+
	ld	r25, Y+		;
    75d8:	99 91       	ld	r25, Y+
	set			;
    75da:	68 94       	set
	_LPMI	r21		;/
    75dc:	55 91       	lpm	r21, Z+
26:	cpi	r21, 'd'	;Is type signed decimal?
    75de:	54 36       	cpi	r21, 0x64	; 100
	brne	27f		;/
    75e0:	39 f4       	brne	.+14     	; 0x75f0 <xvprintf+0x76>
	ldi	r20, -10	;
    75e2:	46 ef       	ldi	r20, 0xF6	; 246
	brts	40f		;
    75e4:	7e f0       	brts	.+30     	; 0x7604 <xvprintf+0x8a>
	sbrs	r23, 7		;
    75e6:	77 ff       	sbrs	r23, 7
	rjmp	40f		;
    75e8:	0d c0       	rjmp	.+26     	; 0x7604 <xvprintf+0x8a>
	ldi	r24, -1		;
    75ea:	8f ef       	ldi	r24, 0xFF	; 255
	ldi	r25, -1		;
    75ec:	9f ef       	ldi	r25, 0xFF	; 255
	rjmp	40f		;/
    75ee:	0a c0       	rjmp	.+20     	; 0x7604 <xvprintf+0x8a>
27:	cpi	r21, 'u'	;Is type unsigned decimal?
    75f0:	55 37       	cpi	r21, 0x75	; 117
	ldi	r20, 10		;
    75f2:	4a e0       	ldi	r20, 0x0A	; 10
	breq	40f		;/
    75f4:	39 f0       	breq	.+14     	; 0x7604 <xvprintf+0x8a>
	cpi	r21, 'X'	;Is type hexdecimal?
    75f6:	58 35       	cpi	r21, 0x58	; 88
	ldi	r20, 16		;
    75f8:	40 e1       	ldi	r20, 0x10	; 16
	breq	40f		;/
    75fa:	21 f0       	breq	.+8      	; 0x7604 <xvprintf+0x8a>
	cpi	r21, 'b'	;Is type binary?
    75fc:	52 36       	cpi	r21, 0x62	; 98
	ldi	r20, 2		;
    75fe:	42 e0       	ldi	r20, 0x02	; 2
	breq	40f		;/
    7600:	09 f0       	breq	.+2      	; 0x7604 <xvprintf+0x8a>
	ret			;abort
    7602:	08 95       	ret
40:	push	ZH		;Output the value
    7604:	ff 93       	push	r31
	push	ZL		;
    7606:	ef 93       	push	r30
	rcall	xitoa		;
    7608:	7d df       	rcall	.-262    	; 0x7504 <xitoa>
42:	pop	ZL		;
    760a:	ef 91       	pop	r30
	pop	ZH		;
    760c:	ff 91       	pop	r31
	rjmp	0b		;/
    760e:	b7 cf       	rjmp	.-146    	; 0x757e <xvprintf+0x4>

50:	push	ZH		;Put a string on the RAM
    7610:	ff 93       	push	r31
	push	ZL
    7612:	ef 93       	push	r30
	_MOVW	ZH,ZL, r25,r24
    7614:	fc 01       	movw	r30, r24
51:	ld	r24, Z+
    7616:	81 91       	ld	r24, Z+
	cpi	r24, 0
    7618:	80 30       	cpi	r24, 0x00	; 0
	breq	42b
    761a:	b9 f3       	breq	.-18     	; 0x760a <xvprintf+0x90>
	rcall	xputc
    761c:	5b df       	rcall	.-330    	; 0x74d4 <xputc>
	rjmp	51b
    761e:	fb cf       	rjmp	.-10     	; 0x7616 <xvprintf+0x9c>

60:	push	ZH		;Put a string on the ROM
    7620:	ff 93       	push	r31
	push	ZL
    7622:	ef 93       	push	r30
	rcall	xputs
    7624:	68 df       	rcall	.-304    	; 0x74f6 <xputs>
	rjmp	42b
    7626:	f1 cf       	rjmp	.-30     	; 0x760a <xvprintf+0x90>

00007628 <xprintf>:


.func xprintf
.global xprintf
xprintf:
	push	YH
    7628:	df 93       	push	r29
	push	YL
    762a:	cf 93       	push	r28
	in	YL, _SFR_IO_ADDR(SPL)
    762c:	cd b7       	in	r28, 0x3d	; 61
#ifdef SPH
	in	YH, _SFR_IO_ADDR(SPH)
    762e:	de b7       	in	r29, 0x3e	; 62
#else
	clr	YH
#endif
	adiw	YL, 5		;Y = pointer to arguments
    7630:	25 96       	adiw	r28, 0x05	; 5
	rcall	xvprintf
    7632:	a3 df       	rcall	.-186    	; 0x757a <xvprintf>
	pop	YL
    7634:	cf 91       	pop	r28
	pop	YH
    7636:	df 91       	pop	r29
	ret
    7638:	08 95       	ret

0000763a <xatoi>:

#if USE_XATOI
.func xatoi
.global xatoi
xatoi:
	_MOVW	r1, r0, r23, r22
    763a:	0b 01       	movw	r0, r22
	_MOVW	XH, XL, r25, r24
    763c:	dc 01       	movw	r26, r24
	ld	ZL, X+
    763e:	ed 91       	ld	r30, X+
	ld	ZH, X+
    7640:	fd 91       	ld	r31, X+
	clr	r18		;r21:r18 = 0;
    7642:	22 27       	eor	r18, r18
	clr	r19		;
    7644:	33 27       	eor	r19, r19
	clr	r20		;
    7646:	44 27       	eor	r20, r20
	clr	r21		;/
    7648:	55 27       	eor	r21, r21
	clt			;T = 0;
    764a:	e8 94       	clt

	ldi	r25, 10		;r25 = 10;
    764c:	9a e0       	ldi	r25, 0x0A	; 10
	rjmp	41f		;/
    764e:	01 c0       	rjmp	.+2      	; 0x7652 <xatoi+0x18>
40:	adiw	ZL, 1		;Z++;
    7650:	31 96       	adiw	r30, 0x01	; 1
41:	ld	r22, Z		;r22 = *Z;
    7652:	60 81       	ld	r22, Z
	cpi	r22, ' '	;if(r22 == ' ') continue
    7654:	60 32       	cpi	r22, 0x20	; 32
	breq	40b		;/
    7656:	e1 f3       	breq	.-8      	; 0x7650 <xatoi+0x16>
	brcs	70f		;if(r22 < ' ') error;
    7658:	a8 f1       	brcs	.+106    	; 0x76c4 <xatoi+0x8a>
	cpi	r22, '-'	;if(r22 == '-') {
    765a:	6d 32       	cpi	r22, 0x2D	; 45
	brne	42f		; T = 1;
    765c:	11 f4       	brne	.+4      	; 0x7662 <xatoi+0x28>
	set			; continue;
    765e:	68 94       	set
	rjmp	40b		;}
    7660:	f7 cf       	rjmp	.-18     	; 0x7650 <xatoi+0x16>
42:	cpi	r22, '9'+1	;if(r22 > '9') error;
    7662:	6a 33       	cpi	r22, 0x3A	; 58
	brcc	70f		;/
    7664:	78 f5       	brcc	.+94     	; 0x76c4 <xatoi+0x8a>
	cpi	r22, '0'	;if(r22 < '0') error;
    7666:	60 33       	cpi	r22, 0x30	; 48
	brcs	70f		;/
    7668:	68 f1       	brcs	.+90     	; 0x76c4 <xatoi+0x8a>
	brne	51f		;if(r22 > '0') cv_start;
    766a:	71 f4       	brne	.+28     	; 0x7688 <xatoi+0x4e>
	ldi	r25, 8		;r25 = 8;
    766c:	98 e0       	ldi	r25, 0x08	; 8
	adiw	ZL, 1		;r22 = *(++Z);
    766e:	31 96       	adiw	r30, 0x01	; 1
	ld	r22, Z		;/
    7670:	60 81       	ld	r22, Z
	cpi	r22, ' '+1	;if(r22 <= ' ') exit;
    7672:	61 32       	cpi	r22, 0x21	; 33
	brcs	80f		;/
    7674:	48 f1       	brcs	.+82     	; 0x76c8 <xatoi+0x8e>
	cpi	r22, 'b'	;if(r22 == 'b') {
    7676:	62 36       	cpi	r22, 0x62	; 98
	brne	43f		; r25 = 2;
    7678:	11 f4       	brne	.+4      	; 0x767e <xatoi+0x44>
	ldi	r25, 2		; cv_start;
    767a:	92 e0       	ldi	r25, 0x02	; 2
	rjmp	50f		;}
    767c:	03 c0       	rjmp	.+6      	; 0x7684 <xatoi+0x4a>
43:	cpi	r22, 'x'	;if(r22 != 'x') error;
    767e:	68 37       	cpi	r22, 0x78	; 120
	brne	51f		;/
    7680:	19 f4       	brne	.+6      	; 0x7688 <xatoi+0x4e>
	ldi	r25, 16		;r25 = 16;
    7682:	90 e1       	ldi	r25, 0x10	; 16

50:	adiw	ZL, 1		;Z++;
    7684:	31 96       	adiw	r30, 0x01	; 1
	ld	r22, Z		;r22 = *Z;
    7686:	60 81       	ld	r22, Z
51:	cpi	r22, ' '+1	;if(r22 <= ' ') break;
    7688:	61 32       	cpi	r22, 0x21	; 33
	brcs	80f		;/
    768a:	f0 f0       	brcs	.+60     	; 0x76c8 <xatoi+0x8e>
	cpi	r22, 'a'	;if(r22 >= 'a') r22 =- 0x20;
    768c:	61 36       	cpi	r22, 0x61	; 97
	brcs	52f		;
    768e:	08 f0       	brcs	.+2      	; 0x7692 <xatoi+0x58>
	subi	r22, 0x20	;/
    7690:	60 52       	subi	r22, 0x20	; 32
52:	subi	r22, '0'	;if((r22 -= '0') < 0) error;
    7692:	60 53       	subi	r22, 0x30	; 48
	brcs	70f		;/
    7694:	b8 f0       	brcs	.+46     	; 0x76c4 <xatoi+0x8a>
	cpi	r22, 10		;if(r22 >= 10) {
    7696:	6a 30       	cpi	r22, 0x0A	; 10
	brcs	53f		; r22 -= 7;
    7698:	18 f0       	brcs	.+6      	; 0x76a0 <xatoi+0x66>
	subi	r22, 7		; if(r22 < 10) 
    769a:	67 50       	subi	r22, 0x07	; 7
	cpi	r22, 10		;
    769c:	6a 30       	cpi	r22, 0x0A	; 10
	brcs	70f		;}
    769e:	90 f0       	brcs	.+36     	; 0x76c4 <xatoi+0x8a>
53:	cp	r22, r25	;if(r22 >= r25) error;
    76a0:	69 17       	cp	r22, r25
	brcc	70f		;/
    76a2:	80 f4       	brcc	.+32     	; 0x76c4 <xatoi+0x8a>
60:	ldi	r24, 33		;r21:r18 *= r25;
    76a4:	81 e2       	ldi	r24, 0x21	; 33
	sub	r23, r23	;
    76a6:	77 1b       	sub	r23, r23
61:	brcc	62f		;
    76a8:	08 f4       	brcc	.+2      	; 0x76ac <xatoi+0x72>
	add	r23, r25	;
    76aa:	79 0f       	add	r23, r25
62:	lsr	r23		;
    76ac:	76 95       	lsr	r23
	ror	r21		;
    76ae:	57 95       	ror	r21
	ror	r20		;
    76b0:	47 95       	ror	r20
	ror	r19		;
    76b2:	37 95       	ror	r19
	ror	r18		;
    76b4:	27 95       	ror	r18
	dec	r24		;
    76b6:	8a 95       	dec	r24
	brne	61b		;/
    76b8:	b9 f7       	brne	.-18     	; 0x76a8 <xatoi+0x6e>
	add	r18, r22	;r21:r18 += r22;
    76ba:	26 0f       	add	r18, r22
	adc	r19, r24	;
    76bc:	38 1f       	adc	r19, r24
	adc	r20, r24	;
    76be:	48 1f       	adc	r20, r24
	adc	r21, r24	;/
    76c0:	58 1f       	adc	r21, r24
	rjmp	50b		;repeat
    76c2:	e0 cf       	rjmp	.-64     	; 0x7684 <xatoi+0x4a>

70:	ldi	r24, 0
    76c4:	80 e0       	ldi	r24, 0x00	; 0
	rjmp	81f
    76c6:	01 c0       	rjmp	.+2      	; 0x76ca <xatoi+0x90>
80:	ldi	r24, 1
    76c8:	81 e0       	ldi	r24, 0x01	; 1
81:	brtc	82f
    76ca:	4e f4       	brtc	.+18     	; 0x76de <xatoi+0xa4>
	clr	r22
    76cc:	66 27       	eor	r22, r22
	com	r18
    76ce:	20 95       	com	r18
	com	r19
    76d0:	30 95       	com	r19
	com	r20
    76d2:	40 95       	com	r20
	com	r21
    76d4:	50 95       	com	r21
	adc	r18, r22
    76d6:	26 1f       	adc	r18, r22
	adc	r19, r22
    76d8:	36 1f       	adc	r19, r22
	adc	r20, r22
    76da:	46 1f       	adc	r20, r22
	adc	r21, r22
    76dc:	56 1f       	adc	r21, r22
82:	st	-X, ZH
    76de:	fe 93       	st	-X, r31
	st	-X, ZL
    76e0:	ee 93       	st	-X, r30
	_MOVW	XH, XL, r1, r0
    76e2:	d0 01       	movw	r26, r0
	st	X+, r18
    76e4:	2d 93       	st	X+, r18
	st	X+, r19
    76e6:	3d 93       	st	X+, r19
	st	X+, r20
    76e8:	4d 93       	st	X+, r20
	st	X+, r21
    76ea:	5d 93       	st	X+, r21
	clr	r1
    76ec:	11 24       	eor	r1, r1
	ret
    76ee:	08 95       	ret

000076f0 <__mulsi3>:
    76f0:	62 9f       	mul	r22, r18
    76f2:	d0 01       	movw	r26, r0
    76f4:	73 9f       	mul	r23, r19
    76f6:	f0 01       	movw	r30, r0
    76f8:	82 9f       	mul	r24, r18
    76fa:	e0 0d       	add	r30, r0
    76fc:	f1 1d       	adc	r31, r1
    76fe:	64 9f       	mul	r22, r20
    7700:	e0 0d       	add	r30, r0
    7702:	f1 1d       	adc	r31, r1
    7704:	92 9f       	mul	r25, r18
    7706:	f0 0d       	add	r31, r0
    7708:	83 9f       	mul	r24, r19
    770a:	f0 0d       	add	r31, r0
    770c:	74 9f       	mul	r23, r20
    770e:	f0 0d       	add	r31, r0
    7710:	65 9f       	mul	r22, r21
    7712:	f0 0d       	add	r31, r0
    7714:	99 27       	eor	r25, r25
    7716:	72 9f       	mul	r23, r18
    7718:	b0 0d       	add	r27, r0
    771a:	e1 1d       	adc	r30, r1
    771c:	f9 1f       	adc	r31, r25
    771e:	63 9f       	mul	r22, r19
    7720:	b0 0d       	add	r27, r0
    7722:	e1 1d       	adc	r30, r1
    7724:	f9 1f       	adc	r31, r25
    7726:	bd 01       	movw	r22, r26
    7728:	cf 01       	movw	r24, r30
    772a:	11 24       	eor	r1, r1
    772c:	08 95       	ret

0000772e <__udivmodsi4>:
    772e:	a1 e2       	ldi	r26, 0x21	; 33
    7730:	1a 2e       	mov	r1, r26
    7732:	aa 1b       	sub	r26, r26
    7734:	bb 1b       	sub	r27, r27
    7736:	fd 01       	movw	r30, r26
    7738:	0d c0       	rjmp	.+26     	; 0x7754 <__udivmodsi4_ep>

0000773a <__udivmodsi4_loop>:
    773a:	aa 1f       	adc	r26, r26
    773c:	bb 1f       	adc	r27, r27
    773e:	ee 1f       	adc	r30, r30
    7740:	ff 1f       	adc	r31, r31
    7742:	a2 17       	cp	r26, r18
    7744:	b3 07       	cpc	r27, r19
    7746:	e4 07       	cpc	r30, r20
    7748:	f5 07       	cpc	r31, r21
    774a:	20 f0       	brcs	.+8      	; 0x7754 <__udivmodsi4_ep>
    774c:	a2 1b       	sub	r26, r18
    774e:	b3 0b       	sbc	r27, r19
    7750:	e4 0b       	sbc	r30, r20
    7752:	f5 0b       	sbc	r31, r21

00007754 <__udivmodsi4_ep>:
    7754:	66 1f       	adc	r22, r22
    7756:	77 1f       	adc	r23, r23
    7758:	88 1f       	adc	r24, r24
    775a:	99 1f       	adc	r25, r25
    775c:	1a 94       	dec	r1
    775e:	69 f7       	brne	.-38     	; 0x773a <__udivmodsi4_loop>
    7760:	60 95       	com	r22
    7762:	70 95       	com	r23
    7764:	80 95       	com	r24
    7766:	90 95       	com	r25
    7768:	9b 01       	movw	r18, r22
    776a:	ac 01       	movw	r20, r24
    776c:	bd 01       	movw	r22, r26
    776e:	cf 01       	movw	r24, r30
    7770:	08 95       	ret

00007772 <__divmodsi4>:
    7772:	97 fb       	bst	r25, 7
    7774:	09 2e       	mov	r0, r25
    7776:	05 26       	eor	r0, r21
    7778:	0e d0       	rcall	.+28     	; 0x7796 <__divmodsi4_neg1>
    777a:	57 fd       	sbrc	r21, 7
    777c:	04 d0       	rcall	.+8      	; 0x7786 <__divmodsi4_neg2>
    777e:	d7 df       	rcall	.-82     	; 0x772e <__udivmodsi4>
    7780:	0a d0       	rcall	.+20     	; 0x7796 <__divmodsi4_neg1>
    7782:	00 1c       	adc	r0, r0
    7784:	38 f4       	brcc	.+14     	; 0x7794 <__divmodsi4_exit>

00007786 <__divmodsi4_neg2>:
    7786:	50 95       	com	r21
    7788:	40 95       	com	r20
    778a:	30 95       	com	r19
    778c:	21 95       	neg	r18
    778e:	3f 4f       	sbci	r19, 0xFF	; 255
    7790:	4f 4f       	sbci	r20, 0xFF	; 255
    7792:	5f 4f       	sbci	r21, 0xFF	; 255

00007794 <__divmodsi4_exit>:
    7794:	08 95       	ret

00007796 <__divmodsi4_neg1>:
    7796:	f6 f7       	brtc	.-4      	; 0x7794 <__divmodsi4_exit>
    7798:	90 95       	com	r25
    779a:	80 95       	com	r24
    779c:	70 95       	com	r23
    779e:	61 95       	neg	r22
    77a0:	7f 4f       	sbci	r23, 0xFF	; 255
    77a2:	8f 4f       	sbci	r24, 0xFF	; 255
    77a4:	9f 4f       	sbci	r25, 0xFF	; 255
    77a6:	08 95       	ret

000077a8 <memset>:
    77a8:	dc 01       	movw	r26, r24
    77aa:	01 c0       	rjmp	.+2      	; 0x77ae <memset+0x6>
    77ac:	6d 93       	st	X+, r22
    77ae:	41 50       	subi	r20, 0x01	; 1
    77b0:	50 40       	sbci	r21, 0x00	; 0
    77b2:	e0 f7       	brcc	.-8      	; 0x77ac <memset+0x4>
    77b4:	08 95       	ret

000077b6 <strchr>:
    77b6:	fc 01       	movw	r30, r24
    77b8:	81 91       	ld	r24, Z+
    77ba:	86 17       	cp	r24, r22
    77bc:	21 f0       	breq	.+8      	; 0x77c6 <strchr+0x10>
    77be:	88 23       	and	r24, r24
    77c0:	d9 f7       	brne	.-10     	; 0x77b8 <strchr+0x2>
    77c2:	99 27       	eor	r25, r25
    77c4:	08 95       	ret
    77c6:	31 97       	sbiw	r30, 0x01	; 1
    77c8:	cf 01       	movw	r24, r30
    77ca:	08 95       	ret

000077cc <strcpy>:
    77cc:	fb 01       	movw	r30, r22
    77ce:	dc 01       	movw	r26, r24
    77d0:	01 90       	ld	r0, Z+
    77d2:	0d 92       	st	X+, r0
    77d4:	00 20       	and	r0, r0
    77d6:	e1 f7       	brne	.-8      	; 0x77d0 <strcpy+0x4>
    77d8:	08 95       	ret

000077da <__eerd_block_m644p>:
    77da:	dc 01       	movw	r26, r24
    77dc:	cb 01       	movw	r24, r22

000077de <__eerd_blraw_m644p>:
    77de:	fc 01       	movw	r30, r24
    77e0:	f9 99       	sbic	0x1f, 1	; 31
    77e2:	fe cf       	rjmp	.-4      	; 0x77e0 <__eerd_blraw_m644p+0x2>
    77e4:	06 c0       	rjmp	.+12     	; 0x77f2 <__eerd_blraw_m644p+0x14>
    77e6:	f2 bd       	out	0x22, r31	; 34
    77e8:	e1 bd       	out	0x21, r30	; 33
    77ea:	f8 9a       	sbi	0x1f, 0	; 31
    77ec:	31 96       	adiw	r30, 0x01	; 1
    77ee:	00 b4       	in	r0, 0x20	; 32
    77f0:	0d 92       	st	X+, r0
    77f2:	41 50       	subi	r20, 0x01	; 1
    77f4:	50 40       	sbci	r21, 0x00	; 0
    77f6:	b8 f7       	brcc	.-18     	; 0x77e6 <__eerd_blraw_m644p+0x8>
    77f8:	08 95       	ret

000077fa <_exit>:
    77fa:	f8 94       	cli

000077fc <__stop_program>:
    77fc:	ff cf       	rjmp	.-2      	; 0x77fc <__stop_program>
